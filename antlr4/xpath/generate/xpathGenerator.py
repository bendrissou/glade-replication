# Generated by Grammarinator 0.0.0

from itertools import chain
from math import inf
from grammarinator.runtime import *

class xpathGenerator(Generator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)


    @depthcontrol
    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    @depthcontrol
    def main(self, parent=None):
        current = UnparserRule(name='main', parent=parent)
        self.enter_rule(current)
        self.expr(parent=current)
        self.exit_rule(current)
        return current
    main.min_depth = 7

    @depthcontrol
    def locationPath(self, parent=None):
        current = UnparserRule(name='locationPath', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.relativeLocationPath(parent=current)
        elif choice == 1:
            self.absoluteLocationPathNoroot(parent=current)
        self.exit_rule(current)
        return current
    locationPath.min_depth = 3

    @depthcontrol
    def absoluteLocationPathNoroot(self, parent=None):
        current = UnparserRule(name='absoluteLocationPathNoroot', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='/', parent=current)
            self.relativeLocationPath(parent=current)
        elif choice == 1:
            UnlexerRule(src='//', parent=current)
            self.relativeLocationPath(parent=current)
        self.exit_rule(current)
        return current
    absoluteLocationPathNoroot.min_depth = 3

    @depthcontrol
    def relativeLocationPath(self, parent=None):
        current = UnparserRule(name='relativeLocationPath', parent=parent)
        self.enter_rule(current)
        self.step(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='/', parent=current)
                elif choice == 1:
                    UnlexerRule(src='//', parent=current)
                self.step(parent=current)
        self.exit_rule(current)
        return current
    relativeLocationPath.min_depth = 2

    @depthcontrol
    def step(self, parent=None):
        current = UnparserRule(name='step', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.axisSpecifier(parent=current)
            self.nodeTest(parent=current)
            if self.max_depth >= 8:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    self.predicate(parent=current)
        elif choice == 1:
            self.abbreviatedStep(parent=current)
        self.exit_rule(current)
        return current
    step.min_depth = 1

    @depthcontrol
    def axisSpecifier(self, parent=None):
        current = UnparserRule(name='axisSpecifier', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.AxisName(parent=current)
            UnlexerRule(src='::', parent=current)
        elif choice == 1:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src='@', parent=current)
        self.exit_rule(current)
        return current
    axisSpecifier.min_depth = 0

    @depthcontrol
    def nodeTest(self, parent=None):
        current = UnparserRule(name='nodeTest', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.nameTest(parent=current)
        elif choice == 1:
            self.NodeType(parent=current)
            UnlexerRule(src='(', parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 2:
            UnlexerRule(src='processing-instruction', parent=current)
            UnlexerRule(src='(', parent=current)
            self.Literal(parent=current)
            UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    nodeTest.min_depth = 1

    @depthcontrol
    def predicate(self, parent=None):
        current = UnparserRule(name='predicate', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='[', parent=current)
        self.expr(parent=current)
        UnlexerRule(src=']', parent=current)
        self.exit_rule(current)
        return current
    predicate.min_depth = 7

    @depthcontrol
    def abbreviatedStep(self, parent=None):
        current = UnparserRule(name='abbreviatedStep', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='.', parent=current)
        elif choice == 1:
            UnlexerRule(src='..', parent=current)
        self.exit_rule(current)
        return current
    abbreviatedStep.min_depth = 0

    @depthcontrol
    def expr(self, parent=None):
        current = UnparserRule(name='expr', parent=parent)
        self.enter_rule(current)
        self.orExpr(parent=current)
        self.exit_rule(current)
        return current
    expr.min_depth = 6

    @depthcontrol
    def primaryExpr(self, parent=None):
        current = UnparserRule(name='primaryExpr', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 7, 1, 2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            self.variableReference(parent=current)
        elif choice == 1:
            UnlexerRule(src='(', parent=current)
            self.expr(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 2:
            self.Literal(parent=current)
        elif choice == 3:
            self.Number(parent=current)
        elif choice == 4:
            self.functionCall(parent=current)
        self.exit_rule(current)
        return current
    primaryExpr.min_depth = 1

    @depthcontrol
    def functionCall(self, parent=None):
        current = UnparserRule(name='functionCall', parent=parent)
        self.enter_rule(current)
        self.functionName(parent=current)
        UnlexerRule(src='(', parent=current)
        if self.max_depth >= 7:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.expr(parent=current)
                if self.max_depth >= 7:
                    for _ in self.model.quantify(current, 1, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.expr(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    functionCall.min_depth = 2

    @depthcontrol
    def unionExprNoRoot(self, parent=None):
        current = UnparserRule(name='unionExprNoRoot', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 5][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.pathExprNoRoot(parent=current)
            if self.max_depth >= 5:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src='|', parent=current)
                    self.unionExprNoRoot(parent=current)
        elif choice == 1:
            UnlexerRule(src='/', parent=current)
            UnlexerRule(src='|', parent=current)
            self.unionExprNoRoot(parent=current)
        self.exit_rule(current)
        return current
    unionExprNoRoot.min_depth = 4

    @depthcontrol
    def pathExprNoRoot(self, parent=None):
        current = UnparserRule(name='pathExprNoRoot', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.locationPath(parent=current)
        elif choice == 1:
            self.filterExpr(parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    choice = self.model.choice(current, 1, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                    if choice == 0:
                        UnlexerRule(src='/', parent=current)
                    elif choice == 1:
                        UnlexerRule(src='//', parent=current)
                    self.relativeLocationPath(parent=current)
        self.exit_rule(current)
        return current
    pathExprNoRoot.min_depth = 3

    @depthcontrol
    def filterExpr(self, parent=None):
        current = UnparserRule(name='filterExpr', parent=parent)
        self.enter_rule(current)
        self.primaryExpr(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.predicate(parent=current)
        self.exit_rule(current)
        return current
    filterExpr.min_depth = 2

    @depthcontrol
    def orExpr(self, parent=None):
        current = UnparserRule(name='orExpr', parent=parent)
        self.enter_rule(current)
        self.andExpr(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src='or', parent=current)
                self.andExpr(parent=current)
        self.exit_rule(current)
        return current
    orExpr.min_depth = 5

    @depthcontrol
    def andExpr(self, parent=None):
        current = UnparserRule(name='andExpr', parent=parent)
        self.enter_rule(current)
        self.equalityExpr(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src='and', parent=current)
                self.equalityExpr(parent=current)
        self.exit_rule(current)
        return current
    andExpr.min_depth = 4

    @depthcontrol
    def equalityExpr(self, parent=None):
        current = UnparserRule(name='equalityExpr', parent=parent)
        self.enter_rule(current)
        self.relationalExpr(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='=', parent=current)
                elif choice == 1:
                    UnlexerRule(src='!=', parent=current)
                self.relationalExpr(parent=current)
        self.exit_rule(current)
        return current
    equalityExpr.min_depth = 3

    @depthcontrol
    def relationalExpr(self, parent=None):
        current = UnparserRule(name='relationalExpr', parent=parent)
        self.enter_rule(current)
        self.additiveExpr(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
                if choice == 0:
                    UnlexerRule(src='<', parent=current)
                elif choice == 1:
                    UnlexerRule(src='>', parent=current)
                elif choice == 2:
                    UnlexerRule(src='<=', parent=current)
                elif choice == 3:
                    UnlexerRule(src='>=', parent=current)
                self.additiveExpr(parent=current)
        self.exit_rule(current)
        return current
    relationalExpr.min_depth = 2

    @depthcontrol
    def additiveExpr(self, parent=None):
        current = UnparserRule(name='additiveExpr', parent=parent)
        self.enter_rule(current)
        self.multiplicativeExpr(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='+', parent=current)
                elif choice == 1:
                    UnlexerRule(src='-', parent=current)
                self.multiplicativeExpr(parent=current)
        self.exit_rule(current)
        return current
    additiveExpr.min_depth = 1

    @depthcontrol
    def multiplicativeExpr(self, parent=None):
        current = UnparserRule(name='multiplicativeExpr', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [6, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.unaryExprNoRoot(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    choice = self.model.choice(current, 1, [0 if [0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                    if choice == 0:
                        UnlexerRule(src='*', parent=current)
                    elif choice == 1:
                        UnlexerRule(src='div', parent=current)
                    elif choice == 2:
                        UnlexerRule(src='mod', parent=current)
                    self.multiplicativeExpr(parent=current)
        elif choice == 1:
            UnlexerRule(src='/', parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    choice = self.model.choice(current, 2, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                    if choice == 0:
                        UnlexerRule(src='div', parent=current)
                    elif choice == 1:
                        UnlexerRule(src='mod', parent=current)
                    self.multiplicativeExpr(parent=current)
        self.exit_rule(current)
        return current
    multiplicativeExpr.min_depth = 0

    @depthcontrol
    def unaryExprNoRoot(self, parent=None):
        current = UnparserRule(name='unaryExprNoRoot', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src='-', parent=current)
        self.unionExprNoRoot(parent=current)
        self.exit_rule(current)
        return current
    unaryExprNoRoot.min_depth = 5

    @depthcontrol
    def qName(self, parent=None):
        current = UnparserRule(name='qName', parent=parent)
        self.enter_rule(current)
        self.nCName(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src=':', parent=current)
                self.nCName(parent=current)
        self.exit_rule(current)
        return current
    qName.min_depth = 2

    @depthcontrol
    def functionName(self, parent=None):
        current = UnparserRule(name='functionName', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.nCName(parent=current)
            UnlexerRule(src=':', parent=current)
            self.nCName(parent=current)
        elif choice == 1:
            self.NCName(parent=current)
        elif choice == 2:
            self.AxisName(parent=current)
        self.exit_rule(current)
        return current
    functionName.min_depth = 1

    @depthcontrol
    def variableReference(self, parent=None):
        current = UnparserRule(name='variableReference', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='$', parent=current)
        self.qName(parent=current)
        self.exit_rule(current)
        return current
    variableReference.min_depth = 3

    @depthcontrol
    def nameTest(self, parent=None):
        current = UnparserRule(name='nameTest', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='*', parent=current)
        elif choice == 1:
            self.nCName(parent=current)
            UnlexerRule(src=':', parent=current)
            UnlexerRule(src='*', parent=current)
        elif choice == 2:
            self.qName(parent=current)
        self.exit_rule(current)
        return current
    nameTest.min_depth = 0

    @depthcontrol
    def nCName(self, parent=None):
        current = UnparserRule(name='nCName', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.NCName(parent=current)
        elif choice == 1:
            self.AxisName(parent=current)
        elif choice == 2:
            self.NodeType(parent=current)
        self.exit_rule(current)
        return current
    nCName.min_depth = 1

    @depthcontrol
    def NodeType(self, parent=None):
        current = UnlexerRule(name='NodeType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='comment', parent=current)
        elif choice == 1:
            UnlexerRule(src='text', parent=current)
        elif choice == 2:
            UnlexerRule(src='processing-instruction', parent=current)
        elif choice == 3:
            UnlexerRule(src='node', parent=current)
        self.exit_rule(current)
        return current
    NodeType.min_depth = 0

    @depthcontrol
    def Number(self, parent=None):
        current = UnlexerRule(name='Number', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.Digits(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src='.', parent=current)
                    if self.max_depth >= 1:
                        for _ in self.model.quantify(current, 1, min=0, max=1):
                            self.Digits(parent=current)
        elif choice == 1:
            UnlexerRule(src='.', parent=current)
            self.Digits(parent=current)
        self.exit_rule(current)
        return current
    Number.min_depth = 1

    @depthcontrol
    def Digits(self, parent=None):
        current = UnlexerRule(name='Digits', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[1]), parent=current)
        self.exit_rule(current)
        return current
    Digits.min_depth = 0

    @depthcontrol
    def AxisName(self, parent=None):
        current = UnlexerRule(name='AxisName', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='ancestor', parent=current)
        elif choice == 1:
            UnlexerRule(src='ancestor-or-self', parent=current)
        elif choice == 2:
            UnlexerRule(src='attribute', parent=current)
        elif choice == 3:
            UnlexerRule(src='child', parent=current)
        elif choice == 4:
            UnlexerRule(src='descendant', parent=current)
        elif choice == 5:
            UnlexerRule(src='descendant-or-self', parent=current)
        elif choice == 6:
            UnlexerRule(src='following', parent=current)
        elif choice == 7:
            UnlexerRule(src='following-sibling', parent=current)
        elif choice == 8:
            UnlexerRule(src='namespace', parent=current)
        elif choice == 9:
            UnlexerRule(src='parent', parent=current)
        elif choice == 10:
            UnlexerRule(src='preceding', parent=current)
        elif choice == 11:
            UnlexerRule(src='preceding-sibling', parent=current)
        elif choice == 12:
            UnlexerRule(src='self', parent=current)
        self.exit_rule(current)
        return current
    AxisName.min_depth = 0

    @depthcontrol
    def PATHSEP(self, parent=None):
        current = UnlexerRule(name='PATHSEP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='/', parent=current)
        self.exit_rule(current)
        return current
    PATHSEP.min_depth = 0

    @depthcontrol
    def ABRPATH(self, parent=None):
        current = UnlexerRule(name='ABRPATH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='//', parent=current)
        self.exit_rule(current)
        return current
    ABRPATH.min_depth = 0

    @depthcontrol
    def LPAR(self, parent=None):
        current = UnlexerRule(name='LPAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.exit_rule(current)
        return current
    LPAR.min_depth = 0

    @depthcontrol
    def RPAR(self, parent=None):
        current = UnlexerRule(name='RPAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    RPAR.min_depth = 0

    @depthcontrol
    def LBRAC(self, parent=None):
        current = UnlexerRule(name='LBRAC', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='[', parent=current)
        self.exit_rule(current)
        return current
    LBRAC.min_depth = 0

    @depthcontrol
    def RBRAC(self, parent=None):
        current = UnlexerRule(name='RBRAC', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=']', parent=current)
        self.exit_rule(current)
        return current
    RBRAC.min_depth = 0

    @depthcontrol
    def MINUS(self, parent=None):
        current = UnlexerRule(name='MINUS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='-', parent=current)
        self.exit_rule(current)
        return current
    MINUS.min_depth = 0

    @depthcontrol
    def PLUS(self, parent=None):
        current = UnlexerRule(name='PLUS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='+', parent=current)
        self.exit_rule(current)
        return current
    PLUS.min_depth = 0

    @depthcontrol
    def DOT(self, parent=None):
        current = UnlexerRule(name='DOT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='.', parent=current)
        self.exit_rule(current)
        return current
    DOT.min_depth = 0

    @depthcontrol
    def MUL(self, parent=None):
        current = UnlexerRule(name='MUL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='*', parent=current)
        self.exit_rule(current)
        return current
    MUL.min_depth = 0

    @depthcontrol
    def DOTDOT(self, parent=None):
        current = UnlexerRule(name='DOTDOT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='..', parent=current)
        self.exit_rule(current)
        return current
    DOTDOT.min_depth = 0

    @depthcontrol
    def AT(self, parent=None):
        current = UnlexerRule(name='AT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='@', parent=current)
        self.exit_rule(current)
        return current
    AT.min_depth = 0

    @depthcontrol
    def COMMA(self, parent=None):
        current = UnlexerRule(name='COMMA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=',', parent=current)
        self.exit_rule(current)
        return current
    COMMA.min_depth = 0

    @depthcontrol
    def PIPE(self, parent=None):
        current = UnlexerRule(name='PIPE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='|', parent=current)
        self.exit_rule(current)
        return current
    PIPE.min_depth = 0

    @depthcontrol
    def LESS(self, parent=None):
        current = UnlexerRule(name='LESS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<', parent=current)
        self.exit_rule(current)
        return current
    LESS.min_depth = 0

    @depthcontrol
    def MORE_(self, parent=None):
        current = UnlexerRule(name='MORE_', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='>', parent=current)
        self.exit_rule(current)
        return current
    MORE_.min_depth = 0

    @depthcontrol
    def LE(self, parent=None):
        current = UnlexerRule(name='LE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<=', parent=current)
        self.exit_rule(current)
        return current
    LE.min_depth = 0

    @depthcontrol
    def GE(self, parent=None):
        current = UnlexerRule(name='GE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='>=', parent=current)
        self.exit_rule(current)
        return current
    GE.min_depth = 0

    @depthcontrol
    def COLON(self, parent=None):
        current = UnlexerRule(name='COLON', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=':', parent=current)
        self.exit_rule(current)
        return current
    COLON.min_depth = 0

    @depthcontrol
    def CC(self, parent=None):
        current = UnlexerRule(name='CC', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='::', parent=current)
        self.exit_rule(current)
        return current
    CC.min_depth = 0

    @depthcontrol
    def APOS(self, parent=None):
        current = UnlexerRule(name='APOS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='\'', parent=current)
        self.exit_rule(current)
        return current
    APOS.min_depth = 0

    @depthcontrol
    def QUOT(self, parent=None):
        current = UnlexerRule(name='QUOT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='"', parent=current)
        self.exit_rule(current)
        return current
    QUOT.min_depth = 0

    @depthcontrol
    def Literal(self, parent=None):
        current = UnlexerRule(name='Literal', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='"', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=self.model.charset(current, 0, self._charsets[2]), parent=current)
            UnlexerRule(src='"', parent=current)
        elif choice == 1:
            UnlexerRule(src='\'', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 1, min=0, max=inf):
                    UnlexerRule(src=self.model.charset(current, 1, self._charsets[3]), parent=current)
            UnlexerRule(src='\'', parent=current)
        self.exit_rule(current)
        return current
    Literal.min_depth = 0

    @depthcontrol
    def Whitespace(self, parent=None):
        current = UnlexerRule(name='Whitespace', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
                if choice == 0:
                    UnlexerRule(src=' ', parent=current)
                elif choice == 1:
                    UnlexerRule(src='\t', parent=current)
                elif choice == 2:
                    UnlexerRule(src='\n', parent=current)
                elif choice == 3:
                    UnlexerRule(src='\r', parent=current)
        self.exit_rule(current)
        return current
    Whitespace.min_depth = 0

    @depthcontrol
    def NCName(self, parent=None):
        current = UnlexerRule(name='NCName', parent=parent)
        self.enter_rule(current)
        self.NCNameStartChar(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.NCNameChar(parent=current)
        self.exit_rule(current)
        return current
    NCName.min_depth = 1

    @depthcontrol
    def NCNameStartChar(self, parent=None):
        current = UnlexerRule(name='NCNameStartChar', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src=self.model.charset(current, 0, self._charsets[4]), parent=current)
        elif choice == 1:
            UnlexerRule(src='_', parent=current)
        elif choice == 2:
            UnlexerRule(src=self.model.charset(current, 1, self._charsets[5]), parent=current)
        elif choice == 3:
            UnlexerRule(src=self.model.charset(current, 2, self._charsets[6]), parent=current)
        elif choice == 4:
            UnlexerRule(src=self.model.charset(current, 3, self._charsets[7]), parent=current)
        elif choice == 5:
            UnlexerRule(src=self.model.charset(current, 4, self._charsets[8]), parent=current)
        elif choice == 6:
            UnlexerRule(src=self.model.charset(current, 5, self._charsets[9]), parent=current)
        elif choice == 7:
            UnlexerRule(src=self.model.charset(current, 6, self._charsets[10]), parent=current)
        elif choice == 8:
            UnlexerRule(src=self.model.charset(current, 7, self._charsets[11]), parent=current)
        elif choice == 9:
            UnlexerRule(src=self.model.charset(current, 8, self._charsets[12]), parent=current)
        elif choice == 10:
            UnlexerRule(src=self.model.charset(current, 9, self._charsets[13]), parent=current)
        elif choice == 11:
            UnlexerRule(src=self.model.charset(current, 10, self._charsets[14]), parent=current)
        elif choice == 12:
            UnlexerRule(src=self.model.charset(current, 11, self._charsets[15]), parent=current)
        elif choice == 13:
            UnlexerRule(src=self.model.charset(current, 12, self._charsets[16]), parent=current)
        self.exit_rule(current)
        return current
    NCNameStartChar.min_depth = 0

    @depthcontrol
    def NCNameChar(self, parent=None):
        current = UnlexerRule(name='NCNameChar', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 0, 0, 0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.NCNameStartChar(parent=current)
        elif choice == 1:
            UnlexerRule(src='-', parent=current)
        elif choice == 2:
            UnlexerRule(src='.', parent=current)
        elif choice == 3:
            UnlexerRule(src=self.model.charset(current, 0, self._charsets[17]), parent=current)
        elif choice == 4:
            UnlexerRule(src='\u00B7', parent=current)
        elif choice == 5:
            UnlexerRule(src=self.model.charset(current, 1, self._charsets[18]), parent=current)
        elif choice == 6:
            UnlexerRule(src=self.model.charset(current, 2, self._charsets[19]), parent=current)
        self.exit_rule(current)
        return current
    NCNameChar.min_depth = 0

    default_rule = main

    _charsets = {
        0: list(chain.from_iterable([range(32, 127)])),
        1: list(chain.from_iterable([range(48, 58)])),
        2: list(chain.from_iterable([range(32, 34), range(35, 127)])),
        3: list(chain.from_iterable([range(32, 92), range(93, 127)])),
        4: list(chain.from_iterable([range(65, 91)])),
        5: list(chain.from_iterable([range(97, 123)])),
        6: list(chain.from_iterable([range(192, 214)])),
        7: list(chain.from_iterable([range(216, 246)])),
        8: list(chain.from_iterable([range(248, 767)])),
        9: list(chain.from_iterable([range(880, 893)])),
        10: list(chain.from_iterable([range(895, 8191)])),
        11: list(chain.from_iterable([range(8204, 8205)])),
        12: list(chain.from_iterable([range(8304, 8591)])),
        13: list(chain.from_iterable([range(11264, 12271)])),
        14: list(chain.from_iterable([range(12289, 55295)])),
        15: list(chain.from_iterable([range(63744, 64975)])),
        16: list(chain.from_iterable([range(65008, 65533)])),
        17: list(chain.from_iterable([range(48, 58)])),
        18: list(chain.from_iterable([range(768, 879)])),
        19: list(chain.from_iterable([range(8255, 8256)])),
    }

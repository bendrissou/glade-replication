# Generated by Grammarinator 0.0.0

from itertools import chain
from math import inf
from grammarinator.runtime import *

class MySqlGenerator(Generator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)


    @depthcontrol
    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    @depthcontrol
    def SPACE(self, parent=None):
        current = UnlexerRule(name='SPACE', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[1]), parent=current)
        self.exit_rule(current)
        return current
    SPACE.min_depth = 0

    @depthcontrol
    def SPEC_MYSQL_COMMENT(self, parent=None):
        current = UnlexerRule(name='SPEC_MYSQL_COMMENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='/*!', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[0]), parent=current)
        UnlexerRule(src='*/', parent=current)
        self.exit_rule(current)
        return current
    SPEC_MYSQL_COMMENT.min_depth = 0

    @depthcontrol
    def COMMENT_INPUT(self, parent=None):
        current = UnlexerRule(name='COMMENT_INPUT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='/*', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[0]), parent=current)
        UnlexerRule(src='*/', parent=current)
        self.exit_rule(current)
        return current
    COMMENT_INPUT.min_depth = 0

    @depthcontrol
    def LINE_COMMENT(self, parent=None):
        current = UnlexerRule(name='LINE_COMMENT', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            choice = self.model.choice(current, 1, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                UnlexerRule(src='--', parent=current)
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[2]), parent=current)
            elif choice == 1:
                UnlexerRule(src='#', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=self.model.charset(current, 1, self._charsets[3]), parent=current)
            choice = self.model.choice(current, 2, [0 if [0, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        UnlexerRule(src='\r', parent=current)
                UnlexerRule(src='\n', parent=current)
            elif choice == 1:
                self.EOF(parent=current)
        elif choice == 1:
            UnlexerRule(src='--', parent=current)
            choice = self.model.choice(current, 3, [0 if [0, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        UnlexerRule(src='\r', parent=current)
                UnlexerRule(src='\n', parent=current)
            elif choice == 1:
                self.EOF(parent=current)
        self.exit_rule(current)
        return current
    LINE_COMMENT.min_depth = 0

    @depthcontrol
    def ADD(self, parent=None):
        current = UnlexerRule(name='ADD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ADD', parent=current)
        self.exit_rule(current)
        return current
    ADD.min_depth = 0

    @depthcontrol
    def ALL(self, parent=None):
        current = UnlexerRule(name='ALL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ALL', parent=current)
        self.exit_rule(current)
        return current
    ALL.min_depth = 0

    @depthcontrol
    def ALTER(self, parent=None):
        current = UnlexerRule(name='ALTER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ALTER', parent=current)
        self.exit_rule(current)
        return current
    ALTER.min_depth = 0

    @depthcontrol
    def ALWAYS(self, parent=None):
        current = UnlexerRule(name='ALWAYS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ALWAYS', parent=current)
        self.exit_rule(current)
        return current
    ALWAYS.min_depth = 0

    @depthcontrol
    def ANALYZE(self, parent=None):
        current = UnlexerRule(name='ANALYZE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ANALYZE', parent=current)
        self.exit_rule(current)
        return current
    ANALYZE.min_depth = 0

    @depthcontrol
    def AND(self, parent=None):
        current = UnlexerRule(name='AND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='AND', parent=current)
        self.exit_rule(current)
        return current
    AND.min_depth = 0

    @depthcontrol
    def AS(self, parent=None):
        current = UnlexerRule(name='AS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='AS', parent=current)
        self.exit_rule(current)
        return current
    AS.min_depth = 0

    @depthcontrol
    def ASC(self, parent=None):
        current = UnlexerRule(name='ASC', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ASC', parent=current)
        self.exit_rule(current)
        return current
    ASC.min_depth = 0

    @depthcontrol
    def BEFORE(self, parent=None):
        current = UnlexerRule(name='BEFORE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BEFORE', parent=current)
        self.exit_rule(current)
        return current
    BEFORE.min_depth = 0

    @depthcontrol
    def BETWEEN(self, parent=None):
        current = UnlexerRule(name='BETWEEN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BETWEEN', parent=current)
        self.exit_rule(current)
        return current
    BETWEEN.min_depth = 0

    @depthcontrol
    def BOTH(self, parent=None):
        current = UnlexerRule(name='BOTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BOTH', parent=current)
        self.exit_rule(current)
        return current
    BOTH.min_depth = 0

    @depthcontrol
    def BY(self, parent=None):
        current = UnlexerRule(name='BY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BY', parent=current)
        self.exit_rule(current)
        return current
    BY.min_depth = 0

    @depthcontrol
    def CALL(self, parent=None):
        current = UnlexerRule(name='CALL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CALL', parent=current)
        self.exit_rule(current)
        return current
    CALL.min_depth = 0

    @depthcontrol
    def CASCADE(self, parent=None):
        current = UnlexerRule(name='CASCADE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CASCADE', parent=current)
        self.exit_rule(current)
        return current
    CASCADE.min_depth = 0

    @depthcontrol
    def CASE(self, parent=None):
        current = UnlexerRule(name='CASE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CASE', parent=current)
        self.exit_rule(current)
        return current
    CASE.min_depth = 0

    @depthcontrol
    def CAST(self, parent=None):
        current = UnlexerRule(name='CAST', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CAST', parent=current)
        self.exit_rule(current)
        return current
    CAST.min_depth = 0

    @depthcontrol
    def CHANGE(self, parent=None):
        current = UnlexerRule(name='CHANGE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CHANGE', parent=current)
        self.exit_rule(current)
        return current
    CHANGE.min_depth = 0

    @depthcontrol
    def CHARACTER(self, parent=None):
        current = UnlexerRule(name='CHARACTER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CHARACTER', parent=current)
        self.exit_rule(current)
        return current
    CHARACTER.min_depth = 0

    @depthcontrol
    def CHECK(self, parent=None):
        current = UnlexerRule(name='CHECK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CHECK', parent=current)
        self.exit_rule(current)
        return current
    CHECK.min_depth = 0

    @depthcontrol
    def COLLATE(self, parent=None):
        current = UnlexerRule(name='COLLATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COLLATE', parent=current)
        self.exit_rule(current)
        return current
    COLLATE.min_depth = 0

    @depthcontrol
    def COLUMN(self, parent=None):
        current = UnlexerRule(name='COLUMN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COLUMN', parent=current)
        self.exit_rule(current)
        return current
    COLUMN.min_depth = 0

    @depthcontrol
    def CONDITION(self, parent=None):
        current = UnlexerRule(name='CONDITION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONDITION', parent=current)
        self.exit_rule(current)
        return current
    CONDITION.min_depth = 0

    @depthcontrol
    def CONSTRAINT(self, parent=None):
        current = UnlexerRule(name='CONSTRAINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONSTRAINT', parent=current)
        self.exit_rule(current)
        return current
    CONSTRAINT.min_depth = 0

    @depthcontrol
    def CONTINUE(self, parent=None):
        current = UnlexerRule(name='CONTINUE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONTINUE', parent=current)
        self.exit_rule(current)
        return current
    CONTINUE.min_depth = 0

    @depthcontrol
    def CONVERT(self, parent=None):
        current = UnlexerRule(name='CONVERT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONVERT', parent=current)
        self.exit_rule(current)
        return current
    CONVERT.min_depth = 0

    @depthcontrol
    def CREATE(self, parent=None):
        current = UnlexerRule(name='CREATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CREATE', parent=current)
        self.exit_rule(current)
        return current
    CREATE.min_depth = 0

    @depthcontrol
    def CROSS(self, parent=None):
        current = UnlexerRule(name='CROSS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CROSS', parent=current)
        self.exit_rule(current)
        return current
    CROSS.min_depth = 0

    @depthcontrol
    def CURRENT(self, parent=None):
        current = UnlexerRule(name='CURRENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CURRENT', parent=current)
        self.exit_rule(current)
        return current
    CURRENT.min_depth = 0

    @depthcontrol
    def CURRENT_USER(self, parent=None):
        current = UnlexerRule(name='CURRENT_USER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CURRENT_USER', parent=current)
        self.exit_rule(current)
        return current
    CURRENT_USER.min_depth = 0

    @depthcontrol
    def CURSOR(self, parent=None):
        current = UnlexerRule(name='CURSOR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CURSOR', parent=current)
        self.exit_rule(current)
        return current
    CURSOR.min_depth = 0

    @depthcontrol
    def DATABASE(self, parent=None):
        current = UnlexerRule(name='DATABASE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DATABASE', parent=current)
        self.exit_rule(current)
        return current
    DATABASE.min_depth = 0

    @depthcontrol
    def DATABASES(self, parent=None):
        current = UnlexerRule(name='DATABASES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DATABASES', parent=current)
        self.exit_rule(current)
        return current
    DATABASES.min_depth = 0

    @depthcontrol
    def DECLARE(self, parent=None):
        current = UnlexerRule(name='DECLARE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DECLARE', parent=current)
        self.exit_rule(current)
        return current
    DECLARE.min_depth = 0

    @depthcontrol
    def DEFAULT(self, parent=None):
        current = UnlexerRule(name='DEFAULT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DEFAULT', parent=current)
        self.exit_rule(current)
        return current
    DEFAULT.min_depth = 0

    @depthcontrol
    def DELAYED(self, parent=None):
        current = UnlexerRule(name='DELAYED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DELAYED', parent=current)
        self.exit_rule(current)
        return current
    DELAYED.min_depth = 0

    @depthcontrol
    def DELETE(self, parent=None):
        current = UnlexerRule(name='DELETE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DELETE', parent=current)
        self.exit_rule(current)
        return current
    DELETE.min_depth = 0

    @depthcontrol
    def DESC(self, parent=None):
        current = UnlexerRule(name='DESC', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DESC', parent=current)
        self.exit_rule(current)
        return current
    DESC.min_depth = 0

    @depthcontrol
    def DESCRIBE(self, parent=None):
        current = UnlexerRule(name='DESCRIBE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DESCRIBE', parent=current)
        self.exit_rule(current)
        return current
    DESCRIBE.min_depth = 0

    @depthcontrol
    def DETERMINISTIC(self, parent=None):
        current = UnlexerRule(name='DETERMINISTIC', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DETERMINISTIC', parent=current)
        self.exit_rule(current)
        return current
    DETERMINISTIC.min_depth = 0

    @depthcontrol
    def DIAGNOSTICS(self, parent=None):
        current = UnlexerRule(name='DIAGNOSTICS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DIAGNOSTICS', parent=current)
        self.exit_rule(current)
        return current
    DIAGNOSTICS.min_depth = 0

    @depthcontrol
    def DISTINCT(self, parent=None):
        current = UnlexerRule(name='DISTINCT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DISTINCT', parent=current)
        self.exit_rule(current)
        return current
    DISTINCT.min_depth = 0

    @depthcontrol
    def DISTINCTROW(self, parent=None):
        current = UnlexerRule(name='DISTINCTROW', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DISTINCTROW', parent=current)
        self.exit_rule(current)
        return current
    DISTINCTROW.min_depth = 0

    @depthcontrol
    def DROP(self, parent=None):
        current = UnlexerRule(name='DROP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DROP', parent=current)
        self.exit_rule(current)
        return current
    DROP.min_depth = 0

    @depthcontrol
    def EACH(self, parent=None):
        current = UnlexerRule(name='EACH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EACH', parent=current)
        self.exit_rule(current)
        return current
    EACH.min_depth = 0

    @depthcontrol
    def ELSE(self, parent=None):
        current = UnlexerRule(name='ELSE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ELSE', parent=current)
        self.exit_rule(current)
        return current
    ELSE.min_depth = 0

    @depthcontrol
    def ELSEIF(self, parent=None):
        current = UnlexerRule(name='ELSEIF', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ELSEIF', parent=current)
        self.exit_rule(current)
        return current
    ELSEIF.min_depth = 0

    @depthcontrol
    def EMPTY(self, parent=None):
        current = UnlexerRule(name='EMPTY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EMPTY', parent=current)
        self.exit_rule(current)
        return current
    EMPTY.min_depth = 0

    @depthcontrol
    def ENCLOSED(self, parent=None):
        current = UnlexerRule(name='ENCLOSED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ENCLOSED', parent=current)
        self.exit_rule(current)
        return current
    ENCLOSED.min_depth = 0

    @depthcontrol
    def ESCAPED(self, parent=None):
        current = UnlexerRule(name='ESCAPED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ESCAPED', parent=current)
        self.exit_rule(current)
        return current
    ESCAPED.min_depth = 0

    @depthcontrol
    def EXISTS(self, parent=None):
        current = UnlexerRule(name='EXISTS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EXISTS', parent=current)
        self.exit_rule(current)
        return current
    EXISTS.min_depth = 0

    @depthcontrol
    def EXIT(self, parent=None):
        current = UnlexerRule(name='EXIT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EXIT', parent=current)
        self.exit_rule(current)
        return current
    EXIT.min_depth = 0

    @depthcontrol
    def EXPLAIN(self, parent=None):
        current = UnlexerRule(name='EXPLAIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EXPLAIN', parent=current)
        self.exit_rule(current)
        return current
    EXPLAIN.min_depth = 0

    @depthcontrol
    def FALSE(self, parent=None):
        current = UnlexerRule(name='FALSE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FALSE', parent=current)
        self.exit_rule(current)
        return current
    FALSE.min_depth = 0

    @depthcontrol
    def FETCH(self, parent=None):
        current = UnlexerRule(name='FETCH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FETCH', parent=current)
        self.exit_rule(current)
        return current
    FETCH.min_depth = 0

    @depthcontrol
    def FOR(self, parent=None):
        current = UnlexerRule(name='FOR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FOR', parent=current)
        self.exit_rule(current)
        return current
    FOR.min_depth = 0

    @depthcontrol
    def FORCE(self, parent=None):
        current = UnlexerRule(name='FORCE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FORCE', parent=current)
        self.exit_rule(current)
        return current
    FORCE.min_depth = 0

    @depthcontrol
    def FOREIGN(self, parent=None):
        current = UnlexerRule(name='FOREIGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FOREIGN', parent=current)
        self.exit_rule(current)
        return current
    FOREIGN.min_depth = 0

    @depthcontrol
    def FROM(self, parent=None):
        current = UnlexerRule(name='FROM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FROM', parent=current)
        self.exit_rule(current)
        return current
    FROM.min_depth = 0

    @depthcontrol
    def FULLTEXT(self, parent=None):
        current = UnlexerRule(name='FULLTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FULLTEXT', parent=current)
        self.exit_rule(current)
        return current
    FULLTEXT.min_depth = 0

    @depthcontrol
    def GENERATED(self, parent=None):
        current = UnlexerRule(name='GENERATED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GENERATED', parent=current)
        self.exit_rule(current)
        return current
    GENERATED.min_depth = 0

    @depthcontrol
    def GET(self, parent=None):
        current = UnlexerRule(name='GET', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GET', parent=current)
        self.exit_rule(current)
        return current
    GET.min_depth = 0

    @depthcontrol
    def GRANT(self, parent=None):
        current = UnlexerRule(name='GRANT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GRANT', parent=current)
        self.exit_rule(current)
        return current
    GRANT.min_depth = 0

    @depthcontrol
    def GROUP(self, parent=None):
        current = UnlexerRule(name='GROUP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GROUP', parent=current)
        self.exit_rule(current)
        return current
    GROUP.min_depth = 0

    @depthcontrol
    def HAVING(self, parent=None):
        current = UnlexerRule(name='HAVING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='HAVING', parent=current)
        self.exit_rule(current)
        return current
    HAVING.min_depth = 0

    @depthcontrol
    def HIGH_PRIORITY(self, parent=None):
        current = UnlexerRule(name='HIGH_PRIORITY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='HIGH_PRIORITY', parent=current)
        self.exit_rule(current)
        return current
    HIGH_PRIORITY.min_depth = 0

    @depthcontrol
    def IF(self, parent=None):
        current = UnlexerRule(name='IF', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IF', parent=current)
        self.exit_rule(current)
        return current
    IF.min_depth = 0

    @depthcontrol
    def IGNORE(self, parent=None):
        current = UnlexerRule(name='IGNORE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IGNORE', parent=current)
        self.exit_rule(current)
        return current
    IGNORE.min_depth = 0

    @depthcontrol
    def IN(self, parent=None):
        current = UnlexerRule(name='IN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IN', parent=current)
        self.exit_rule(current)
        return current
    IN.min_depth = 0

    @depthcontrol
    def INDEX(self, parent=None):
        current = UnlexerRule(name='INDEX', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INDEX', parent=current)
        self.exit_rule(current)
        return current
    INDEX.min_depth = 0

    @depthcontrol
    def INFILE(self, parent=None):
        current = UnlexerRule(name='INFILE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INFILE', parent=current)
        self.exit_rule(current)
        return current
    INFILE.min_depth = 0

    @depthcontrol
    def INNER(self, parent=None):
        current = UnlexerRule(name='INNER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INNER', parent=current)
        self.exit_rule(current)
        return current
    INNER.min_depth = 0

    @depthcontrol
    def INOUT(self, parent=None):
        current = UnlexerRule(name='INOUT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INOUT', parent=current)
        self.exit_rule(current)
        return current
    INOUT.min_depth = 0

    @depthcontrol
    def INSERT(self, parent=None):
        current = UnlexerRule(name='INSERT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INSERT', parent=current)
        self.exit_rule(current)
        return current
    INSERT.min_depth = 0

    @depthcontrol
    def INTERVAL(self, parent=None):
        current = UnlexerRule(name='INTERVAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INTERVAL', parent=current)
        self.exit_rule(current)
        return current
    INTERVAL.min_depth = 0

    @depthcontrol
    def INTO(self, parent=None):
        current = UnlexerRule(name='INTO', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INTO', parent=current)
        self.exit_rule(current)
        return current
    INTO.min_depth = 0

    @depthcontrol
    def IS(self, parent=None):
        current = UnlexerRule(name='IS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IS', parent=current)
        self.exit_rule(current)
        return current
    IS.min_depth = 0

    @depthcontrol
    def ITERATE(self, parent=None):
        current = UnlexerRule(name='ITERATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ITERATE', parent=current)
        self.exit_rule(current)
        return current
    ITERATE.min_depth = 0

    @depthcontrol
    def JOIN(self, parent=None):
        current = UnlexerRule(name='JOIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JOIN', parent=current)
        self.exit_rule(current)
        return current
    JOIN.min_depth = 0

    @depthcontrol
    def KEY(self, parent=None):
        current = UnlexerRule(name='KEY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='KEY', parent=current)
        self.exit_rule(current)
        return current
    KEY.min_depth = 0

    @depthcontrol
    def KEYS(self, parent=None):
        current = UnlexerRule(name='KEYS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='KEYS', parent=current)
        self.exit_rule(current)
        return current
    KEYS.min_depth = 0

    @depthcontrol
    def KILL(self, parent=None):
        current = UnlexerRule(name='KILL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='KILL', parent=current)
        self.exit_rule(current)
        return current
    KILL.min_depth = 0

    @depthcontrol
    def LEADING(self, parent=None):
        current = UnlexerRule(name='LEADING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LEADING', parent=current)
        self.exit_rule(current)
        return current
    LEADING.min_depth = 0

    @depthcontrol
    def LEAVE(self, parent=None):
        current = UnlexerRule(name='LEAVE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LEAVE', parent=current)
        self.exit_rule(current)
        return current
    LEAVE.min_depth = 0

    @depthcontrol
    def LEFT(self, parent=None):
        current = UnlexerRule(name='LEFT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LEFT', parent=current)
        self.exit_rule(current)
        return current
    LEFT.min_depth = 0

    @depthcontrol
    def LIKE(self, parent=None):
        current = UnlexerRule(name='LIKE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LIKE', parent=current)
        self.exit_rule(current)
        return current
    LIKE.min_depth = 0

    @depthcontrol
    def LIMIT(self, parent=None):
        current = UnlexerRule(name='LIMIT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LIMIT', parent=current)
        self.exit_rule(current)
        return current
    LIMIT.min_depth = 0

    @depthcontrol
    def LINEAR(self, parent=None):
        current = UnlexerRule(name='LINEAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LINEAR', parent=current)
        self.exit_rule(current)
        return current
    LINEAR.min_depth = 0

    @depthcontrol
    def LINES(self, parent=None):
        current = UnlexerRule(name='LINES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LINES', parent=current)
        self.exit_rule(current)
        return current
    LINES.min_depth = 0

    @depthcontrol
    def LOAD(self, parent=None):
        current = UnlexerRule(name='LOAD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LOAD', parent=current)
        self.exit_rule(current)
        return current
    LOAD.min_depth = 0

    @depthcontrol
    def LOCK(self, parent=None):
        current = UnlexerRule(name='LOCK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LOCK', parent=current)
        self.exit_rule(current)
        return current
    LOCK.min_depth = 0

    @depthcontrol
    def LOOP(self, parent=None):
        current = UnlexerRule(name='LOOP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LOOP', parent=current)
        self.exit_rule(current)
        return current
    LOOP.min_depth = 0

    @depthcontrol
    def LOW_PRIORITY(self, parent=None):
        current = UnlexerRule(name='LOW_PRIORITY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LOW_PRIORITY', parent=current)
        self.exit_rule(current)
        return current
    LOW_PRIORITY.min_depth = 0

    @depthcontrol
    def MASTER_BIND(self, parent=None):
        current = UnlexerRule(name='MASTER_BIND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_BIND', parent=current)
        self.exit_rule(current)
        return current
    MASTER_BIND.min_depth = 0

    @depthcontrol
    def MASTER_SSL_VERIFY_SERVER_CERT(self, parent=None):
        current = UnlexerRule(name='MASTER_SSL_VERIFY_SERVER_CERT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_SSL_VERIFY_SERVER_CERT', parent=current)
        self.exit_rule(current)
        return current
    MASTER_SSL_VERIFY_SERVER_CERT.min_depth = 0

    @depthcontrol
    def MATCH(self, parent=None):
        current = UnlexerRule(name='MATCH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MATCH', parent=current)
        self.exit_rule(current)
        return current
    MATCH.min_depth = 0

    @depthcontrol
    def MAXVALUE(self, parent=None):
        current = UnlexerRule(name='MAXVALUE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MAXVALUE', parent=current)
        self.exit_rule(current)
        return current
    MAXVALUE.min_depth = 0

    @depthcontrol
    def MODIFIES(self, parent=None):
        current = UnlexerRule(name='MODIFIES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MODIFIES', parent=current)
        self.exit_rule(current)
        return current
    MODIFIES.min_depth = 0

    @depthcontrol
    def NATURAL(self, parent=None):
        current = UnlexerRule(name='NATURAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NATURAL', parent=current)
        self.exit_rule(current)
        return current
    NATURAL.min_depth = 0

    @depthcontrol
    def NOT(self, parent=None):
        current = UnlexerRule(name='NOT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NOT', parent=current)
        self.exit_rule(current)
        return current
    NOT.min_depth = 0

    @depthcontrol
    def NO_WRITE_TO_BINLOG(self, parent=None):
        current = UnlexerRule(name='NO_WRITE_TO_BINLOG', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NO_WRITE_TO_BINLOG', parent=current)
        self.exit_rule(current)
        return current
    NO_WRITE_TO_BINLOG.min_depth = 0

    @depthcontrol
    def NULL_LITERAL(self, parent=None):
        current = UnlexerRule(name='NULL_LITERAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NULL', parent=current)
        self.exit_rule(current)
        return current
    NULL_LITERAL.min_depth = 0

    @depthcontrol
    def NUMBER(self, parent=None):
        current = UnlexerRule(name='NUMBER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NUMBER', parent=current)
        self.exit_rule(current)
        return current
    NUMBER.min_depth = 0

    @depthcontrol
    def ON(self, parent=None):
        current = UnlexerRule(name='ON', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ON', parent=current)
        self.exit_rule(current)
        return current
    ON.min_depth = 0

    @depthcontrol
    def OPTIMIZE(self, parent=None):
        current = UnlexerRule(name='OPTIMIZE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OPTIMIZE', parent=current)
        self.exit_rule(current)
        return current
    OPTIMIZE.min_depth = 0

    @depthcontrol
    def OPTION(self, parent=None):
        current = UnlexerRule(name='OPTION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OPTION', parent=current)
        self.exit_rule(current)
        return current
    OPTION.min_depth = 0

    @depthcontrol
    def OPTIONALLY(self, parent=None):
        current = UnlexerRule(name='OPTIONALLY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OPTIONALLY', parent=current)
        self.exit_rule(current)
        return current
    OPTIONALLY.min_depth = 0

    @depthcontrol
    def OR(self, parent=None):
        current = UnlexerRule(name='OR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OR', parent=current)
        self.exit_rule(current)
        return current
    OR.min_depth = 0

    @depthcontrol
    def ORDER(self, parent=None):
        current = UnlexerRule(name='ORDER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ORDER', parent=current)
        self.exit_rule(current)
        return current
    ORDER.min_depth = 0

    @depthcontrol
    def OUT(self, parent=None):
        current = UnlexerRule(name='OUT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OUT', parent=current)
        self.exit_rule(current)
        return current
    OUT.min_depth = 0

    @depthcontrol
    def OUTER(self, parent=None):
        current = UnlexerRule(name='OUTER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OUTER', parent=current)
        self.exit_rule(current)
        return current
    OUTER.min_depth = 0

    @depthcontrol
    def OUTFILE(self, parent=None):
        current = UnlexerRule(name='OUTFILE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OUTFILE', parent=current)
        self.exit_rule(current)
        return current
    OUTFILE.min_depth = 0

    @depthcontrol
    def PARTITION(self, parent=None):
        current = UnlexerRule(name='PARTITION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PARTITION', parent=current)
        self.exit_rule(current)
        return current
    PARTITION.min_depth = 0

    @depthcontrol
    def PRIMARY(self, parent=None):
        current = UnlexerRule(name='PRIMARY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PRIMARY', parent=current)
        self.exit_rule(current)
        return current
    PRIMARY.min_depth = 0

    @depthcontrol
    def PROCEDURE(self, parent=None):
        current = UnlexerRule(name='PROCEDURE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PROCEDURE', parent=current)
        self.exit_rule(current)
        return current
    PROCEDURE.min_depth = 0

    @depthcontrol
    def PURGE(self, parent=None):
        current = UnlexerRule(name='PURGE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PURGE', parent=current)
        self.exit_rule(current)
        return current
    PURGE.min_depth = 0

    @depthcontrol
    def RANGE(self, parent=None):
        current = UnlexerRule(name='RANGE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RANGE', parent=current)
        self.exit_rule(current)
        return current
    RANGE.min_depth = 0

    @depthcontrol
    def READ(self, parent=None):
        current = UnlexerRule(name='READ', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='READ', parent=current)
        self.exit_rule(current)
        return current
    READ.min_depth = 0

    @depthcontrol
    def READS(self, parent=None):
        current = UnlexerRule(name='READS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='READS', parent=current)
        self.exit_rule(current)
        return current
    READS.min_depth = 0

    @depthcontrol
    def REFERENCES(self, parent=None):
        current = UnlexerRule(name='REFERENCES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REFERENCES', parent=current)
        self.exit_rule(current)
        return current
    REFERENCES.min_depth = 0

    @depthcontrol
    def REGEXP(self, parent=None):
        current = UnlexerRule(name='REGEXP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REGEXP', parent=current)
        self.exit_rule(current)
        return current
    REGEXP.min_depth = 0

    @depthcontrol
    def RELEASE(self, parent=None):
        current = UnlexerRule(name='RELEASE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RELEASE', parent=current)
        self.exit_rule(current)
        return current
    RELEASE.min_depth = 0

    @depthcontrol
    def RENAME(self, parent=None):
        current = UnlexerRule(name='RENAME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RENAME', parent=current)
        self.exit_rule(current)
        return current
    RENAME.min_depth = 0

    @depthcontrol
    def REPEAT(self, parent=None):
        current = UnlexerRule(name='REPEAT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REPEAT', parent=current)
        self.exit_rule(current)
        return current
    REPEAT.min_depth = 0

    @depthcontrol
    def REPLACE(self, parent=None):
        current = UnlexerRule(name='REPLACE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REPLACE', parent=current)
        self.exit_rule(current)
        return current
    REPLACE.min_depth = 0

    @depthcontrol
    def REQUIRE(self, parent=None):
        current = UnlexerRule(name='REQUIRE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REQUIRE', parent=current)
        self.exit_rule(current)
        return current
    REQUIRE.min_depth = 0

    @depthcontrol
    def RESIGNAL(self, parent=None):
        current = UnlexerRule(name='RESIGNAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RESIGNAL', parent=current)
        self.exit_rule(current)
        return current
    RESIGNAL.min_depth = 0

    @depthcontrol
    def RESTRICT(self, parent=None):
        current = UnlexerRule(name='RESTRICT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RESTRICT', parent=current)
        self.exit_rule(current)
        return current
    RESTRICT.min_depth = 0

    @depthcontrol
    def RETURN(self, parent=None):
        current = UnlexerRule(name='RETURN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RETURN', parent=current)
        self.exit_rule(current)
        return current
    RETURN.min_depth = 0

    @depthcontrol
    def REVOKE(self, parent=None):
        current = UnlexerRule(name='REVOKE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REVOKE', parent=current)
        self.exit_rule(current)
        return current
    REVOKE.min_depth = 0

    @depthcontrol
    def RIGHT(self, parent=None):
        current = UnlexerRule(name='RIGHT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RIGHT', parent=current)
        self.exit_rule(current)
        return current
    RIGHT.min_depth = 0

    @depthcontrol
    def RLIKE(self, parent=None):
        current = UnlexerRule(name='RLIKE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RLIKE', parent=current)
        self.exit_rule(current)
        return current
    RLIKE.min_depth = 0

    @depthcontrol
    def SCHEMA(self, parent=None):
        current = UnlexerRule(name='SCHEMA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SCHEMA', parent=current)
        self.exit_rule(current)
        return current
    SCHEMA.min_depth = 0

    @depthcontrol
    def SCHEMAS(self, parent=None):
        current = UnlexerRule(name='SCHEMAS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SCHEMAS', parent=current)
        self.exit_rule(current)
        return current
    SCHEMAS.min_depth = 0

    @depthcontrol
    def SELECT(self, parent=None):
        current = UnlexerRule(name='SELECT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SELECT', parent=current)
        self.exit_rule(current)
        return current
    SELECT.min_depth = 0

    @depthcontrol
    def SET(self, parent=None):
        current = UnlexerRule(name='SET', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SET', parent=current)
        self.exit_rule(current)
        return current
    SET.min_depth = 0

    @depthcontrol
    def SEPARATOR(self, parent=None):
        current = UnlexerRule(name='SEPARATOR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SEPARATOR', parent=current)
        self.exit_rule(current)
        return current
    SEPARATOR.min_depth = 0

    @depthcontrol
    def SHOW(self, parent=None):
        current = UnlexerRule(name='SHOW', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SHOW', parent=current)
        self.exit_rule(current)
        return current
    SHOW.min_depth = 0

    @depthcontrol
    def SIGNAL(self, parent=None):
        current = UnlexerRule(name='SIGNAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SIGNAL', parent=current)
        self.exit_rule(current)
        return current
    SIGNAL.min_depth = 0

    @depthcontrol
    def SPATIAL(self, parent=None):
        current = UnlexerRule(name='SPATIAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SPATIAL', parent=current)
        self.exit_rule(current)
        return current
    SPATIAL.min_depth = 0

    @depthcontrol
    def SQL(self, parent=None):
        current = UnlexerRule(name='SQL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQL', parent=current)
        self.exit_rule(current)
        return current
    SQL.min_depth = 0

    @depthcontrol
    def SQLEXCEPTION(self, parent=None):
        current = UnlexerRule(name='SQLEXCEPTION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQLEXCEPTION', parent=current)
        self.exit_rule(current)
        return current
    SQLEXCEPTION.min_depth = 0

    @depthcontrol
    def SQLSTATE(self, parent=None):
        current = UnlexerRule(name='SQLSTATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQLSTATE', parent=current)
        self.exit_rule(current)
        return current
    SQLSTATE.min_depth = 0

    @depthcontrol
    def SQLWARNING(self, parent=None):
        current = UnlexerRule(name='SQLWARNING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQLWARNING', parent=current)
        self.exit_rule(current)
        return current
    SQLWARNING.min_depth = 0

    @depthcontrol
    def SQL_BIG_RESULT(self, parent=None):
        current = UnlexerRule(name='SQL_BIG_RESULT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQL_BIG_RESULT', parent=current)
        self.exit_rule(current)
        return current
    SQL_BIG_RESULT.min_depth = 0

    @depthcontrol
    def SQL_CALC_FOUND_ROWS(self, parent=None):
        current = UnlexerRule(name='SQL_CALC_FOUND_ROWS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQL_CALC_FOUND_ROWS', parent=current)
        self.exit_rule(current)
        return current
    SQL_CALC_FOUND_ROWS.min_depth = 0

    @depthcontrol
    def SQL_SMALL_RESULT(self, parent=None):
        current = UnlexerRule(name='SQL_SMALL_RESULT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQL_SMALL_RESULT', parent=current)
        self.exit_rule(current)
        return current
    SQL_SMALL_RESULT.min_depth = 0

    @depthcontrol
    def SSL(self, parent=None):
        current = UnlexerRule(name='SSL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SSL', parent=current)
        self.exit_rule(current)
        return current
    SSL.min_depth = 0

    @depthcontrol
    def STACKED(self, parent=None):
        current = UnlexerRule(name='STACKED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STACKED', parent=current)
        self.exit_rule(current)
        return current
    STACKED.min_depth = 0

    @depthcontrol
    def STARTING(self, parent=None):
        current = UnlexerRule(name='STARTING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STARTING', parent=current)
        self.exit_rule(current)
        return current
    STARTING.min_depth = 0

    @depthcontrol
    def STRAIGHT_JOIN(self, parent=None):
        current = UnlexerRule(name='STRAIGHT_JOIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STRAIGHT_JOIN', parent=current)
        self.exit_rule(current)
        return current
    STRAIGHT_JOIN.min_depth = 0

    @depthcontrol
    def TABLE(self, parent=None):
        current = UnlexerRule(name='TABLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TABLE', parent=current)
        self.exit_rule(current)
        return current
    TABLE.min_depth = 0

    @depthcontrol
    def TERMINATED(self, parent=None):
        current = UnlexerRule(name='TERMINATED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TERMINATED', parent=current)
        self.exit_rule(current)
        return current
    TERMINATED.min_depth = 0

    @depthcontrol
    def THEN(self, parent=None):
        current = UnlexerRule(name='THEN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='THEN', parent=current)
        self.exit_rule(current)
        return current
    THEN.min_depth = 0

    @depthcontrol
    def TO(self, parent=None):
        current = UnlexerRule(name='TO', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TO', parent=current)
        self.exit_rule(current)
        return current
    TO.min_depth = 0

    @depthcontrol
    def TRAILING(self, parent=None):
        current = UnlexerRule(name='TRAILING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TRAILING', parent=current)
        self.exit_rule(current)
        return current
    TRAILING.min_depth = 0

    @depthcontrol
    def TRIGGER(self, parent=None):
        current = UnlexerRule(name='TRIGGER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TRIGGER', parent=current)
        self.exit_rule(current)
        return current
    TRIGGER.min_depth = 0

    @depthcontrol
    def TRUE(self, parent=None):
        current = UnlexerRule(name='TRUE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TRUE', parent=current)
        self.exit_rule(current)
        return current
    TRUE.min_depth = 0

    @depthcontrol
    def UNDO(self, parent=None):
        current = UnlexerRule(name='UNDO', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNDO', parent=current)
        self.exit_rule(current)
        return current
    UNDO.min_depth = 0

    @depthcontrol
    def UNION(self, parent=None):
        current = UnlexerRule(name='UNION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNION', parent=current)
        self.exit_rule(current)
        return current
    UNION.min_depth = 0

    @depthcontrol
    def UNIQUE(self, parent=None):
        current = UnlexerRule(name='UNIQUE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNIQUE', parent=current)
        self.exit_rule(current)
        return current
    UNIQUE.min_depth = 0

    @depthcontrol
    def UNLOCK(self, parent=None):
        current = UnlexerRule(name='UNLOCK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNLOCK', parent=current)
        self.exit_rule(current)
        return current
    UNLOCK.min_depth = 0

    @depthcontrol
    def UNSIGNED(self, parent=None):
        current = UnlexerRule(name='UNSIGNED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNSIGNED', parent=current)
        self.exit_rule(current)
        return current
    UNSIGNED.min_depth = 0

    @depthcontrol
    def UPDATE(self, parent=None):
        current = UnlexerRule(name='UPDATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UPDATE', parent=current)
        self.exit_rule(current)
        return current
    UPDATE.min_depth = 0

    @depthcontrol
    def USAGE(self, parent=None):
        current = UnlexerRule(name='USAGE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='USAGE', parent=current)
        self.exit_rule(current)
        return current
    USAGE.min_depth = 0

    @depthcontrol
    def USE(self, parent=None):
        current = UnlexerRule(name='USE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='USE', parent=current)
        self.exit_rule(current)
        return current
    USE.min_depth = 0

    @depthcontrol
    def USING(self, parent=None):
        current = UnlexerRule(name='USING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='USING', parent=current)
        self.exit_rule(current)
        return current
    USING.min_depth = 0

    @depthcontrol
    def VALUES(self, parent=None):
        current = UnlexerRule(name='VALUES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VALUES', parent=current)
        self.exit_rule(current)
        return current
    VALUES.min_depth = 0

    @depthcontrol
    def WHEN(self, parent=None):
        current = UnlexerRule(name='WHEN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WHEN', parent=current)
        self.exit_rule(current)
        return current
    WHEN.min_depth = 0

    @depthcontrol
    def WHERE(self, parent=None):
        current = UnlexerRule(name='WHERE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WHERE', parent=current)
        self.exit_rule(current)
        return current
    WHERE.min_depth = 0

    @depthcontrol
    def WHILE(self, parent=None):
        current = UnlexerRule(name='WHILE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WHILE', parent=current)
        self.exit_rule(current)
        return current
    WHILE.min_depth = 0

    @depthcontrol
    def WITH(self, parent=None):
        current = UnlexerRule(name='WITH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WITH', parent=current)
        self.exit_rule(current)
        return current
    WITH.min_depth = 0

    @depthcontrol
    def WRITE(self, parent=None):
        current = UnlexerRule(name='WRITE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WRITE', parent=current)
        self.exit_rule(current)
        return current
    WRITE.min_depth = 0

    @depthcontrol
    def XOR(self, parent=None):
        current = UnlexerRule(name='XOR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='XOR', parent=current)
        self.exit_rule(current)
        return current
    XOR.min_depth = 0

    @depthcontrol
    def ZEROFILL(self, parent=None):
        current = UnlexerRule(name='ZEROFILL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ZEROFILL', parent=current)
        self.exit_rule(current)
        return current
    ZEROFILL.min_depth = 0

    @depthcontrol
    def TINYINT(self, parent=None):
        current = UnlexerRule(name='TINYINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TINYINT', parent=current)
        self.exit_rule(current)
        return current
    TINYINT.min_depth = 0

    @depthcontrol
    def SMALLINT(self, parent=None):
        current = UnlexerRule(name='SMALLINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SMALLINT', parent=current)
        self.exit_rule(current)
        return current
    SMALLINT.min_depth = 0

    @depthcontrol
    def MEDIUMINT(self, parent=None):
        current = UnlexerRule(name='MEDIUMINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MEDIUMINT', parent=current)
        self.exit_rule(current)
        return current
    MEDIUMINT.min_depth = 0

    @depthcontrol
    def MIDDLEINT(self, parent=None):
        current = UnlexerRule(name='MIDDLEINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MIDDLEINT', parent=current)
        self.exit_rule(current)
        return current
    MIDDLEINT.min_depth = 0

    @depthcontrol
    def INT(self, parent=None):
        current = UnlexerRule(name='INT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INT', parent=current)
        self.exit_rule(current)
        return current
    INT.min_depth = 0

    @depthcontrol
    def INT1(self, parent=None):
        current = UnlexerRule(name='INT1', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INT1', parent=current)
        self.exit_rule(current)
        return current
    INT1.min_depth = 0

    @depthcontrol
    def INT2(self, parent=None):
        current = UnlexerRule(name='INT2', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INT2', parent=current)
        self.exit_rule(current)
        return current
    INT2.min_depth = 0

    @depthcontrol
    def INT3(self, parent=None):
        current = UnlexerRule(name='INT3', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INT3', parent=current)
        self.exit_rule(current)
        return current
    INT3.min_depth = 0

    @depthcontrol
    def INT4(self, parent=None):
        current = UnlexerRule(name='INT4', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INT4', parent=current)
        self.exit_rule(current)
        return current
    INT4.min_depth = 0

    @depthcontrol
    def INT8(self, parent=None):
        current = UnlexerRule(name='INT8', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INT8', parent=current)
        self.exit_rule(current)
        return current
    INT8.min_depth = 0

    @depthcontrol
    def INTEGER(self, parent=None):
        current = UnlexerRule(name='INTEGER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INTEGER', parent=current)
        self.exit_rule(current)
        return current
    INTEGER.min_depth = 0

    @depthcontrol
    def BIGINT(self, parent=None):
        current = UnlexerRule(name='BIGINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BIGINT', parent=current)
        self.exit_rule(current)
        return current
    BIGINT.min_depth = 0

    @depthcontrol
    def REAL(self, parent=None):
        current = UnlexerRule(name='REAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REAL', parent=current)
        self.exit_rule(current)
        return current
    REAL.min_depth = 0

    @depthcontrol
    def DOUBLE(self, parent=None):
        current = UnlexerRule(name='DOUBLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DOUBLE', parent=current)
        self.exit_rule(current)
        return current
    DOUBLE.min_depth = 0

    @depthcontrol
    def PRECISION(self, parent=None):
        current = UnlexerRule(name='PRECISION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PRECISION', parent=current)
        self.exit_rule(current)
        return current
    PRECISION.min_depth = 0

    @depthcontrol
    def FLOAT(self, parent=None):
        current = UnlexerRule(name='FLOAT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FLOAT', parent=current)
        self.exit_rule(current)
        return current
    FLOAT.min_depth = 0

    @depthcontrol
    def FLOAT4(self, parent=None):
        current = UnlexerRule(name='FLOAT4', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FLOAT4', parent=current)
        self.exit_rule(current)
        return current
    FLOAT4.min_depth = 0

    @depthcontrol
    def FLOAT8(self, parent=None):
        current = UnlexerRule(name='FLOAT8', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FLOAT8', parent=current)
        self.exit_rule(current)
        return current
    FLOAT8.min_depth = 0

    @depthcontrol
    def DECIMAL(self, parent=None):
        current = UnlexerRule(name='DECIMAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DECIMAL', parent=current)
        self.exit_rule(current)
        return current
    DECIMAL.min_depth = 0

    @depthcontrol
    def DEC(self, parent=None):
        current = UnlexerRule(name='DEC', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DEC', parent=current)
        self.exit_rule(current)
        return current
    DEC.min_depth = 0

    @depthcontrol
    def NUMERIC(self, parent=None):
        current = UnlexerRule(name='NUMERIC', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NUMERIC', parent=current)
        self.exit_rule(current)
        return current
    NUMERIC.min_depth = 0

    @depthcontrol
    def DATE(self, parent=None):
        current = UnlexerRule(name='DATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DATE', parent=current)
        self.exit_rule(current)
        return current
    DATE.min_depth = 0

    @depthcontrol
    def TIME(self, parent=None):
        current = UnlexerRule(name='TIME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TIME', parent=current)
        self.exit_rule(current)
        return current
    TIME.min_depth = 0

    @depthcontrol
    def TIMESTAMP(self, parent=None):
        current = UnlexerRule(name='TIMESTAMP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TIMESTAMP', parent=current)
        self.exit_rule(current)
        return current
    TIMESTAMP.min_depth = 0

    @depthcontrol
    def DATETIME(self, parent=None):
        current = UnlexerRule(name='DATETIME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DATETIME', parent=current)
        self.exit_rule(current)
        return current
    DATETIME.min_depth = 0

    @depthcontrol
    def YEAR(self, parent=None):
        current = UnlexerRule(name='YEAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='YEAR', parent=current)
        self.exit_rule(current)
        return current
    YEAR.min_depth = 0

    @depthcontrol
    def CHAR(self, parent=None):
        current = UnlexerRule(name='CHAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CHAR', parent=current)
        self.exit_rule(current)
        return current
    CHAR.min_depth = 0

    @depthcontrol
    def VARCHAR(self, parent=None):
        current = UnlexerRule(name='VARCHAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VARCHAR', parent=current)
        self.exit_rule(current)
        return current
    VARCHAR.min_depth = 0

    @depthcontrol
    def NVARCHAR(self, parent=None):
        current = UnlexerRule(name='NVARCHAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NVARCHAR', parent=current)
        self.exit_rule(current)
        return current
    NVARCHAR.min_depth = 0

    @depthcontrol
    def NATIONAL(self, parent=None):
        current = UnlexerRule(name='NATIONAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NATIONAL', parent=current)
        self.exit_rule(current)
        return current
    NATIONAL.min_depth = 0

    @depthcontrol
    def BINARY(self, parent=None):
        current = UnlexerRule(name='BINARY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BINARY', parent=current)
        self.exit_rule(current)
        return current
    BINARY.min_depth = 0

    @depthcontrol
    def VARBINARY(self, parent=None):
        current = UnlexerRule(name='VARBINARY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VARBINARY', parent=current)
        self.exit_rule(current)
        return current
    VARBINARY.min_depth = 0

    @depthcontrol
    def TINYBLOB(self, parent=None):
        current = UnlexerRule(name='TINYBLOB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TINYBLOB', parent=current)
        self.exit_rule(current)
        return current
    TINYBLOB.min_depth = 0

    @depthcontrol
    def BLOB(self, parent=None):
        current = UnlexerRule(name='BLOB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BLOB', parent=current)
        self.exit_rule(current)
        return current
    BLOB.min_depth = 0

    @depthcontrol
    def MEDIUMBLOB(self, parent=None):
        current = UnlexerRule(name='MEDIUMBLOB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MEDIUMBLOB', parent=current)
        self.exit_rule(current)
        return current
    MEDIUMBLOB.min_depth = 0

    @depthcontrol
    def LONG(self, parent=None):
        current = UnlexerRule(name='LONG', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LONG', parent=current)
        self.exit_rule(current)
        return current
    LONG.min_depth = 0

    @depthcontrol
    def LONGBLOB(self, parent=None):
        current = UnlexerRule(name='LONGBLOB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LONGBLOB', parent=current)
        self.exit_rule(current)
        return current
    LONGBLOB.min_depth = 0

    @depthcontrol
    def TINYTEXT(self, parent=None):
        current = UnlexerRule(name='TINYTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TINYTEXT', parent=current)
        self.exit_rule(current)
        return current
    TINYTEXT.min_depth = 0

    @depthcontrol
    def TEXT(self, parent=None):
        current = UnlexerRule(name='TEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TEXT', parent=current)
        self.exit_rule(current)
        return current
    TEXT.min_depth = 0

    @depthcontrol
    def MEDIUMTEXT(self, parent=None):
        current = UnlexerRule(name='MEDIUMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MEDIUMTEXT', parent=current)
        self.exit_rule(current)
        return current
    MEDIUMTEXT.min_depth = 0

    @depthcontrol
    def LONGTEXT(self, parent=None):
        current = UnlexerRule(name='LONGTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LONGTEXT', parent=current)
        self.exit_rule(current)
        return current
    LONGTEXT.min_depth = 0

    @depthcontrol
    def ENUM(self, parent=None):
        current = UnlexerRule(name='ENUM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ENUM', parent=current)
        self.exit_rule(current)
        return current
    ENUM.min_depth = 0

    @depthcontrol
    def VARYING(self, parent=None):
        current = UnlexerRule(name='VARYING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VARYING', parent=current)
        self.exit_rule(current)
        return current
    VARYING.min_depth = 0

    @depthcontrol
    def SERIAL(self, parent=None):
        current = UnlexerRule(name='SERIAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SERIAL', parent=current)
        self.exit_rule(current)
        return current
    SERIAL.min_depth = 0

    @depthcontrol
    def YEAR_MONTH(self, parent=None):
        current = UnlexerRule(name='YEAR_MONTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='YEAR_MONTH', parent=current)
        self.exit_rule(current)
        return current
    YEAR_MONTH.min_depth = 0

    @depthcontrol
    def DAY_HOUR(self, parent=None):
        current = UnlexerRule(name='DAY_HOUR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DAY_HOUR', parent=current)
        self.exit_rule(current)
        return current
    DAY_HOUR.min_depth = 0

    @depthcontrol
    def DAY_MINUTE(self, parent=None):
        current = UnlexerRule(name='DAY_MINUTE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DAY_MINUTE', parent=current)
        self.exit_rule(current)
        return current
    DAY_MINUTE.min_depth = 0

    @depthcontrol
    def DAY_SECOND(self, parent=None):
        current = UnlexerRule(name='DAY_SECOND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DAY_SECOND', parent=current)
        self.exit_rule(current)
        return current
    DAY_SECOND.min_depth = 0

    @depthcontrol
    def HOUR_MINUTE(self, parent=None):
        current = UnlexerRule(name='HOUR_MINUTE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='HOUR_MINUTE', parent=current)
        self.exit_rule(current)
        return current
    HOUR_MINUTE.min_depth = 0

    @depthcontrol
    def HOUR_SECOND(self, parent=None):
        current = UnlexerRule(name='HOUR_SECOND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='HOUR_SECOND', parent=current)
        self.exit_rule(current)
        return current
    HOUR_SECOND.min_depth = 0

    @depthcontrol
    def MINUTE_SECOND(self, parent=None):
        current = UnlexerRule(name='MINUTE_SECOND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MINUTE_SECOND', parent=current)
        self.exit_rule(current)
        return current
    MINUTE_SECOND.min_depth = 0

    @depthcontrol
    def SECOND_MICROSECOND(self, parent=None):
        current = UnlexerRule(name='SECOND_MICROSECOND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SECOND_MICROSECOND', parent=current)
        self.exit_rule(current)
        return current
    SECOND_MICROSECOND.min_depth = 0

    @depthcontrol
    def MINUTE_MICROSECOND(self, parent=None):
        current = UnlexerRule(name='MINUTE_MICROSECOND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MINUTE_MICROSECOND', parent=current)
        self.exit_rule(current)
        return current
    MINUTE_MICROSECOND.min_depth = 0

    @depthcontrol
    def HOUR_MICROSECOND(self, parent=None):
        current = UnlexerRule(name='HOUR_MICROSECOND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='HOUR_MICROSECOND', parent=current)
        self.exit_rule(current)
        return current
    HOUR_MICROSECOND.min_depth = 0

    @depthcontrol
    def DAY_MICROSECOND(self, parent=None):
        current = UnlexerRule(name='DAY_MICROSECOND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DAY_MICROSECOND', parent=current)
        self.exit_rule(current)
        return current
    DAY_MICROSECOND.min_depth = 0

    @depthcontrol
    def JSON_ARRAY(self, parent=None):
        current = UnlexerRule(name='JSON_ARRAY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_ARRAY', parent=current)
        self.exit_rule(current)
        return current
    JSON_ARRAY.min_depth = 0

    @depthcontrol
    def JSON_OBJECT(self, parent=None):
        current = UnlexerRule(name='JSON_OBJECT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_OBJECT', parent=current)
        self.exit_rule(current)
        return current
    JSON_OBJECT.min_depth = 0

    @depthcontrol
    def JSON_QUOTE(self, parent=None):
        current = UnlexerRule(name='JSON_QUOTE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_QUOTE', parent=current)
        self.exit_rule(current)
        return current
    JSON_QUOTE.min_depth = 0

    @depthcontrol
    def JSON_CONTAINS(self, parent=None):
        current = UnlexerRule(name='JSON_CONTAINS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_CONTAINS', parent=current)
        self.exit_rule(current)
        return current
    JSON_CONTAINS.min_depth = 0

    @depthcontrol
    def JSON_CONTAINS_PATH(self, parent=None):
        current = UnlexerRule(name='JSON_CONTAINS_PATH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_CONTAINS_PATH', parent=current)
        self.exit_rule(current)
        return current
    JSON_CONTAINS_PATH.min_depth = 0

    @depthcontrol
    def JSON_EXTRACT(self, parent=None):
        current = UnlexerRule(name='JSON_EXTRACT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_EXTRACT', parent=current)
        self.exit_rule(current)
        return current
    JSON_EXTRACT.min_depth = 0

    @depthcontrol
    def JSON_KEYS(self, parent=None):
        current = UnlexerRule(name='JSON_KEYS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_KEYS', parent=current)
        self.exit_rule(current)
        return current
    JSON_KEYS.min_depth = 0

    @depthcontrol
    def JSON_OVERLAPS(self, parent=None):
        current = UnlexerRule(name='JSON_OVERLAPS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_OVERLAPS', parent=current)
        self.exit_rule(current)
        return current
    JSON_OVERLAPS.min_depth = 0

    @depthcontrol
    def JSON_SEARCH(self, parent=None):
        current = UnlexerRule(name='JSON_SEARCH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_SEARCH', parent=current)
        self.exit_rule(current)
        return current
    JSON_SEARCH.min_depth = 0

    @depthcontrol
    def JSON_VALUE(self, parent=None):
        current = UnlexerRule(name='JSON_VALUE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_VALUE', parent=current)
        self.exit_rule(current)
        return current
    JSON_VALUE.min_depth = 0

    @depthcontrol
    def JSON_ARRAY_APPEND(self, parent=None):
        current = UnlexerRule(name='JSON_ARRAY_APPEND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_ARRAY_APPEND', parent=current)
        self.exit_rule(current)
        return current
    JSON_ARRAY_APPEND.min_depth = 0

    @depthcontrol
    def JSON_ARRAY_INSERT(self, parent=None):
        current = UnlexerRule(name='JSON_ARRAY_INSERT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_ARRAY_INSERT', parent=current)
        self.exit_rule(current)
        return current
    JSON_ARRAY_INSERT.min_depth = 0

    @depthcontrol
    def JSON_INSERT(self, parent=None):
        current = UnlexerRule(name='JSON_INSERT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_INSERT', parent=current)
        self.exit_rule(current)
        return current
    JSON_INSERT.min_depth = 0

    @depthcontrol
    def JSON_MERGE(self, parent=None):
        current = UnlexerRule(name='JSON_MERGE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_MERGE', parent=current)
        self.exit_rule(current)
        return current
    JSON_MERGE.min_depth = 0

    @depthcontrol
    def JSON_MERGE_PATCH(self, parent=None):
        current = UnlexerRule(name='JSON_MERGE_PATCH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_MERGE_PATCH', parent=current)
        self.exit_rule(current)
        return current
    JSON_MERGE_PATCH.min_depth = 0

    @depthcontrol
    def JSON_MERGE_PRESERVE(self, parent=None):
        current = UnlexerRule(name='JSON_MERGE_PRESERVE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_MERGE_PRESERVE', parent=current)
        self.exit_rule(current)
        return current
    JSON_MERGE_PRESERVE.min_depth = 0

    @depthcontrol
    def JSON_REMOVE(self, parent=None):
        current = UnlexerRule(name='JSON_REMOVE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_REMOVE', parent=current)
        self.exit_rule(current)
        return current
    JSON_REMOVE.min_depth = 0

    @depthcontrol
    def JSON_REPLACE(self, parent=None):
        current = UnlexerRule(name='JSON_REPLACE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_REPLACE', parent=current)
        self.exit_rule(current)
        return current
    JSON_REPLACE.min_depth = 0

    @depthcontrol
    def JSON_SET(self, parent=None):
        current = UnlexerRule(name='JSON_SET', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_SET', parent=current)
        self.exit_rule(current)
        return current
    JSON_SET.min_depth = 0

    @depthcontrol
    def JSON_UNQUOTE(self, parent=None):
        current = UnlexerRule(name='JSON_UNQUOTE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_UNQUOTE', parent=current)
        self.exit_rule(current)
        return current
    JSON_UNQUOTE.min_depth = 0

    @depthcontrol
    def JSON_DEPTH(self, parent=None):
        current = UnlexerRule(name='JSON_DEPTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_DEPTH', parent=current)
        self.exit_rule(current)
        return current
    JSON_DEPTH.min_depth = 0

    @depthcontrol
    def JSON_LENGTH(self, parent=None):
        current = UnlexerRule(name='JSON_LENGTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_LENGTH', parent=current)
        self.exit_rule(current)
        return current
    JSON_LENGTH.min_depth = 0

    @depthcontrol
    def JSON_TYPE(self, parent=None):
        current = UnlexerRule(name='JSON_TYPE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_TYPE', parent=current)
        self.exit_rule(current)
        return current
    JSON_TYPE.min_depth = 0

    @depthcontrol
    def JSON_VALID(self, parent=None):
        current = UnlexerRule(name='JSON_VALID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_VALID', parent=current)
        self.exit_rule(current)
        return current
    JSON_VALID.min_depth = 0

    @depthcontrol
    def JSON_TABLE(self, parent=None):
        current = UnlexerRule(name='JSON_TABLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_TABLE', parent=current)
        self.exit_rule(current)
        return current
    JSON_TABLE.min_depth = 0

    @depthcontrol
    def JSON_SCHEMA_VALID(self, parent=None):
        current = UnlexerRule(name='JSON_SCHEMA_VALID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_SCHEMA_VALID', parent=current)
        self.exit_rule(current)
        return current
    JSON_SCHEMA_VALID.min_depth = 0

    @depthcontrol
    def JSON_SCHEMA_VALIDATION_REPORT(self, parent=None):
        current = UnlexerRule(name='JSON_SCHEMA_VALIDATION_REPORT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_SCHEMA_VALIDATION_REPORT', parent=current)
        self.exit_rule(current)
        return current
    JSON_SCHEMA_VALIDATION_REPORT.min_depth = 0

    @depthcontrol
    def JSON_PRETTY(self, parent=None):
        current = UnlexerRule(name='JSON_PRETTY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_PRETTY', parent=current)
        self.exit_rule(current)
        return current
    JSON_PRETTY.min_depth = 0

    @depthcontrol
    def JSON_STORAGE_FREE(self, parent=None):
        current = UnlexerRule(name='JSON_STORAGE_FREE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_STORAGE_FREE', parent=current)
        self.exit_rule(current)
        return current
    JSON_STORAGE_FREE.min_depth = 0

    @depthcontrol
    def JSON_STORAGE_SIZE(self, parent=None):
        current = UnlexerRule(name='JSON_STORAGE_SIZE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_STORAGE_SIZE', parent=current)
        self.exit_rule(current)
        return current
    JSON_STORAGE_SIZE.min_depth = 0

    @depthcontrol
    def JSON_ARRAYAGG(self, parent=None):
        current = UnlexerRule(name='JSON_ARRAYAGG', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_ARRAYAGG', parent=current)
        self.exit_rule(current)
        return current
    JSON_ARRAYAGG.min_depth = 0

    @depthcontrol
    def JSON_OBJECTAGG(self, parent=None):
        current = UnlexerRule(name='JSON_OBJECTAGG', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON_OBJECTAGG', parent=current)
        self.exit_rule(current)
        return current
    JSON_OBJECTAGG.min_depth = 0

    @depthcontrol
    def AVG(self, parent=None):
        current = UnlexerRule(name='AVG', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='AVG', parent=current)
        self.exit_rule(current)
        return current
    AVG.min_depth = 0

    @depthcontrol
    def BIT_AND(self, parent=None):
        current = UnlexerRule(name='BIT_AND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BIT_AND', parent=current)
        self.exit_rule(current)
        return current
    BIT_AND.min_depth = 0

    @depthcontrol
    def BIT_OR(self, parent=None):
        current = UnlexerRule(name='BIT_OR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BIT_OR', parent=current)
        self.exit_rule(current)
        return current
    BIT_OR.min_depth = 0

    @depthcontrol
    def BIT_XOR(self, parent=None):
        current = UnlexerRule(name='BIT_XOR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BIT_XOR', parent=current)
        self.exit_rule(current)
        return current
    BIT_XOR.min_depth = 0

    @depthcontrol
    def COUNT(self, parent=None):
        current = UnlexerRule(name='COUNT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COUNT', parent=current)
        self.exit_rule(current)
        return current
    COUNT.min_depth = 0

    @depthcontrol
    def GROUP_CONCAT(self, parent=None):
        current = UnlexerRule(name='GROUP_CONCAT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GROUP_CONCAT', parent=current)
        self.exit_rule(current)
        return current
    GROUP_CONCAT.min_depth = 0

    @depthcontrol
    def MAX(self, parent=None):
        current = UnlexerRule(name='MAX', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MAX', parent=current)
        self.exit_rule(current)
        return current
    MAX.min_depth = 0

    @depthcontrol
    def MIN(self, parent=None):
        current = UnlexerRule(name='MIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MIN', parent=current)
        self.exit_rule(current)
        return current
    MIN.min_depth = 0

    @depthcontrol
    def STD(self, parent=None):
        current = UnlexerRule(name='STD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STD', parent=current)
        self.exit_rule(current)
        return current
    STD.min_depth = 0

    @depthcontrol
    def STDDEV(self, parent=None):
        current = UnlexerRule(name='STDDEV', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STDDEV', parent=current)
        self.exit_rule(current)
        return current
    STDDEV.min_depth = 0

    @depthcontrol
    def STDDEV_POP(self, parent=None):
        current = UnlexerRule(name='STDDEV_POP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STDDEV_POP', parent=current)
        self.exit_rule(current)
        return current
    STDDEV_POP.min_depth = 0

    @depthcontrol
    def STDDEV_SAMP(self, parent=None):
        current = UnlexerRule(name='STDDEV_SAMP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STDDEV_SAMP', parent=current)
        self.exit_rule(current)
        return current
    STDDEV_SAMP.min_depth = 0

    @depthcontrol
    def SUM(self, parent=None):
        current = UnlexerRule(name='SUM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SUM', parent=current)
        self.exit_rule(current)
        return current
    SUM.min_depth = 0

    @depthcontrol
    def VAR_POP(self, parent=None):
        current = UnlexerRule(name='VAR_POP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VAR_POP', parent=current)
        self.exit_rule(current)
        return current
    VAR_POP.min_depth = 0

    @depthcontrol
    def VAR_SAMP(self, parent=None):
        current = UnlexerRule(name='VAR_SAMP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VAR_SAMP', parent=current)
        self.exit_rule(current)
        return current
    VAR_SAMP.min_depth = 0

    @depthcontrol
    def VARIANCE(self, parent=None):
        current = UnlexerRule(name='VARIANCE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VARIANCE', parent=current)
        self.exit_rule(current)
        return current
    VARIANCE.min_depth = 0

    @depthcontrol
    def CURRENT_DATE(self, parent=None):
        current = UnlexerRule(name='CURRENT_DATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CURRENT_DATE', parent=current)
        self.exit_rule(current)
        return current
    CURRENT_DATE.min_depth = 0

    @depthcontrol
    def CURRENT_TIME(self, parent=None):
        current = UnlexerRule(name='CURRENT_TIME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CURRENT_TIME', parent=current)
        self.exit_rule(current)
        return current
    CURRENT_TIME.min_depth = 0

    @depthcontrol
    def CURRENT_TIMESTAMP(self, parent=None):
        current = UnlexerRule(name='CURRENT_TIMESTAMP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CURRENT_TIMESTAMP', parent=current)
        self.exit_rule(current)
        return current
    CURRENT_TIMESTAMP.min_depth = 0

    @depthcontrol
    def LOCALTIME(self, parent=None):
        current = UnlexerRule(name='LOCALTIME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LOCALTIME', parent=current)
        self.exit_rule(current)
        return current
    LOCALTIME.min_depth = 0

    @depthcontrol
    def CURDATE(self, parent=None):
        current = UnlexerRule(name='CURDATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CURDATE', parent=current)
        self.exit_rule(current)
        return current
    CURDATE.min_depth = 0

    @depthcontrol
    def CURTIME(self, parent=None):
        current = UnlexerRule(name='CURTIME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CURTIME', parent=current)
        self.exit_rule(current)
        return current
    CURTIME.min_depth = 0

    @depthcontrol
    def DATE_ADD(self, parent=None):
        current = UnlexerRule(name='DATE_ADD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DATE_ADD', parent=current)
        self.exit_rule(current)
        return current
    DATE_ADD.min_depth = 0

    @depthcontrol
    def DATE_SUB(self, parent=None):
        current = UnlexerRule(name='DATE_SUB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DATE_SUB', parent=current)
        self.exit_rule(current)
        return current
    DATE_SUB.min_depth = 0

    @depthcontrol
    def EXTRACT(self, parent=None):
        current = UnlexerRule(name='EXTRACT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EXTRACT', parent=current)
        self.exit_rule(current)
        return current
    EXTRACT.min_depth = 0

    @depthcontrol
    def LOCALTIMESTAMP(self, parent=None):
        current = UnlexerRule(name='LOCALTIMESTAMP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LOCALTIMESTAMP', parent=current)
        self.exit_rule(current)
        return current
    LOCALTIMESTAMP.min_depth = 0

    @depthcontrol
    def NOW(self, parent=None):
        current = UnlexerRule(name='NOW', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NOW', parent=current)
        self.exit_rule(current)
        return current
    NOW.min_depth = 0

    @depthcontrol
    def POSITION(self, parent=None):
        current = UnlexerRule(name='POSITION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='POSITION', parent=current)
        self.exit_rule(current)
        return current
    POSITION.min_depth = 0

    @depthcontrol
    def SUBSTR(self, parent=None):
        current = UnlexerRule(name='SUBSTR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SUBSTR', parent=current)
        self.exit_rule(current)
        return current
    SUBSTR.min_depth = 0

    @depthcontrol
    def SUBSTRING(self, parent=None):
        current = UnlexerRule(name='SUBSTRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SUBSTRING', parent=current)
        self.exit_rule(current)
        return current
    SUBSTRING.min_depth = 0

    @depthcontrol
    def SYSDATE(self, parent=None):
        current = UnlexerRule(name='SYSDATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SYSDATE', parent=current)
        self.exit_rule(current)
        return current
    SYSDATE.min_depth = 0

    @depthcontrol
    def TRIM(self, parent=None):
        current = UnlexerRule(name='TRIM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TRIM', parent=current)
        self.exit_rule(current)
        return current
    TRIM.min_depth = 0

    @depthcontrol
    def UTC_DATE(self, parent=None):
        current = UnlexerRule(name='UTC_DATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UTC_DATE', parent=current)
        self.exit_rule(current)
        return current
    UTC_DATE.min_depth = 0

    @depthcontrol
    def UTC_TIME(self, parent=None):
        current = UnlexerRule(name='UTC_TIME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UTC_TIME', parent=current)
        self.exit_rule(current)
        return current
    UTC_TIME.min_depth = 0

    @depthcontrol
    def UTC_TIMESTAMP(self, parent=None):
        current = UnlexerRule(name='UTC_TIMESTAMP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UTC_TIMESTAMP', parent=current)
        self.exit_rule(current)
        return current
    UTC_TIMESTAMP.min_depth = 0

    @depthcontrol
    def ACCOUNT(self, parent=None):
        current = UnlexerRule(name='ACCOUNT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ACCOUNT', parent=current)
        self.exit_rule(current)
        return current
    ACCOUNT.min_depth = 0

    @depthcontrol
    def ACTION(self, parent=None):
        current = UnlexerRule(name='ACTION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ACTION', parent=current)
        self.exit_rule(current)
        return current
    ACTION.min_depth = 0

    @depthcontrol
    def ADMIN(self, parent=None):
        current = UnlexerRule(name='ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ADMIN', parent=current)
        self.exit_rule(current)
        return current
    ADMIN.min_depth = 0

    @depthcontrol
    def NULL(self, parent=None):
        current = UnlexerRule(name='NULL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NULL', parent=current)
        self.exit_rule(current)
        return current
    NULL.min_depth = 0

    @depthcontrol
    def OPTIONAL(self, parent=None):
        current = UnlexerRule(name='OPTIONAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OPTIONAL', parent=current)
        self.exit_rule(current)
        return current
    OPTIONAL.min_depth = 0

    @depthcontrol
    def AFTER(self, parent=None):
        current = UnlexerRule(name='AFTER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='AFTER', parent=current)
        self.exit_rule(current)
        return current
    AFTER.min_depth = 0

    @depthcontrol
    def AGGREGATE(self, parent=None):
        current = UnlexerRule(name='AGGREGATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='AGGREGATE', parent=current)
        self.exit_rule(current)
        return current
    AGGREGATE.min_depth = 0

    @depthcontrol
    def ALGORITHM(self, parent=None):
        current = UnlexerRule(name='ALGORITHM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ALGORITHM', parent=current)
        self.exit_rule(current)
        return current
    ALGORITHM.min_depth = 0

    @depthcontrol
    def ANY(self, parent=None):
        current = UnlexerRule(name='ANY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ANY', parent=current)
        self.exit_rule(current)
        return current
    ANY.min_depth = 0

    @depthcontrol
    def AT(self, parent=None):
        current = UnlexerRule(name='AT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='AT', parent=current)
        self.exit_rule(current)
        return current
    AT.min_depth = 0

    @depthcontrol
    def AUTHORS(self, parent=None):
        current = UnlexerRule(name='AUTHORS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='AUTHORS', parent=current)
        self.exit_rule(current)
        return current
    AUTHORS.min_depth = 0

    @depthcontrol
    def AUTOCOMMIT(self, parent=None):
        current = UnlexerRule(name='AUTOCOMMIT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='AUTOCOMMIT', parent=current)
        self.exit_rule(current)
        return current
    AUTOCOMMIT.min_depth = 0

    @depthcontrol
    def AUTOEXTEND_SIZE(self, parent=None):
        current = UnlexerRule(name='AUTOEXTEND_SIZE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='AUTOEXTEND_SIZE', parent=current)
        self.exit_rule(current)
        return current
    AUTOEXTEND_SIZE.min_depth = 0

    @depthcontrol
    def AUTO_INCREMENT(self, parent=None):
        current = UnlexerRule(name='AUTO_INCREMENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='AUTO_INCREMENT', parent=current)
        self.exit_rule(current)
        return current
    AUTO_INCREMENT.min_depth = 0

    @depthcontrol
    def AVG_ROW_LENGTH(self, parent=None):
        current = UnlexerRule(name='AVG_ROW_LENGTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='AVG_ROW_LENGTH', parent=current)
        self.exit_rule(current)
        return current
    AVG_ROW_LENGTH.min_depth = 0

    @depthcontrol
    def BEGIN(self, parent=None):
        current = UnlexerRule(name='BEGIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BEGIN', parent=current)
        self.exit_rule(current)
        return current
    BEGIN.min_depth = 0

    @depthcontrol
    def BINLOG(self, parent=None):
        current = UnlexerRule(name='BINLOG', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BINLOG', parent=current)
        self.exit_rule(current)
        return current
    BINLOG.min_depth = 0

    @depthcontrol
    def BIT(self, parent=None):
        current = UnlexerRule(name='BIT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BIT', parent=current)
        self.exit_rule(current)
        return current
    BIT.min_depth = 0

    @depthcontrol
    def BLOCK(self, parent=None):
        current = UnlexerRule(name='BLOCK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BLOCK', parent=current)
        self.exit_rule(current)
        return current
    BLOCK.min_depth = 0

    @depthcontrol
    def BOOL(self, parent=None):
        current = UnlexerRule(name='BOOL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BOOL', parent=current)
        self.exit_rule(current)
        return current
    BOOL.min_depth = 0

    @depthcontrol
    def BOOLEAN(self, parent=None):
        current = UnlexerRule(name='BOOLEAN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BOOLEAN', parent=current)
        self.exit_rule(current)
        return current
    BOOLEAN.min_depth = 0

    @depthcontrol
    def BTREE(self, parent=None):
        current = UnlexerRule(name='BTREE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BTREE', parent=current)
        self.exit_rule(current)
        return current
    BTREE.min_depth = 0

    @depthcontrol
    def CACHE(self, parent=None):
        current = UnlexerRule(name='CACHE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CACHE', parent=current)
        self.exit_rule(current)
        return current
    CACHE.min_depth = 0

    @depthcontrol
    def CASCADED(self, parent=None):
        current = UnlexerRule(name='CASCADED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CASCADED', parent=current)
        self.exit_rule(current)
        return current
    CASCADED.min_depth = 0

    @depthcontrol
    def CHAIN(self, parent=None):
        current = UnlexerRule(name='CHAIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CHAIN', parent=current)
        self.exit_rule(current)
        return current
    CHAIN.min_depth = 0

    @depthcontrol
    def CHANGED(self, parent=None):
        current = UnlexerRule(name='CHANGED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CHANGED', parent=current)
        self.exit_rule(current)
        return current
    CHANGED.min_depth = 0

    @depthcontrol
    def CHANNEL(self, parent=None):
        current = UnlexerRule(name='CHANNEL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CHANNEL', parent=current)
        self.exit_rule(current)
        return current
    CHANNEL.min_depth = 0

    @depthcontrol
    def CHECKSUM(self, parent=None):
        current = UnlexerRule(name='CHECKSUM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CHECKSUM', parent=current)
        self.exit_rule(current)
        return current
    CHECKSUM.min_depth = 0

    @depthcontrol
    def PAGE_CHECKSUM(self, parent=None):
        current = UnlexerRule(name='PAGE_CHECKSUM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PAGE_CHECKSUM', parent=current)
        self.exit_rule(current)
        return current
    PAGE_CHECKSUM.min_depth = 0

    @depthcontrol
    def CIPHER(self, parent=None):
        current = UnlexerRule(name='CIPHER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CIPHER', parent=current)
        self.exit_rule(current)
        return current
    CIPHER.min_depth = 0

    @depthcontrol
    def CLASS_ORIGIN(self, parent=None):
        current = UnlexerRule(name='CLASS_ORIGIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CLASS_ORIGIN', parent=current)
        self.exit_rule(current)
        return current
    CLASS_ORIGIN.min_depth = 0

    @depthcontrol
    def CLIENT(self, parent=None):
        current = UnlexerRule(name='CLIENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CLIENT', parent=current)
        self.exit_rule(current)
        return current
    CLIENT.min_depth = 0

    @depthcontrol
    def CLOSE(self, parent=None):
        current = UnlexerRule(name='CLOSE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CLOSE', parent=current)
        self.exit_rule(current)
        return current
    CLOSE.min_depth = 0

    @depthcontrol
    def COALESCE(self, parent=None):
        current = UnlexerRule(name='COALESCE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COALESCE', parent=current)
        self.exit_rule(current)
        return current
    COALESCE.min_depth = 0

    @depthcontrol
    def CODE(self, parent=None):
        current = UnlexerRule(name='CODE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CODE', parent=current)
        self.exit_rule(current)
        return current
    CODE.min_depth = 0

    @depthcontrol
    def COLUMNS(self, parent=None):
        current = UnlexerRule(name='COLUMNS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COLUMNS', parent=current)
        self.exit_rule(current)
        return current
    COLUMNS.min_depth = 0

    @depthcontrol
    def COLUMN_FORMAT(self, parent=None):
        current = UnlexerRule(name='COLUMN_FORMAT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COLUMN_FORMAT', parent=current)
        self.exit_rule(current)
        return current
    COLUMN_FORMAT.min_depth = 0

    @depthcontrol
    def COLUMN_NAME(self, parent=None):
        current = UnlexerRule(name='COLUMN_NAME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COLUMN_NAME', parent=current)
        self.exit_rule(current)
        return current
    COLUMN_NAME.min_depth = 0

    @depthcontrol
    def COMMENT(self, parent=None):
        current = UnlexerRule(name='COMMENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COMMENT', parent=current)
        self.exit_rule(current)
        return current
    COMMENT.min_depth = 0

    @depthcontrol
    def COMMIT(self, parent=None):
        current = UnlexerRule(name='COMMIT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COMMIT', parent=current)
        self.exit_rule(current)
        return current
    COMMIT.min_depth = 0

    @depthcontrol
    def COMPACT(self, parent=None):
        current = UnlexerRule(name='COMPACT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COMPACT', parent=current)
        self.exit_rule(current)
        return current
    COMPACT.min_depth = 0

    @depthcontrol
    def COMPLETION(self, parent=None):
        current = UnlexerRule(name='COMPLETION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COMPLETION', parent=current)
        self.exit_rule(current)
        return current
    COMPLETION.min_depth = 0

    @depthcontrol
    def COMPRESSED(self, parent=None):
        current = UnlexerRule(name='COMPRESSED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COMPRESSED', parent=current)
        self.exit_rule(current)
        return current
    COMPRESSED.min_depth = 0

    @depthcontrol
    def COMPRESSION(self, parent=None):
        current = UnlexerRule(name='COMPRESSION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COMPRESSION', parent=current)
        self.exit_rule(current)
        return current
    COMPRESSION.min_depth = 0

    @depthcontrol
    def CONCURRENT(self, parent=None):
        current = UnlexerRule(name='CONCURRENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONCURRENT', parent=current)
        self.exit_rule(current)
        return current
    CONCURRENT.min_depth = 0

    @depthcontrol
    def CONNECTION(self, parent=None):
        current = UnlexerRule(name='CONNECTION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONNECTION', parent=current)
        self.exit_rule(current)
        return current
    CONNECTION.min_depth = 0

    @depthcontrol
    def CONSISTENT(self, parent=None):
        current = UnlexerRule(name='CONSISTENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONSISTENT', parent=current)
        self.exit_rule(current)
        return current
    CONSISTENT.min_depth = 0

    @depthcontrol
    def CONSTRAINT_CATALOG(self, parent=None):
        current = UnlexerRule(name='CONSTRAINT_CATALOG', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONSTRAINT_CATALOG', parent=current)
        self.exit_rule(current)
        return current
    CONSTRAINT_CATALOG.min_depth = 0

    @depthcontrol
    def CONSTRAINT_SCHEMA(self, parent=None):
        current = UnlexerRule(name='CONSTRAINT_SCHEMA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONSTRAINT_SCHEMA', parent=current)
        self.exit_rule(current)
        return current
    CONSTRAINT_SCHEMA.min_depth = 0

    @depthcontrol
    def CONSTRAINT_NAME(self, parent=None):
        current = UnlexerRule(name='CONSTRAINT_NAME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONSTRAINT_NAME', parent=current)
        self.exit_rule(current)
        return current
    CONSTRAINT_NAME.min_depth = 0

    @depthcontrol
    def CONTAINS(self, parent=None):
        current = UnlexerRule(name='CONTAINS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONTAINS', parent=current)
        self.exit_rule(current)
        return current
    CONTAINS.min_depth = 0

    @depthcontrol
    def CONTEXT(self, parent=None):
        current = UnlexerRule(name='CONTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONTEXT', parent=current)
        self.exit_rule(current)
        return current
    CONTEXT.min_depth = 0

    @depthcontrol
    def CONTRIBUTORS(self, parent=None):
        current = UnlexerRule(name='CONTRIBUTORS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONTRIBUTORS', parent=current)
        self.exit_rule(current)
        return current
    CONTRIBUTORS.min_depth = 0

    @depthcontrol
    def COPY(self, parent=None):
        current = UnlexerRule(name='COPY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COPY', parent=current)
        self.exit_rule(current)
        return current
    COPY.min_depth = 0

    @depthcontrol
    def CPU(self, parent=None):
        current = UnlexerRule(name='CPU', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CPU', parent=current)
        self.exit_rule(current)
        return current
    CPU.min_depth = 0

    @depthcontrol
    def CURSOR_NAME(self, parent=None):
        current = UnlexerRule(name='CURSOR_NAME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CURSOR_NAME', parent=current)
        self.exit_rule(current)
        return current
    CURSOR_NAME.min_depth = 0

    @depthcontrol
    def DATA(self, parent=None):
        current = UnlexerRule(name='DATA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DATA', parent=current)
        self.exit_rule(current)
        return current
    DATA.min_depth = 0

    @depthcontrol
    def DATAFILE(self, parent=None):
        current = UnlexerRule(name='DATAFILE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DATAFILE', parent=current)
        self.exit_rule(current)
        return current
    DATAFILE.min_depth = 0

    @depthcontrol
    def DEALLOCATE(self, parent=None):
        current = UnlexerRule(name='DEALLOCATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DEALLOCATE', parent=current)
        self.exit_rule(current)
        return current
    DEALLOCATE.min_depth = 0

    @depthcontrol
    def DEFAULT_AUTH(self, parent=None):
        current = UnlexerRule(name='DEFAULT_AUTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DEFAULT_AUTH', parent=current)
        self.exit_rule(current)
        return current
    DEFAULT_AUTH.min_depth = 0

    @depthcontrol
    def DEFINER(self, parent=None):
        current = UnlexerRule(name='DEFINER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DEFINER', parent=current)
        self.exit_rule(current)
        return current
    DEFINER.min_depth = 0

    @depthcontrol
    def DELAY_KEY_WRITE(self, parent=None):
        current = UnlexerRule(name='DELAY_KEY_WRITE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DELAY_KEY_WRITE', parent=current)
        self.exit_rule(current)
        return current
    DELAY_KEY_WRITE.min_depth = 0

    @depthcontrol
    def DES_KEY_FILE(self, parent=None):
        current = UnlexerRule(name='DES_KEY_FILE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DES_KEY_FILE', parent=current)
        self.exit_rule(current)
        return current
    DES_KEY_FILE.min_depth = 0

    @depthcontrol
    def DIRECTORY(self, parent=None):
        current = UnlexerRule(name='DIRECTORY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DIRECTORY', parent=current)
        self.exit_rule(current)
        return current
    DIRECTORY.min_depth = 0

    @depthcontrol
    def DISABLE(self, parent=None):
        current = UnlexerRule(name='DISABLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DISABLE', parent=current)
        self.exit_rule(current)
        return current
    DISABLE.min_depth = 0

    @depthcontrol
    def DISCARD(self, parent=None):
        current = UnlexerRule(name='DISCARD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DISCARD', parent=current)
        self.exit_rule(current)
        return current
    DISCARD.min_depth = 0

    @depthcontrol
    def DISK(self, parent=None):
        current = UnlexerRule(name='DISK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DISK', parent=current)
        self.exit_rule(current)
        return current
    DISK.min_depth = 0

    @depthcontrol
    def DO(self, parent=None):
        current = UnlexerRule(name='DO', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DO', parent=current)
        self.exit_rule(current)
        return current
    DO.min_depth = 0

    @depthcontrol
    def DUMPFILE(self, parent=None):
        current = UnlexerRule(name='DUMPFILE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DUMPFILE', parent=current)
        self.exit_rule(current)
        return current
    DUMPFILE.min_depth = 0

    @depthcontrol
    def DUPLICATE(self, parent=None):
        current = UnlexerRule(name='DUPLICATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DUPLICATE', parent=current)
        self.exit_rule(current)
        return current
    DUPLICATE.min_depth = 0

    @depthcontrol
    def DYNAMIC(self, parent=None):
        current = UnlexerRule(name='DYNAMIC', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DYNAMIC', parent=current)
        self.exit_rule(current)
        return current
    DYNAMIC.min_depth = 0

    @depthcontrol
    def ENABLE(self, parent=None):
        current = UnlexerRule(name='ENABLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ENABLE', parent=current)
        self.exit_rule(current)
        return current
    ENABLE.min_depth = 0

    @depthcontrol
    def ENCRYPTION(self, parent=None):
        current = UnlexerRule(name='ENCRYPTION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ENCRYPTION', parent=current)
        self.exit_rule(current)
        return current
    ENCRYPTION.min_depth = 0

    @depthcontrol
    def END(self, parent=None):
        current = UnlexerRule(name='END', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='END', parent=current)
        self.exit_rule(current)
        return current
    END.min_depth = 0

    @depthcontrol
    def ENDS(self, parent=None):
        current = UnlexerRule(name='ENDS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ENDS', parent=current)
        self.exit_rule(current)
        return current
    ENDS.min_depth = 0

    @depthcontrol
    def ENGINE(self, parent=None):
        current = UnlexerRule(name='ENGINE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ENGINE', parent=current)
        self.exit_rule(current)
        return current
    ENGINE.min_depth = 0

    @depthcontrol
    def ENGINES(self, parent=None):
        current = UnlexerRule(name='ENGINES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ENGINES', parent=current)
        self.exit_rule(current)
        return current
    ENGINES.min_depth = 0

    @depthcontrol
    def ERROR(self, parent=None):
        current = UnlexerRule(name='ERROR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ERROR', parent=current)
        self.exit_rule(current)
        return current
    ERROR.min_depth = 0

    @depthcontrol
    def ERRORS(self, parent=None):
        current = UnlexerRule(name='ERRORS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ERRORS', parent=current)
        self.exit_rule(current)
        return current
    ERRORS.min_depth = 0

    @depthcontrol
    def ESCAPE(self, parent=None):
        current = UnlexerRule(name='ESCAPE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ESCAPE', parent=current)
        self.exit_rule(current)
        return current
    ESCAPE.min_depth = 0

    @depthcontrol
    def EVEN(self, parent=None):
        current = UnlexerRule(name='EVEN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EVEN', parent=current)
        self.exit_rule(current)
        return current
    EVEN.min_depth = 0

    @depthcontrol
    def EVENT(self, parent=None):
        current = UnlexerRule(name='EVENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EVENT', parent=current)
        self.exit_rule(current)
        return current
    EVENT.min_depth = 0

    @depthcontrol
    def EVENTS(self, parent=None):
        current = UnlexerRule(name='EVENTS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EVENTS', parent=current)
        self.exit_rule(current)
        return current
    EVENTS.min_depth = 0

    @depthcontrol
    def EVERY(self, parent=None):
        current = UnlexerRule(name='EVERY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EVERY', parent=current)
        self.exit_rule(current)
        return current
    EVERY.min_depth = 0

    @depthcontrol
    def EXCHANGE(self, parent=None):
        current = UnlexerRule(name='EXCHANGE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EXCHANGE', parent=current)
        self.exit_rule(current)
        return current
    EXCHANGE.min_depth = 0

    @depthcontrol
    def EXCLUSIVE(self, parent=None):
        current = UnlexerRule(name='EXCLUSIVE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EXCLUSIVE', parent=current)
        self.exit_rule(current)
        return current
    EXCLUSIVE.min_depth = 0

    @depthcontrol
    def EXPIRE(self, parent=None):
        current = UnlexerRule(name='EXPIRE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EXPIRE', parent=current)
        self.exit_rule(current)
        return current
    EXPIRE.min_depth = 0

    @depthcontrol
    def EXPORT(self, parent=None):
        current = UnlexerRule(name='EXPORT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EXPORT', parent=current)
        self.exit_rule(current)
        return current
    EXPORT.min_depth = 0

    @depthcontrol
    def EXTENDED(self, parent=None):
        current = UnlexerRule(name='EXTENDED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EXTENDED', parent=current)
        self.exit_rule(current)
        return current
    EXTENDED.min_depth = 0

    @depthcontrol
    def EXTENT_SIZE(self, parent=None):
        current = UnlexerRule(name='EXTENT_SIZE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EXTENT_SIZE', parent=current)
        self.exit_rule(current)
        return current
    EXTENT_SIZE.min_depth = 0

    @depthcontrol
    def FAST(self, parent=None):
        current = UnlexerRule(name='FAST', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FAST', parent=current)
        self.exit_rule(current)
        return current
    FAST.min_depth = 0

    @depthcontrol
    def FAULTS(self, parent=None):
        current = UnlexerRule(name='FAULTS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FAULTS', parent=current)
        self.exit_rule(current)
        return current
    FAULTS.min_depth = 0

    @depthcontrol
    def FIELDS(self, parent=None):
        current = UnlexerRule(name='FIELDS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FIELDS', parent=current)
        self.exit_rule(current)
        return current
    FIELDS.min_depth = 0

    @depthcontrol
    def FILE_BLOCK_SIZE(self, parent=None):
        current = UnlexerRule(name='FILE_BLOCK_SIZE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FILE_BLOCK_SIZE', parent=current)
        self.exit_rule(current)
        return current
    FILE_BLOCK_SIZE.min_depth = 0

    @depthcontrol
    def FILTER(self, parent=None):
        current = UnlexerRule(name='FILTER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FILTER', parent=current)
        self.exit_rule(current)
        return current
    FILTER.min_depth = 0

    @depthcontrol
    def FIRST(self, parent=None):
        current = UnlexerRule(name='FIRST', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FIRST', parent=current)
        self.exit_rule(current)
        return current
    FIRST.min_depth = 0

    @depthcontrol
    def FIXED(self, parent=None):
        current = UnlexerRule(name='FIXED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FIXED', parent=current)
        self.exit_rule(current)
        return current
    FIXED.min_depth = 0

    @depthcontrol
    def FLUSH(self, parent=None):
        current = UnlexerRule(name='FLUSH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FLUSH', parent=current)
        self.exit_rule(current)
        return current
    FLUSH.min_depth = 0

    @depthcontrol
    def FOLLOWS(self, parent=None):
        current = UnlexerRule(name='FOLLOWS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FOLLOWS', parent=current)
        self.exit_rule(current)
        return current
    FOLLOWS.min_depth = 0

    @depthcontrol
    def FOUND(self, parent=None):
        current = UnlexerRule(name='FOUND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FOUND', parent=current)
        self.exit_rule(current)
        return current
    FOUND.min_depth = 0

    @depthcontrol
    def FULL(self, parent=None):
        current = UnlexerRule(name='FULL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FULL', parent=current)
        self.exit_rule(current)
        return current
    FULL.min_depth = 0

    @depthcontrol
    def FUNCTION(self, parent=None):
        current = UnlexerRule(name='FUNCTION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FUNCTION', parent=current)
        self.exit_rule(current)
        return current
    FUNCTION.min_depth = 0

    @depthcontrol
    def GENERAL(self, parent=None):
        current = UnlexerRule(name='GENERAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GENERAL', parent=current)
        self.exit_rule(current)
        return current
    GENERAL.min_depth = 0

    @depthcontrol
    def GLOBAL(self, parent=None):
        current = UnlexerRule(name='GLOBAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GLOBAL', parent=current)
        self.exit_rule(current)
        return current
    GLOBAL.min_depth = 0

    @depthcontrol
    def GRANTS(self, parent=None):
        current = UnlexerRule(name='GRANTS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GRANTS', parent=current)
        self.exit_rule(current)
        return current
    GRANTS.min_depth = 0

    @depthcontrol
    def GROUP_REPLICATION(self, parent=None):
        current = UnlexerRule(name='GROUP_REPLICATION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GROUP_REPLICATION', parent=current)
        self.exit_rule(current)
        return current
    GROUP_REPLICATION.min_depth = 0

    @depthcontrol
    def HANDLER(self, parent=None):
        current = UnlexerRule(name='HANDLER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='HANDLER', parent=current)
        self.exit_rule(current)
        return current
    HANDLER.min_depth = 0

    @depthcontrol
    def HASH(self, parent=None):
        current = UnlexerRule(name='HASH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='HASH', parent=current)
        self.exit_rule(current)
        return current
    HASH.min_depth = 0

    @depthcontrol
    def HELP(self, parent=None):
        current = UnlexerRule(name='HELP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='HELP', parent=current)
        self.exit_rule(current)
        return current
    HELP.min_depth = 0

    @depthcontrol
    def HOST(self, parent=None):
        current = UnlexerRule(name='HOST', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='HOST', parent=current)
        self.exit_rule(current)
        return current
    HOST.min_depth = 0

    @depthcontrol
    def HOSTS(self, parent=None):
        current = UnlexerRule(name='HOSTS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='HOSTS', parent=current)
        self.exit_rule(current)
        return current
    HOSTS.min_depth = 0

    @depthcontrol
    def IDENTIFIED(self, parent=None):
        current = UnlexerRule(name='IDENTIFIED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IDENTIFIED', parent=current)
        self.exit_rule(current)
        return current
    IDENTIFIED.min_depth = 0

    @depthcontrol
    def IGNORE_SERVER_IDS(self, parent=None):
        current = UnlexerRule(name='IGNORE_SERVER_IDS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IGNORE_SERVER_IDS', parent=current)
        self.exit_rule(current)
        return current
    IGNORE_SERVER_IDS.min_depth = 0

    @depthcontrol
    def IMPORT(self, parent=None):
        current = UnlexerRule(name='IMPORT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IMPORT', parent=current)
        self.exit_rule(current)
        return current
    IMPORT.min_depth = 0

    @depthcontrol
    def INDEXES(self, parent=None):
        current = UnlexerRule(name='INDEXES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INDEXES', parent=current)
        self.exit_rule(current)
        return current
    INDEXES.min_depth = 0

    @depthcontrol
    def INITIAL_SIZE(self, parent=None):
        current = UnlexerRule(name='INITIAL_SIZE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INITIAL_SIZE', parent=current)
        self.exit_rule(current)
        return current
    INITIAL_SIZE.min_depth = 0

    @depthcontrol
    def INPLACE(self, parent=None):
        current = UnlexerRule(name='INPLACE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INPLACE', parent=current)
        self.exit_rule(current)
        return current
    INPLACE.min_depth = 0

    @depthcontrol
    def INSERT_METHOD(self, parent=None):
        current = UnlexerRule(name='INSERT_METHOD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INSERT_METHOD', parent=current)
        self.exit_rule(current)
        return current
    INSERT_METHOD.min_depth = 0

    @depthcontrol
    def INSTALL(self, parent=None):
        current = UnlexerRule(name='INSTALL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INSTALL', parent=current)
        self.exit_rule(current)
        return current
    INSTALL.min_depth = 0

    @depthcontrol
    def INSTANCE(self, parent=None):
        current = UnlexerRule(name='INSTANCE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INSTANCE', parent=current)
        self.exit_rule(current)
        return current
    INSTANCE.min_depth = 0

    @depthcontrol
    def INVISIBLE(self, parent=None):
        current = UnlexerRule(name='INVISIBLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INVISIBLE', parent=current)
        self.exit_rule(current)
        return current
    INVISIBLE.min_depth = 0

    @depthcontrol
    def INVOKER(self, parent=None):
        current = UnlexerRule(name='INVOKER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INVOKER', parent=current)
        self.exit_rule(current)
        return current
    INVOKER.min_depth = 0

    @depthcontrol
    def IO(self, parent=None):
        current = UnlexerRule(name='IO', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IO', parent=current)
        self.exit_rule(current)
        return current
    IO.min_depth = 0

    @depthcontrol
    def IO_THREAD(self, parent=None):
        current = UnlexerRule(name='IO_THREAD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IO_THREAD', parent=current)
        self.exit_rule(current)
        return current
    IO_THREAD.min_depth = 0

    @depthcontrol
    def IPC(self, parent=None):
        current = UnlexerRule(name='IPC', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IPC', parent=current)
        self.exit_rule(current)
        return current
    IPC.min_depth = 0

    @depthcontrol
    def ISOLATION(self, parent=None):
        current = UnlexerRule(name='ISOLATION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ISOLATION', parent=current)
        self.exit_rule(current)
        return current
    ISOLATION.min_depth = 0

    @depthcontrol
    def ISSUER(self, parent=None):
        current = UnlexerRule(name='ISSUER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ISSUER', parent=current)
        self.exit_rule(current)
        return current
    ISSUER.min_depth = 0

    @depthcontrol
    def JSON(self, parent=None):
        current = UnlexerRule(name='JSON', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JSON', parent=current)
        self.exit_rule(current)
        return current
    JSON.min_depth = 0

    @depthcontrol
    def KEY_BLOCK_SIZE(self, parent=None):
        current = UnlexerRule(name='KEY_BLOCK_SIZE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='KEY_BLOCK_SIZE', parent=current)
        self.exit_rule(current)
        return current
    KEY_BLOCK_SIZE.min_depth = 0

    @depthcontrol
    def LANGUAGE(self, parent=None):
        current = UnlexerRule(name='LANGUAGE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LANGUAGE', parent=current)
        self.exit_rule(current)
        return current
    LANGUAGE.min_depth = 0

    @depthcontrol
    def LAST(self, parent=None):
        current = UnlexerRule(name='LAST', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LAST', parent=current)
        self.exit_rule(current)
        return current
    LAST.min_depth = 0

    @depthcontrol
    def LEAVES(self, parent=None):
        current = UnlexerRule(name='LEAVES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LEAVES', parent=current)
        self.exit_rule(current)
        return current
    LEAVES.min_depth = 0

    @depthcontrol
    def LESS(self, parent=None):
        current = UnlexerRule(name='LESS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LESS', parent=current)
        self.exit_rule(current)
        return current
    LESS.min_depth = 0

    @depthcontrol
    def LEVEL(self, parent=None):
        current = UnlexerRule(name='LEVEL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LEVEL', parent=current)
        self.exit_rule(current)
        return current
    LEVEL.min_depth = 0

    @depthcontrol
    def LIST(self, parent=None):
        current = UnlexerRule(name='LIST', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LIST', parent=current)
        self.exit_rule(current)
        return current
    LIST.min_depth = 0

    @depthcontrol
    def LOCAL(self, parent=None):
        current = UnlexerRule(name='LOCAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LOCAL', parent=current)
        self.exit_rule(current)
        return current
    LOCAL.min_depth = 0

    @depthcontrol
    def LOGFILE(self, parent=None):
        current = UnlexerRule(name='LOGFILE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LOGFILE', parent=current)
        self.exit_rule(current)
        return current
    LOGFILE.min_depth = 0

    @depthcontrol
    def LOGS(self, parent=None):
        current = UnlexerRule(name='LOGS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LOGS', parent=current)
        self.exit_rule(current)
        return current
    LOGS.min_depth = 0

    @depthcontrol
    def MASTER(self, parent=None):
        current = UnlexerRule(name='MASTER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER', parent=current)
        self.exit_rule(current)
        return current
    MASTER.min_depth = 0

    @depthcontrol
    def MASTER_AUTO_POSITION(self, parent=None):
        current = UnlexerRule(name='MASTER_AUTO_POSITION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_AUTO_POSITION', parent=current)
        self.exit_rule(current)
        return current
    MASTER_AUTO_POSITION.min_depth = 0

    @depthcontrol
    def MASTER_CONNECT_RETRY(self, parent=None):
        current = UnlexerRule(name='MASTER_CONNECT_RETRY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_CONNECT_RETRY', parent=current)
        self.exit_rule(current)
        return current
    MASTER_CONNECT_RETRY.min_depth = 0

    @depthcontrol
    def MASTER_DELAY(self, parent=None):
        current = UnlexerRule(name='MASTER_DELAY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_DELAY', parent=current)
        self.exit_rule(current)
        return current
    MASTER_DELAY.min_depth = 0

    @depthcontrol
    def MASTER_HEARTBEAT_PERIOD(self, parent=None):
        current = UnlexerRule(name='MASTER_HEARTBEAT_PERIOD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_HEARTBEAT_PERIOD', parent=current)
        self.exit_rule(current)
        return current
    MASTER_HEARTBEAT_PERIOD.min_depth = 0

    @depthcontrol
    def MASTER_HOST(self, parent=None):
        current = UnlexerRule(name='MASTER_HOST', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_HOST', parent=current)
        self.exit_rule(current)
        return current
    MASTER_HOST.min_depth = 0

    @depthcontrol
    def MASTER_LOG_FILE(self, parent=None):
        current = UnlexerRule(name='MASTER_LOG_FILE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_LOG_FILE', parent=current)
        self.exit_rule(current)
        return current
    MASTER_LOG_FILE.min_depth = 0

    @depthcontrol
    def MASTER_LOG_POS(self, parent=None):
        current = UnlexerRule(name='MASTER_LOG_POS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_LOG_POS', parent=current)
        self.exit_rule(current)
        return current
    MASTER_LOG_POS.min_depth = 0

    @depthcontrol
    def MASTER_PASSWORD(self, parent=None):
        current = UnlexerRule(name='MASTER_PASSWORD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_PASSWORD', parent=current)
        self.exit_rule(current)
        return current
    MASTER_PASSWORD.min_depth = 0

    @depthcontrol
    def MASTER_PORT(self, parent=None):
        current = UnlexerRule(name='MASTER_PORT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_PORT', parent=current)
        self.exit_rule(current)
        return current
    MASTER_PORT.min_depth = 0

    @depthcontrol
    def MASTER_RETRY_COUNT(self, parent=None):
        current = UnlexerRule(name='MASTER_RETRY_COUNT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_RETRY_COUNT', parent=current)
        self.exit_rule(current)
        return current
    MASTER_RETRY_COUNT.min_depth = 0

    @depthcontrol
    def MASTER_SSL(self, parent=None):
        current = UnlexerRule(name='MASTER_SSL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_SSL', parent=current)
        self.exit_rule(current)
        return current
    MASTER_SSL.min_depth = 0

    @depthcontrol
    def MASTER_SSL_CA(self, parent=None):
        current = UnlexerRule(name='MASTER_SSL_CA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_SSL_CA', parent=current)
        self.exit_rule(current)
        return current
    MASTER_SSL_CA.min_depth = 0

    @depthcontrol
    def MASTER_SSL_CAPATH(self, parent=None):
        current = UnlexerRule(name='MASTER_SSL_CAPATH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_SSL_CAPATH', parent=current)
        self.exit_rule(current)
        return current
    MASTER_SSL_CAPATH.min_depth = 0

    @depthcontrol
    def MASTER_SSL_CERT(self, parent=None):
        current = UnlexerRule(name='MASTER_SSL_CERT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_SSL_CERT', parent=current)
        self.exit_rule(current)
        return current
    MASTER_SSL_CERT.min_depth = 0

    @depthcontrol
    def MASTER_SSL_CIPHER(self, parent=None):
        current = UnlexerRule(name='MASTER_SSL_CIPHER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_SSL_CIPHER', parent=current)
        self.exit_rule(current)
        return current
    MASTER_SSL_CIPHER.min_depth = 0

    @depthcontrol
    def MASTER_SSL_CRL(self, parent=None):
        current = UnlexerRule(name='MASTER_SSL_CRL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_SSL_CRL', parent=current)
        self.exit_rule(current)
        return current
    MASTER_SSL_CRL.min_depth = 0

    @depthcontrol
    def MASTER_SSL_CRLPATH(self, parent=None):
        current = UnlexerRule(name='MASTER_SSL_CRLPATH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_SSL_CRLPATH', parent=current)
        self.exit_rule(current)
        return current
    MASTER_SSL_CRLPATH.min_depth = 0

    @depthcontrol
    def MASTER_SSL_KEY(self, parent=None):
        current = UnlexerRule(name='MASTER_SSL_KEY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_SSL_KEY', parent=current)
        self.exit_rule(current)
        return current
    MASTER_SSL_KEY.min_depth = 0

    @depthcontrol
    def MASTER_TLS_VERSION(self, parent=None):
        current = UnlexerRule(name='MASTER_TLS_VERSION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_TLS_VERSION', parent=current)
        self.exit_rule(current)
        return current
    MASTER_TLS_VERSION.min_depth = 0

    @depthcontrol
    def MASTER_USER(self, parent=None):
        current = UnlexerRule(name='MASTER_USER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_USER', parent=current)
        self.exit_rule(current)
        return current
    MASTER_USER.min_depth = 0

    @depthcontrol
    def MAX_CONNECTIONS_PER_HOUR(self, parent=None):
        current = UnlexerRule(name='MAX_CONNECTIONS_PER_HOUR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MAX_CONNECTIONS_PER_HOUR', parent=current)
        self.exit_rule(current)
        return current
    MAX_CONNECTIONS_PER_HOUR.min_depth = 0

    @depthcontrol
    def MAX_QUERIES_PER_HOUR(self, parent=None):
        current = UnlexerRule(name='MAX_QUERIES_PER_HOUR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MAX_QUERIES_PER_HOUR', parent=current)
        self.exit_rule(current)
        return current
    MAX_QUERIES_PER_HOUR.min_depth = 0

    @depthcontrol
    def MAX_ROWS(self, parent=None):
        current = UnlexerRule(name='MAX_ROWS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MAX_ROWS', parent=current)
        self.exit_rule(current)
        return current
    MAX_ROWS.min_depth = 0

    @depthcontrol
    def MAX_SIZE(self, parent=None):
        current = UnlexerRule(name='MAX_SIZE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MAX_SIZE', parent=current)
        self.exit_rule(current)
        return current
    MAX_SIZE.min_depth = 0

    @depthcontrol
    def MAX_UPDATES_PER_HOUR(self, parent=None):
        current = UnlexerRule(name='MAX_UPDATES_PER_HOUR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MAX_UPDATES_PER_HOUR', parent=current)
        self.exit_rule(current)
        return current
    MAX_UPDATES_PER_HOUR.min_depth = 0

    @depthcontrol
    def MAX_USER_CONNECTIONS(self, parent=None):
        current = UnlexerRule(name='MAX_USER_CONNECTIONS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MAX_USER_CONNECTIONS', parent=current)
        self.exit_rule(current)
        return current
    MAX_USER_CONNECTIONS.min_depth = 0

    @depthcontrol
    def MEDIUM(self, parent=None):
        current = UnlexerRule(name='MEDIUM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MEDIUM', parent=current)
        self.exit_rule(current)
        return current
    MEDIUM.min_depth = 0

    @depthcontrol
    def MEMBER(self, parent=None):
        current = UnlexerRule(name='MEMBER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MEMBER', parent=current)
        self.exit_rule(current)
        return current
    MEMBER.min_depth = 0

    @depthcontrol
    def MERGE(self, parent=None):
        current = UnlexerRule(name='MERGE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MERGE', parent=current)
        self.exit_rule(current)
        return current
    MERGE.min_depth = 0

    @depthcontrol
    def MESSAGE_TEXT(self, parent=None):
        current = UnlexerRule(name='MESSAGE_TEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MESSAGE_TEXT', parent=current)
        self.exit_rule(current)
        return current
    MESSAGE_TEXT.min_depth = 0

    @depthcontrol
    def MID(self, parent=None):
        current = UnlexerRule(name='MID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MID', parent=current)
        self.exit_rule(current)
        return current
    MID.min_depth = 0

    @depthcontrol
    def MIGRATE(self, parent=None):
        current = UnlexerRule(name='MIGRATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MIGRATE', parent=current)
        self.exit_rule(current)
        return current
    MIGRATE.min_depth = 0

    @depthcontrol
    def MIN_ROWS(self, parent=None):
        current = UnlexerRule(name='MIN_ROWS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MIN_ROWS', parent=current)
        self.exit_rule(current)
        return current
    MIN_ROWS.min_depth = 0

    @depthcontrol
    def MODE(self, parent=None):
        current = UnlexerRule(name='MODE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MODE', parent=current)
        self.exit_rule(current)
        return current
    MODE.min_depth = 0

    @depthcontrol
    def MODIFY(self, parent=None):
        current = UnlexerRule(name='MODIFY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MODIFY', parent=current)
        self.exit_rule(current)
        return current
    MODIFY.min_depth = 0

    @depthcontrol
    def MUTEX(self, parent=None):
        current = UnlexerRule(name='MUTEX', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MUTEX', parent=current)
        self.exit_rule(current)
        return current
    MUTEX.min_depth = 0

    @depthcontrol
    def MYSQL(self, parent=None):
        current = UnlexerRule(name='MYSQL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MYSQL', parent=current)
        self.exit_rule(current)
        return current
    MYSQL.min_depth = 0

    @depthcontrol
    def MYSQL_ERRNO(self, parent=None):
        current = UnlexerRule(name='MYSQL_ERRNO', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MYSQL_ERRNO', parent=current)
        self.exit_rule(current)
        return current
    MYSQL_ERRNO.min_depth = 0

    @depthcontrol
    def NAME(self, parent=None):
        current = UnlexerRule(name='NAME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NAME', parent=current)
        self.exit_rule(current)
        return current
    NAME.min_depth = 0

    @depthcontrol
    def NAMES(self, parent=None):
        current = UnlexerRule(name='NAMES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NAMES', parent=current)
        self.exit_rule(current)
        return current
    NAMES.min_depth = 0

    @depthcontrol
    def NCHAR(self, parent=None):
        current = UnlexerRule(name='NCHAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NCHAR', parent=current)
        self.exit_rule(current)
        return current
    NCHAR.min_depth = 0

    @depthcontrol
    def NEVER(self, parent=None):
        current = UnlexerRule(name='NEVER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NEVER', parent=current)
        self.exit_rule(current)
        return current
    NEVER.min_depth = 0

    @depthcontrol
    def NEXT(self, parent=None):
        current = UnlexerRule(name='NEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NEXT', parent=current)
        self.exit_rule(current)
        return current
    NEXT.min_depth = 0

    @depthcontrol
    def NO(self, parent=None):
        current = UnlexerRule(name='NO', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NO', parent=current)
        self.exit_rule(current)
        return current
    NO.min_depth = 0

    @depthcontrol
    def NODEGROUP(self, parent=None):
        current = UnlexerRule(name='NODEGROUP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NODEGROUP', parent=current)
        self.exit_rule(current)
        return current
    NODEGROUP.min_depth = 0

    @depthcontrol
    def NONE(self, parent=None):
        current = UnlexerRule(name='NONE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NONE', parent=current)
        self.exit_rule(current)
        return current
    NONE.min_depth = 0

    @depthcontrol
    def OFFLINE(self, parent=None):
        current = UnlexerRule(name='OFFLINE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OFFLINE', parent=current)
        self.exit_rule(current)
        return current
    OFFLINE.min_depth = 0

    @depthcontrol
    def OFFSET(self, parent=None):
        current = UnlexerRule(name='OFFSET', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OFFSET', parent=current)
        self.exit_rule(current)
        return current
    OFFSET.min_depth = 0

    @depthcontrol
    def OF(self, parent=None):
        current = UnlexerRule(name='OF', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OF', parent=current)
        self.exit_rule(current)
        return current
    OF.min_depth = 0

    @depthcontrol
    def OJ(self, parent=None):
        current = UnlexerRule(name='OJ', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OJ', parent=current)
        self.exit_rule(current)
        return current
    OJ.min_depth = 0

    @depthcontrol
    def OLD_PASSWORD(self, parent=None):
        current = UnlexerRule(name='OLD_PASSWORD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OLD_PASSWORD', parent=current)
        self.exit_rule(current)
        return current
    OLD_PASSWORD.min_depth = 0

    @depthcontrol
    def ONE(self, parent=None):
        current = UnlexerRule(name='ONE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ONE', parent=current)
        self.exit_rule(current)
        return current
    ONE.min_depth = 0

    @depthcontrol
    def ONLINE(self, parent=None):
        current = UnlexerRule(name='ONLINE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ONLINE', parent=current)
        self.exit_rule(current)
        return current
    ONLINE.min_depth = 0

    @depthcontrol
    def ONLY(self, parent=None):
        current = UnlexerRule(name='ONLY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ONLY', parent=current)
        self.exit_rule(current)
        return current
    ONLY.min_depth = 0

    @depthcontrol
    def OPEN(self, parent=None):
        current = UnlexerRule(name='OPEN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OPEN', parent=current)
        self.exit_rule(current)
        return current
    OPEN.min_depth = 0

    @depthcontrol
    def OPTIMIZER_COSTS(self, parent=None):
        current = UnlexerRule(name='OPTIMIZER_COSTS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OPTIMIZER_COSTS', parent=current)
        self.exit_rule(current)
        return current
    OPTIMIZER_COSTS.min_depth = 0

    @depthcontrol
    def OPTIONS(self, parent=None):
        current = UnlexerRule(name='OPTIONS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OPTIONS', parent=current)
        self.exit_rule(current)
        return current
    OPTIONS.min_depth = 0

    @depthcontrol
    def OWNER(self, parent=None):
        current = UnlexerRule(name='OWNER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OWNER', parent=current)
        self.exit_rule(current)
        return current
    OWNER.min_depth = 0

    @depthcontrol
    def PACK_KEYS(self, parent=None):
        current = UnlexerRule(name='PACK_KEYS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PACK_KEYS', parent=current)
        self.exit_rule(current)
        return current
    PACK_KEYS.min_depth = 0

    @depthcontrol
    def PAGE(self, parent=None):
        current = UnlexerRule(name='PAGE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PAGE', parent=current)
        self.exit_rule(current)
        return current
    PAGE.min_depth = 0

    @depthcontrol
    def PARSER(self, parent=None):
        current = UnlexerRule(name='PARSER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PARSER', parent=current)
        self.exit_rule(current)
        return current
    PARSER.min_depth = 0

    @depthcontrol
    def PARTIAL(self, parent=None):
        current = UnlexerRule(name='PARTIAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PARTIAL', parent=current)
        self.exit_rule(current)
        return current
    PARTIAL.min_depth = 0

    @depthcontrol
    def PARTITIONING(self, parent=None):
        current = UnlexerRule(name='PARTITIONING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PARTITIONING', parent=current)
        self.exit_rule(current)
        return current
    PARTITIONING.min_depth = 0

    @depthcontrol
    def PARTITIONS(self, parent=None):
        current = UnlexerRule(name='PARTITIONS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PARTITIONS', parent=current)
        self.exit_rule(current)
        return current
    PARTITIONS.min_depth = 0

    @depthcontrol
    def PASSWORD(self, parent=None):
        current = UnlexerRule(name='PASSWORD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PASSWORD', parent=current)
        self.exit_rule(current)
        return current
    PASSWORD.min_depth = 0

    @depthcontrol
    def PHASE(self, parent=None):
        current = UnlexerRule(name='PHASE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PHASE', parent=current)
        self.exit_rule(current)
        return current
    PHASE.min_depth = 0

    @depthcontrol
    def PLUGIN(self, parent=None):
        current = UnlexerRule(name='PLUGIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PLUGIN', parent=current)
        self.exit_rule(current)
        return current
    PLUGIN.min_depth = 0

    @depthcontrol
    def PLUGIN_DIR(self, parent=None):
        current = UnlexerRule(name='PLUGIN_DIR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PLUGIN_DIR', parent=current)
        self.exit_rule(current)
        return current
    PLUGIN_DIR.min_depth = 0

    @depthcontrol
    def PLUGINS(self, parent=None):
        current = UnlexerRule(name='PLUGINS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PLUGINS', parent=current)
        self.exit_rule(current)
        return current
    PLUGINS.min_depth = 0

    @depthcontrol
    def PORT(self, parent=None):
        current = UnlexerRule(name='PORT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PORT', parent=current)
        self.exit_rule(current)
        return current
    PORT.min_depth = 0

    @depthcontrol
    def PRECEDES(self, parent=None):
        current = UnlexerRule(name='PRECEDES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PRECEDES', parent=current)
        self.exit_rule(current)
        return current
    PRECEDES.min_depth = 0

    @depthcontrol
    def PREPARE(self, parent=None):
        current = UnlexerRule(name='PREPARE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PREPARE', parent=current)
        self.exit_rule(current)
        return current
    PREPARE.min_depth = 0

    @depthcontrol
    def PRESERVE(self, parent=None):
        current = UnlexerRule(name='PRESERVE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PRESERVE', parent=current)
        self.exit_rule(current)
        return current
    PRESERVE.min_depth = 0

    @depthcontrol
    def PREV(self, parent=None):
        current = UnlexerRule(name='PREV', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PREV', parent=current)
        self.exit_rule(current)
        return current
    PREV.min_depth = 0

    @depthcontrol
    def PROCESSLIST(self, parent=None):
        current = UnlexerRule(name='PROCESSLIST', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PROCESSLIST', parent=current)
        self.exit_rule(current)
        return current
    PROCESSLIST.min_depth = 0

    @depthcontrol
    def PROFILE(self, parent=None):
        current = UnlexerRule(name='PROFILE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PROFILE', parent=current)
        self.exit_rule(current)
        return current
    PROFILE.min_depth = 0

    @depthcontrol
    def PROFILES(self, parent=None):
        current = UnlexerRule(name='PROFILES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PROFILES', parent=current)
        self.exit_rule(current)
        return current
    PROFILES.min_depth = 0

    @depthcontrol
    def PROXY(self, parent=None):
        current = UnlexerRule(name='PROXY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PROXY', parent=current)
        self.exit_rule(current)
        return current
    PROXY.min_depth = 0

    @depthcontrol
    def QUERY(self, parent=None):
        current = UnlexerRule(name='QUERY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='QUERY', parent=current)
        self.exit_rule(current)
        return current
    QUERY.min_depth = 0

    @depthcontrol
    def QUICK(self, parent=None):
        current = UnlexerRule(name='QUICK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='QUICK', parent=current)
        self.exit_rule(current)
        return current
    QUICK.min_depth = 0

    @depthcontrol
    def REBUILD(self, parent=None):
        current = UnlexerRule(name='REBUILD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REBUILD', parent=current)
        self.exit_rule(current)
        return current
    REBUILD.min_depth = 0

    @depthcontrol
    def RECOVER(self, parent=None):
        current = UnlexerRule(name='RECOVER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RECOVER', parent=current)
        self.exit_rule(current)
        return current
    RECOVER.min_depth = 0

    @depthcontrol
    def REDO_BUFFER_SIZE(self, parent=None):
        current = UnlexerRule(name='REDO_BUFFER_SIZE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REDO_BUFFER_SIZE', parent=current)
        self.exit_rule(current)
        return current
    REDO_BUFFER_SIZE.min_depth = 0

    @depthcontrol
    def REDUNDANT(self, parent=None):
        current = UnlexerRule(name='REDUNDANT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REDUNDANT', parent=current)
        self.exit_rule(current)
        return current
    REDUNDANT.min_depth = 0

    @depthcontrol
    def RELAY(self, parent=None):
        current = UnlexerRule(name='RELAY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RELAY', parent=current)
        self.exit_rule(current)
        return current
    RELAY.min_depth = 0

    @depthcontrol
    def RELAY_LOG_FILE(self, parent=None):
        current = UnlexerRule(name='RELAY_LOG_FILE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RELAY_LOG_FILE', parent=current)
        self.exit_rule(current)
        return current
    RELAY_LOG_FILE.min_depth = 0

    @depthcontrol
    def RELAY_LOG_POS(self, parent=None):
        current = UnlexerRule(name='RELAY_LOG_POS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RELAY_LOG_POS', parent=current)
        self.exit_rule(current)
        return current
    RELAY_LOG_POS.min_depth = 0

    @depthcontrol
    def RELAYLOG(self, parent=None):
        current = UnlexerRule(name='RELAYLOG', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RELAYLOG', parent=current)
        self.exit_rule(current)
        return current
    RELAYLOG.min_depth = 0

    @depthcontrol
    def REMOVE(self, parent=None):
        current = UnlexerRule(name='REMOVE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REMOVE', parent=current)
        self.exit_rule(current)
        return current
    REMOVE.min_depth = 0

    @depthcontrol
    def REORGANIZE(self, parent=None):
        current = UnlexerRule(name='REORGANIZE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REORGANIZE', parent=current)
        self.exit_rule(current)
        return current
    REORGANIZE.min_depth = 0

    @depthcontrol
    def REPAIR(self, parent=None):
        current = UnlexerRule(name='REPAIR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REPAIR', parent=current)
        self.exit_rule(current)
        return current
    REPAIR.min_depth = 0

    @depthcontrol
    def REPLICATE_DO_DB(self, parent=None):
        current = UnlexerRule(name='REPLICATE_DO_DB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REPLICATE_DO_DB', parent=current)
        self.exit_rule(current)
        return current
    REPLICATE_DO_DB.min_depth = 0

    @depthcontrol
    def REPLICATE_DO_TABLE(self, parent=None):
        current = UnlexerRule(name='REPLICATE_DO_TABLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REPLICATE_DO_TABLE', parent=current)
        self.exit_rule(current)
        return current
    REPLICATE_DO_TABLE.min_depth = 0

    @depthcontrol
    def REPLICATE_IGNORE_DB(self, parent=None):
        current = UnlexerRule(name='REPLICATE_IGNORE_DB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REPLICATE_IGNORE_DB', parent=current)
        self.exit_rule(current)
        return current
    REPLICATE_IGNORE_DB.min_depth = 0

    @depthcontrol
    def REPLICATE_IGNORE_TABLE(self, parent=None):
        current = UnlexerRule(name='REPLICATE_IGNORE_TABLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REPLICATE_IGNORE_TABLE', parent=current)
        self.exit_rule(current)
        return current
    REPLICATE_IGNORE_TABLE.min_depth = 0

    @depthcontrol
    def REPLICATE_REWRITE_DB(self, parent=None):
        current = UnlexerRule(name='REPLICATE_REWRITE_DB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REPLICATE_REWRITE_DB', parent=current)
        self.exit_rule(current)
        return current
    REPLICATE_REWRITE_DB.min_depth = 0

    @depthcontrol
    def REPLICATE_WILD_DO_TABLE(self, parent=None):
        current = UnlexerRule(name='REPLICATE_WILD_DO_TABLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REPLICATE_WILD_DO_TABLE', parent=current)
        self.exit_rule(current)
        return current
    REPLICATE_WILD_DO_TABLE.min_depth = 0

    @depthcontrol
    def REPLICATE_WILD_IGNORE_TABLE(self, parent=None):
        current = UnlexerRule(name='REPLICATE_WILD_IGNORE_TABLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REPLICATE_WILD_IGNORE_TABLE', parent=current)
        self.exit_rule(current)
        return current
    REPLICATE_WILD_IGNORE_TABLE.min_depth = 0

    @depthcontrol
    def REPLICATION(self, parent=None):
        current = UnlexerRule(name='REPLICATION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REPLICATION', parent=current)
        self.exit_rule(current)
        return current
    REPLICATION.min_depth = 0

    @depthcontrol
    def RESET(self, parent=None):
        current = UnlexerRule(name='RESET', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RESET', parent=current)
        self.exit_rule(current)
        return current
    RESET.min_depth = 0

    @depthcontrol
    def RESUME(self, parent=None):
        current = UnlexerRule(name='RESUME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RESUME', parent=current)
        self.exit_rule(current)
        return current
    RESUME.min_depth = 0

    @depthcontrol
    def RETURNED_SQLSTATE(self, parent=None):
        current = UnlexerRule(name='RETURNED_SQLSTATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RETURNED_SQLSTATE', parent=current)
        self.exit_rule(current)
        return current
    RETURNED_SQLSTATE.min_depth = 0

    @depthcontrol
    def RETURNING(self, parent=None):
        current = UnlexerRule(name='RETURNING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RETURNING', parent=current)
        self.exit_rule(current)
        return current
    RETURNING.min_depth = 0

    @depthcontrol
    def RETURNS(self, parent=None):
        current = UnlexerRule(name='RETURNS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RETURNS', parent=current)
        self.exit_rule(current)
        return current
    RETURNS.min_depth = 0

    @depthcontrol
    def ROLE(self, parent=None):
        current = UnlexerRule(name='ROLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ROLE', parent=current)
        self.exit_rule(current)
        return current
    ROLE.min_depth = 0

    @depthcontrol
    def ROLLBACK(self, parent=None):
        current = UnlexerRule(name='ROLLBACK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ROLLBACK', parent=current)
        self.exit_rule(current)
        return current
    ROLLBACK.min_depth = 0

    @depthcontrol
    def ROLLUP(self, parent=None):
        current = UnlexerRule(name='ROLLUP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ROLLUP', parent=current)
        self.exit_rule(current)
        return current
    ROLLUP.min_depth = 0

    @depthcontrol
    def ROTATE(self, parent=None):
        current = UnlexerRule(name='ROTATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ROTATE', parent=current)
        self.exit_rule(current)
        return current
    ROTATE.min_depth = 0

    @depthcontrol
    def ROW(self, parent=None):
        current = UnlexerRule(name='ROW', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ROW', parent=current)
        self.exit_rule(current)
        return current
    ROW.min_depth = 0

    @depthcontrol
    def ROWS(self, parent=None):
        current = UnlexerRule(name='ROWS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ROWS', parent=current)
        self.exit_rule(current)
        return current
    ROWS.min_depth = 0

    @depthcontrol
    def ROW_FORMAT(self, parent=None):
        current = UnlexerRule(name='ROW_FORMAT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ROW_FORMAT', parent=current)
        self.exit_rule(current)
        return current
    ROW_FORMAT.min_depth = 0

    @depthcontrol
    def SAVEPOINT(self, parent=None):
        current = UnlexerRule(name='SAVEPOINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SAVEPOINT', parent=current)
        self.exit_rule(current)
        return current
    SAVEPOINT.min_depth = 0

    @depthcontrol
    def SCHEDULE(self, parent=None):
        current = UnlexerRule(name='SCHEDULE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SCHEDULE', parent=current)
        self.exit_rule(current)
        return current
    SCHEDULE.min_depth = 0

    @depthcontrol
    def SECURITY(self, parent=None):
        current = UnlexerRule(name='SECURITY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SECURITY', parent=current)
        self.exit_rule(current)
        return current
    SECURITY.min_depth = 0

    @depthcontrol
    def SERVER(self, parent=None):
        current = UnlexerRule(name='SERVER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SERVER', parent=current)
        self.exit_rule(current)
        return current
    SERVER.min_depth = 0

    @depthcontrol
    def SESSION(self, parent=None):
        current = UnlexerRule(name='SESSION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SESSION', parent=current)
        self.exit_rule(current)
        return current
    SESSION.min_depth = 0

    @depthcontrol
    def SHARE(self, parent=None):
        current = UnlexerRule(name='SHARE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SHARE', parent=current)
        self.exit_rule(current)
        return current
    SHARE.min_depth = 0

    @depthcontrol
    def SHARED(self, parent=None):
        current = UnlexerRule(name='SHARED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SHARED', parent=current)
        self.exit_rule(current)
        return current
    SHARED.min_depth = 0

    @depthcontrol
    def SIGNED(self, parent=None):
        current = UnlexerRule(name='SIGNED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SIGNED', parent=current)
        self.exit_rule(current)
        return current
    SIGNED.min_depth = 0

    @depthcontrol
    def SIMPLE(self, parent=None):
        current = UnlexerRule(name='SIMPLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SIMPLE', parent=current)
        self.exit_rule(current)
        return current
    SIMPLE.min_depth = 0

    @depthcontrol
    def SLAVE(self, parent=None):
        current = UnlexerRule(name='SLAVE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SLAVE', parent=current)
        self.exit_rule(current)
        return current
    SLAVE.min_depth = 0

    @depthcontrol
    def SLOW(self, parent=None):
        current = UnlexerRule(name='SLOW', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SLOW', parent=current)
        self.exit_rule(current)
        return current
    SLOW.min_depth = 0

    @depthcontrol
    def SNAPSHOT(self, parent=None):
        current = UnlexerRule(name='SNAPSHOT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SNAPSHOT', parent=current)
        self.exit_rule(current)
        return current
    SNAPSHOT.min_depth = 0

    @depthcontrol
    def SOCKET(self, parent=None):
        current = UnlexerRule(name='SOCKET', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SOCKET', parent=current)
        self.exit_rule(current)
        return current
    SOCKET.min_depth = 0

    @depthcontrol
    def SOME(self, parent=None):
        current = UnlexerRule(name='SOME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SOME', parent=current)
        self.exit_rule(current)
        return current
    SOME.min_depth = 0

    @depthcontrol
    def SONAME(self, parent=None):
        current = UnlexerRule(name='SONAME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SONAME', parent=current)
        self.exit_rule(current)
        return current
    SONAME.min_depth = 0

    @depthcontrol
    def SOUNDS(self, parent=None):
        current = UnlexerRule(name='SOUNDS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SOUNDS', parent=current)
        self.exit_rule(current)
        return current
    SOUNDS.min_depth = 0

    @depthcontrol
    def SOURCE(self, parent=None):
        current = UnlexerRule(name='SOURCE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SOURCE', parent=current)
        self.exit_rule(current)
        return current
    SOURCE.min_depth = 0

    @depthcontrol
    def SQL_AFTER_GTIDS(self, parent=None):
        current = UnlexerRule(name='SQL_AFTER_GTIDS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQL_AFTER_GTIDS', parent=current)
        self.exit_rule(current)
        return current
    SQL_AFTER_GTIDS.min_depth = 0

    @depthcontrol
    def SQL_AFTER_MTS_GAPS(self, parent=None):
        current = UnlexerRule(name='SQL_AFTER_MTS_GAPS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQL_AFTER_MTS_GAPS', parent=current)
        self.exit_rule(current)
        return current
    SQL_AFTER_MTS_GAPS.min_depth = 0

    @depthcontrol
    def SQL_BEFORE_GTIDS(self, parent=None):
        current = UnlexerRule(name='SQL_BEFORE_GTIDS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQL_BEFORE_GTIDS', parent=current)
        self.exit_rule(current)
        return current
    SQL_BEFORE_GTIDS.min_depth = 0

    @depthcontrol
    def SQL_BUFFER_RESULT(self, parent=None):
        current = UnlexerRule(name='SQL_BUFFER_RESULT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQL_BUFFER_RESULT', parent=current)
        self.exit_rule(current)
        return current
    SQL_BUFFER_RESULT.min_depth = 0

    @depthcontrol
    def SQL_CACHE(self, parent=None):
        current = UnlexerRule(name='SQL_CACHE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQL_CACHE', parent=current)
        self.exit_rule(current)
        return current
    SQL_CACHE.min_depth = 0

    @depthcontrol
    def SQL_NO_CACHE(self, parent=None):
        current = UnlexerRule(name='SQL_NO_CACHE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQL_NO_CACHE', parent=current)
        self.exit_rule(current)
        return current
    SQL_NO_CACHE.min_depth = 0

    @depthcontrol
    def SQL_THREAD(self, parent=None):
        current = UnlexerRule(name='SQL_THREAD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQL_THREAD', parent=current)
        self.exit_rule(current)
        return current
    SQL_THREAD.min_depth = 0

    @depthcontrol
    def START(self, parent=None):
        current = UnlexerRule(name='START', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='START', parent=current)
        self.exit_rule(current)
        return current
    START.min_depth = 0

    @depthcontrol
    def STARTS(self, parent=None):
        current = UnlexerRule(name='STARTS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STARTS', parent=current)
        self.exit_rule(current)
        return current
    STARTS.min_depth = 0

    @depthcontrol
    def STATS_AUTO_RECALC(self, parent=None):
        current = UnlexerRule(name='STATS_AUTO_RECALC', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STATS_AUTO_RECALC', parent=current)
        self.exit_rule(current)
        return current
    STATS_AUTO_RECALC.min_depth = 0

    @depthcontrol
    def STATS_PERSISTENT(self, parent=None):
        current = UnlexerRule(name='STATS_PERSISTENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STATS_PERSISTENT', parent=current)
        self.exit_rule(current)
        return current
    STATS_PERSISTENT.min_depth = 0

    @depthcontrol
    def STATS_SAMPLE_PAGES(self, parent=None):
        current = UnlexerRule(name='STATS_SAMPLE_PAGES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STATS_SAMPLE_PAGES', parent=current)
        self.exit_rule(current)
        return current
    STATS_SAMPLE_PAGES.min_depth = 0

    @depthcontrol
    def STATUS(self, parent=None):
        current = UnlexerRule(name='STATUS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STATUS', parent=current)
        self.exit_rule(current)
        return current
    STATUS.min_depth = 0

    @depthcontrol
    def STOP(self, parent=None):
        current = UnlexerRule(name='STOP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STOP', parent=current)
        self.exit_rule(current)
        return current
    STOP.min_depth = 0

    @depthcontrol
    def STORAGE(self, parent=None):
        current = UnlexerRule(name='STORAGE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STORAGE', parent=current)
        self.exit_rule(current)
        return current
    STORAGE.min_depth = 0

    @depthcontrol
    def STORED(self, parent=None):
        current = UnlexerRule(name='STORED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STORED', parent=current)
        self.exit_rule(current)
        return current
    STORED.min_depth = 0

    @depthcontrol
    def STRING(self, parent=None):
        current = UnlexerRule(name='STRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STRING', parent=current)
        self.exit_rule(current)
        return current
    STRING.min_depth = 0

    @depthcontrol
    def SUBCLASS_ORIGIN(self, parent=None):
        current = UnlexerRule(name='SUBCLASS_ORIGIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SUBCLASS_ORIGIN', parent=current)
        self.exit_rule(current)
        return current
    SUBCLASS_ORIGIN.min_depth = 0

    @depthcontrol
    def SUBJECT(self, parent=None):
        current = UnlexerRule(name='SUBJECT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SUBJECT', parent=current)
        self.exit_rule(current)
        return current
    SUBJECT.min_depth = 0

    @depthcontrol
    def SUBPARTITION(self, parent=None):
        current = UnlexerRule(name='SUBPARTITION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SUBPARTITION', parent=current)
        self.exit_rule(current)
        return current
    SUBPARTITION.min_depth = 0

    @depthcontrol
    def SUBPARTITIONS(self, parent=None):
        current = UnlexerRule(name='SUBPARTITIONS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SUBPARTITIONS', parent=current)
        self.exit_rule(current)
        return current
    SUBPARTITIONS.min_depth = 0

    @depthcontrol
    def SUSPEND(self, parent=None):
        current = UnlexerRule(name='SUSPEND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SUSPEND', parent=current)
        self.exit_rule(current)
        return current
    SUSPEND.min_depth = 0

    @depthcontrol
    def SWAPS(self, parent=None):
        current = UnlexerRule(name='SWAPS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SWAPS', parent=current)
        self.exit_rule(current)
        return current
    SWAPS.min_depth = 0

    @depthcontrol
    def SWITCHES(self, parent=None):
        current = UnlexerRule(name='SWITCHES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SWITCHES', parent=current)
        self.exit_rule(current)
        return current
    SWITCHES.min_depth = 0

    @depthcontrol
    def TABLE_NAME(self, parent=None):
        current = UnlexerRule(name='TABLE_NAME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TABLE_NAME', parent=current)
        self.exit_rule(current)
        return current
    TABLE_NAME.min_depth = 0

    @depthcontrol
    def TABLESPACE(self, parent=None):
        current = UnlexerRule(name='TABLESPACE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TABLESPACE', parent=current)
        self.exit_rule(current)
        return current
    TABLESPACE.min_depth = 0

    @depthcontrol
    def TEMPORARY(self, parent=None):
        current = UnlexerRule(name='TEMPORARY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TEMPORARY', parent=current)
        self.exit_rule(current)
        return current
    TEMPORARY.min_depth = 0

    @depthcontrol
    def TEMPTABLE(self, parent=None):
        current = UnlexerRule(name='TEMPTABLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TEMPTABLE', parent=current)
        self.exit_rule(current)
        return current
    TEMPTABLE.min_depth = 0

    @depthcontrol
    def THAN(self, parent=None):
        current = UnlexerRule(name='THAN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='THAN', parent=current)
        self.exit_rule(current)
        return current
    THAN.min_depth = 0

    @depthcontrol
    def TRADITIONAL(self, parent=None):
        current = UnlexerRule(name='TRADITIONAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TRADITIONAL', parent=current)
        self.exit_rule(current)
        return current
    TRADITIONAL.min_depth = 0

    @depthcontrol
    def TRANSACTION(self, parent=None):
        current = UnlexerRule(name='TRANSACTION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TRANSACTION', parent=current)
        self.exit_rule(current)
        return current
    TRANSACTION.min_depth = 0

    @depthcontrol
    def TRANSACTIONAL(self, parent=None):
        current = UnlexerRule(name='TRANSACTIONAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TRANSACTIONAL', parent=current)
        self.exit_rule(current)
        return current
    TRANSACTIONAL.min_depth = 0

    @depthcontrol
    def TRIGGERS(self, parent=None):
        current = UnlexerRule(name='TRIGGERS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TRIGGERS', parent=current)
        self.exit_rule(current)
        return current
    TRIGGERS.min_depth = 0

    @depthcontrol
    def TRUNCATE(self, parent=None):
        current = UnlexerRule(name='TRUNCATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TRUNCATE', parent=current)
        self.exit_rule(current)
        return current
    TRUNCATE.min_depth = 0

    @depthcontrol
    def UNDEFINED(self, parent=None):
        current = UnlexerRule(name='UNDEFINED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNDEFINED', parent=current)
        self.exit_rule(current)
        return current
    UNDEFINED.min_depth = 0

    @depthcontrol
    def UNDOFILE(self, parent=None):
        current = UnlexerRule(name='UNDOFILE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNDOFILE', parent=current)
        self.exit_rule(current)
        return current
    UNDOFILE.min_depth = 0

    @depthcontrol
    def UNDO_BUFFER_SIZE(self, parent=None):
        current = UnlexerRule(name='UNDO_BUFFER_SIZE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNDO_BUFFER_SIZE', parent=current)
        self.exit_rule(current)
        return current
    UNDO_BUFFER_SIZE.min_depth = 0

    @depthcontrol
    def UNINSTALL(self, parent=None):
        current = UnlexerRule(name='UNINSTALL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNINSTALL', parent=current)
        self.exit_rule(current)
        return current
    UNINSTALL.min_depth = 0

    @depthcontrol
    def UNKNOWN(self, parent=None):
        current = UnlexerRule(name='UNKNOWN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNKNOWN', parent=current)
        self.exit_rule(current)
        return current
    UNKNOWN.min_depth = 0

    @depthcontrol
    def UNTIL(self, parent=None):
        current = UnlexerRule(name='UNTIL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNTIL', parent=current)
        self.exit_rule(current)
        return current
    UNTIL.min_depth = 0

    @depthcontrol
    def UPGRADE(self, parent=None):
        current = UnlexerRule(name='UPGRADE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UPGRADE', parent=current)
        self.exit_rule(current)
        return current
    UPGRADE.min_depth = 0

    @depthcontrol
    def USER(self, parent=None):
        current = UnlexerRule(name='USER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='USER', parent=current)
        self.exit_rule(current)
        return current
    USER.min_depth = 0

    @depthcontrol
    def USE_FRM(self, parent=None):
        current = UnlexerRule(name='USE_FRM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='USE_FRM', parent=current)
        self.exit_rule(current)
        return current
    USE_FRM.min_depth = 0

    @depthcontrol
    def USER_RESOURCES(self, parent=None):
        current = UnlexerRule(name='USER_RESOURCES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='USER_RESOURCES', parent=current)
        self.exit_rule(current)
        return current
    USER_RESOURCES.min_depth = 0

    @depthcontrol
    def VALIDATION(self, parent=None):
        current = UnlexerRule(name='VALIDATION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VALIDATION', parent=current)
        self.exit_rule(current)
        return current
    VALIDATION.min_depth = 0

    @depthcontrol
    def VALUE(self, parent=None):
        current = UnlexerRule(name='VALUE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VALUE', parent=current)
        self.exit_rule(current)
        return current
    VALUE.min_depth = 0

    @depthcontrol
    def VARIABLES(self, parent=None):
        current = UnlexerRule(name='VARIABLES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VARIABLES', parent=current)
        self.exit_rule(current)
        return current
    VARIABLES.min_depth = 0

    @depthcontrol
    def VIEW(self, parent=None):
        current = UnlexerRule(name='VIEW', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VIEW', parent=current)
        self.exit_rule(current)
        return current
    VIEW.min_depth = 0

    @depthcontrol
    def VIRTUAL(self, parent=None):
        current = UnlexerRule(name='VIRTUAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VIRTUAL', parent=current)
        self.exit_rule(current)
        return current
    VIRTUAL.min_depth = 0

    @depthcontrol
    def VISIBLE(self, parent=None):
        current = UnlexerRule(name='VISIBLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VISIBLE', parent=current)
        self.exit_rule(current)
        return current
    VISIBLE.min_depth = 0

    @depthcontrol
    def WAIT(self, parent=None):
        current = UnlexerRule(name='WAIT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WAIT', parent=current)
        self.exit_rule(current)
        return current
    WAIT.min_depth = 0

    @depthcontrol
    def WARNINGS(self, parent=None):
        current = UnlexerRule(name='WARNINGS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WARNINGS', parent=current)
        self.exit_rule(current)
        return current
    WARNINGS.min_depth = 0

    @depthcontrol
    def WITHOUT(self, parent=None):
        current = UnlexerRule(name='WITHOUT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WITHOUT', parent=current)
        self.exit_rule(current)
        return current
    WITHOUT.min_depth = 0

    @depthcontrol
    def WORK(self, parent=None):
        current = UnlexerRule(name='WORK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WORK', parent=current)
        self.exit_rule(current)
        return current
    WORK.min_depth = 0

    @depthcontrol
    def WRAPPER(self, parent=None):
        current = UnlexerRule(name='WRAPPER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WRAPPER', parent=current)
        self.exit_rule(current)
        return current
    WRAPPER.min_depth = 0

    @depthcontrol
    def X509(self, parent=None):
        current = UnlexerRule(name='X509', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='X509', parent=current)
        self.exit_rule(current)
        return current
    X509.min_depth = 0

    @depthcontrol
    def XA(self, parent=None):
        current = UnlexerRule(name='XA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='XA', parent=current)
        self.exit_rule(current)
        return current
    XA.min_depth = 0

    @depthcontrol
    def XML(self, parent=None):
        current = UnlexerRule(name='XML', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='XML', parent=current)
        self.exit_rule(current)
        return current
    XML.min_depth = 0

    @depthcontrol
    def EUR(self, parent=None):
        current = UnlexerRule(name='EUR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EUR', parent=current)
        self.exit_rule(current)
        return current
    EUR.min_depth = 0

    @depthcontrol
    def USA(self, parent=None):
        current = UnlexerRule(name='USA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='USA', parent=current)
        self.exit_rule(current)
        return current
    USA.min_depth = 0

    @depthcontrol
    def JIS(self, parent=None):
        current = UnlexerRule(name='JIS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='JIS', parent=current)
        self.exit_rule(current)
        return current
    JIS.min_depth = 0

    @depthcontrol
    def ISO(self, parent=None):
        current = UnlexerRule(name='ISO', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ISO', parent=current)
        self.exit_rule(current)
        return current
    ISO.min_depth = 0

    @depthcontrol
    def INTERNAL(self, parent=None):
        current = UnlexerRule(name='INTERNAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INTERNAL', parent=current)
        self.exit_rule(current)
        return current
    INTERNAL.min_depth = 0

    @depthcontrol
    def QUARTER(self, parent=None):
        current = UnlexerRule(name='QUARTER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='QUARTER', parent=current)
        self.exit_rule(current)
        return current
    QUARTER.min_depth = 0

    @depthcontrol
    def MONTH(self, parent=None):
        current = UnlexerRule(name='MONTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MONTH', parent=current)
        self.exit_rule(current)
        return current
    MONTH.min_depth = 0

    @depthcontrol
    def DAY(self, parent=None):
        current = UnlexerRule(name='DAY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DAY', parent=current)
        self.exit_rule(current)
        return current
    DAY.min_depth = 0

    @depthcontrol
    def HOUR(self, parent=None):
        current = UnlexerRule(name='HOUR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='HOUR', parent=current)
        self.exit_rule(current)
        return current
    HOUR.min_depth = 0

    @depthcontrol
    def MINUTE(self, parent=None):
        current = UnlexerRule(name='MINUTE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MINUTE', parent=current)
        self.exit_rule(current)
        return current
    MINUTE.min_depth = 0

    @depthcontrol
    def WEEK(self, parent=None):
        current = UnlexerRule(name='WEEK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WEEK', parent=current)
        self.exit_rule(current)
        return current
    WEEK.min_depth = 0

    @depthcontrol
    def SECOND(self, parent=None):
        current = UnlexerRule(name='SECOND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SECOND', parent=current)
        self.exit_rule(current)
        return current
    SECOND.min_depth = 0

    @depthcontrol
    def MICROSECOND(self, parent=None):
        current = UnlexerRule(name='MICROSECOND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MICROSECOND', parent=current)
        self.exit_rule(current)
        return current
    MICROSECOND.min_depth = 0

    @depthcontrol
    def TABLES(self, parent=None):
        current = UnlexerRule(name='TABLES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TABLES', parent=current)
        self.exit_rule(current)
        return current
    TABLES.min_depth = 0

    @depthcontrol
    def ROUTINE(self, parent=None):
        current = UnlexerRule(name='ROUTINE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ROUTINE', parent=current)
        self.exit_rule(current)
        return current
    ROUTINE.min_depth = 0

    @depthcontrol
    def EXECUTE(self, parent=None):
        current = UnlexerRule(name='EXECUTE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EXECUTE', parent=current)
        self.exit_rule(current)
        return current
    EXECUTE.min_depth = 0

    @depthcontrol
    def FILE(self, parent=None):
        current = UnlexerRule(name='FILE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FILE', parent=current)
        self.exit_rule(current)
        return current
    FILE.min_depth = 0

    @depthcontrol
    def PROCESS(self, parent=None):
        current = UnlexerRule(name='PROCESS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PROCESS', parent=current)
        self.exit_rule(current)
        return current
    PROCESS.min_depth = 0

    @depthcontrol
    def RELOAD(self, parent=None):
        current = UnlexerRule(name='RELOAD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RELOAD', parent=current)
        self.exit_rule(current)
        return current
    RELOAD.min_depth = 0

    @depthcontrol
    def SHUTDOWN(self, parent=None):
        current = UnlexerRule(name='SHUTDOWN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SHUTDOWN', parent=current)
        self.exit_rule(current)
        return current
    SHUTDOWN.min_depth = 0

    @depthcontrol
    def SUPER(self, parent=None):
        current = UnlexerRule(name='SUPER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SUPER', parent=current)
        self.exit_rule(current)
        return current
    SUPER.min_depth = 0

    @depthcontrol
    def PRIVILEGES(self, parent=None):
        current = UnlexerRule(name='PRIVILEGES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PRIVILEGES', parent=current)
        self.exit_rule(current)
        return current
    PRIVILEGES.min_depth = 0

    @depthcontrol
    def APPLICATION_PASSWORD_ADMIN(self, parent=None):
        current = UnlexerRule(name='APPLICATION_PASSWORD_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='APPLICATION_PASSWORD_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    APPLICATION_PASSWORD_ADMIN.min_depth = 0

    @depthcontrol
    def AUDIT_ADMIN(self, parent=None):
        current = UnlexerRule(name='AUDIT_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='AUDIT_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    AUDIT_ADMIN.min_depth = 0

    @depthcontrol
    def BACKUP_ADMIN(self, parent=None):
        current = UnlexerRule(name='BACKUP_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BACKUP_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    BACKUP_ADMIN.min_depth = 0

    @depthcontrol
    def BINLOG_ADMIN(self, parent=None):
        current = UnlexerRule(name='BINLOG_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BINLOG_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    BINLOG_ADMIN.min_depth = 0

    @depthcontrol
    def BINLOG_ENCRYPTION_ADMIN(self, parent=None):
        current = UnlexerRule(name='BINLOG_ENCRYPTION_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BINLOG_ENCRYPTION_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    BINLOG_ENCRYPTION_ADMIN.min_depth = 0

    @depthcontrol
    def CLONE_ADMIN(self, parent=None):
        current = UnlexerRule(name='CLONE_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CLONE_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    CLONE_ADMIN.min_depth = 0

    @depthcontrol
    def CONNECTION_ADMIN(self, parent=None):
        current = UnlexerRule(name='CONNECTION_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONNECTION_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    CONNECTION_ADMIN.min_depth = 0

    @depthcontrol
    def ENCRYPTION_KEY_ADMIN(self, parent=None):
        current = UnlexerRule(name='ENCRYPTION_KEY_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ENCRYPTION_KEY_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    ENCRYPTION_KEY_ADMIN.min_depth = 0

    @depthcontrol
    def FIREWALL_ADMIN(self, parent=None):
        current = UnlexerRule(name='FIREWALL_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FIREWALL_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    FIREWALL_ADMIN.min_depth = 0

    @depthcontrol
    def FIREWALL_USER(self, parent=None):
        current = UnlexerRule(name='FIREWALL_USER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FIREWALL_USER', parent=current)
        self.exit_rule(current)
        return current
    FIREWALL_USER.min_depth = 0

    @depthcontrol
    def FLUSH_OPTIMIZER_COSTS(self, parent=None):
        current = UnlexerRule(name='FLUSH_OPTIMIZER_COSTS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FLUSH_OPTIMIZER_COSTS', parent=current)
        self.exit_rule(current)
        return current
    FLUSH_OPTIMIZER_COSTS.min_depth = 0

    @depthcontrol
    def FLUSH_STATUS(self, parent=None):
        current = UnlexerRule(name='FLUSH_STATUS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FLUSH_STATUS', parent=current)
        self.exit_rule(current)
        return current
    FLUSH_STATUS.min_depth = 0

    @depthcontrol
    def FLUSH_TABLES(self, parent=None):
        current = UnlexerRule(name='FLUSH_TABLES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FLUSH_TABLES', parent=current)
        self.exit_rule(current)
        return current
    FLUSH_TABLES.min_depth = 0

    @depthcontrol
    def FLUSH_USER_RESOURCES(self, parent=None):
        current = UnlexerRule(name='FLUSH_USER_RESOURCES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FLUSH_USER_RESOURCES', parent=current)
        self.exit_rule(current)
        return current
    FLUSH_USER_RESOURCES.min_depth = 0

    @depthcontrol
    def GROUP_REPLICATION_ADMIN(self, parent=None):
        current = UnlexerRule(name='GROUP_REPLICATION_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GROUP_REPLICATION_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    GROUP_REPLICATION_ADMIN.min_depth = 0

    @depthcontrol
    def INNODB_REDO_LOG_ARCHIVE(self, parent=None):
        current = UnlexerRule(name='INNODB_REDO_LOG_ARCHIVE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INNODB_REDO_LOG_ARCHIVE', parent=current)
        self.exit_rule(current)
        return current
    INNODB_REDO_LOG_ARCHIVE.min_depth = 0

    @depthcontrol
    def INNODB_REDO_LOG_ENABLE(self, parent=None):
        current = UnlexerRule(name='INNODB_REDO_LOG_ENABLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INNODB_REDO_LOG_ENABLE', parent=current)
        self.exit_rule(current)
        return current
    INNODB_REDO_LOG_ENABLE.min_depth = 0

    @depthcontrol
    def NDB_STORED_USER(self, parent=None):
        current = UnlexerRule(name='NDB_STORED_USER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NDB_STORED_USER', parent=current)
        self.exit_rule(current)
        return current
    NDB_STORED_USER.min_depth = 0

    @depthcontrol
    def PERSIST_RO_VARIABLES_ADMIN(self, parent=None):
        current = UnlexerRule(name='PERSIST_RO_VARIABLES_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PERSIST_RO_VARIABLES_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    PERSIST_RO_VARIABLES_ADMIN.min_depth = 0

    @depthcontrol
    def REPLICATION_APPLIER(self, parent=None):
        current = UnlexerRule(name='REPLICATION_APPLIER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REPLICATION_APPLIER', parent=current)
        self.exit_rule(current)
        return current
    REPLICATION_APPLIER.min_depth = 0

    @depthcontrol
    def REPLICATION_SLAVE_ADMIN(self, parent=None):
        current = UnlexerRule(name='REPLICATION_SLAVE_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REPLICATION_SLAVE_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    REPLICATION_SLAVE_ADMIN.min_depth = 0

    @depthcontrol
    def RESOURCE_GROUP_ADMIN(self, parent=None):
        current = UnlexerRule(name='RESOURCE_GROUP_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RESOURCE_GROUP_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    RESOURCE_GROUP_ADMIN.min_depth = 0

    @depthcontrol
    def RESOURCE_GROUP_USER(self, parent=None):
        current = UnlexerRule(name='RESOURCE_GROUP_USER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RESOURCE_GROUP_USER', parent=current)
        self.exit_rule(current)
        return current
    RESOURCE_GROUP_USER.min_depth = 0

    @depthcontrol
    def ROLE_ADMIN(self, parent=None):
        current = UnlexerRule(name='ROLE_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ROLE_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    ROLE_ADMIN.min_depth = 0

    @depthcontrol
    def SERVICE_CONNECTION_ADMIN(self, parent=None):
        current = UnlexerRule(name='SERVICE_CONNECTION_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SERVICE_CONNECTION_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    SERVICE_CONNECTION_ADMIN.min_depth = 0

    @depthcontrol
    def SESSION_VARIABLES_ADMIN(self, parent=None):
        current = UnlexerRule(name='SESSION_VARIABLES_ADMIN', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.QUOTE_SYMB(parent=current)
        UnlexerRule(src='SESSION_VARIABLES_ADMIN', parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.QUOTE_SYMB(parent=current)
        self.exit_rule(current)
        return current
    SESSION_VARIABLES_ADMIN.min_depth = 0

    @depthcontrol
    def SET_USER_ID(self, parent=None):
        current = UnlexerRule(name='SET_USER_ID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SET_USER_ID', parent=current)
        self.exit_rule(current)
        return current
    SET_USER_ID.min_depth = 0

    @depthcontrol
    def SHOW_ROUTINE(self, parent=None):
        current = UnlexerRule(name='SHOW_ROUTINE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SHOW_ROUTINE', parent=current)
        self.exit_rule(current)
        return current
    SHOW_ROUTINE.min_depth = 0

    @depthcontrol
    def SYSTEM_VARIABLES_ADMIN(self, parent=None):
        current = UnlexerRule(name='SYSTEM_VARIABLES_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SYSTEM_VARIABLES_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    SYSTEM_VARIABLES_ADMIN.min_depth = 0

    @depthcontrol
    def TABLE_ENCRYPTION_ADMIN(self, parent=None):
        current = UnlexerRule(name='TABLE_ENCRYPTION_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TABLE_ENCRYPTION_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    TABLE_ENCRYPTION_ADMIN.min_depth = 0

    @depthcontrol
    def VERSION_TOKEN_ADMIN(self, parent=None):
        current = UnlexerRule(name='VERSION_TOKEN_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VERSION_TOKEN_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    VERSION_TOKEN_ADMIN.min_depth = 0

    @depthcontrol
    def XA_RECOVER_ADMIN(self, parent=None):
        current = UnlexerRule(name='XA_RECOVER_ADMIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='XA_RECOVER_ADMIN', parent=current)
        self.exit_rule(current)
        return current
    XA_RECOVER_ADMIN.min_depth = 0

    @depthcontrol
    def ARMSCII8(self, parent=None):
        current = UnlexerRule(name='ARMSCII8', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ARMSCII8', parent=current)
        self.exit_rule(current)
        return current
    ARMSCII8.min_depth = 0

    @depthcontrol
    def ASCII(self, parent=None):
        current = UnlexerRule(name='ASCII', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ASCII', parent=current)
        self.exit_rule(current)
        return current
    ASCII.min_depth = 0

    @depthcontrol
    def BIG5(self, parent=None):
        current = UnlexerRule(name='BIG5', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BIG5', parent=current)
        self.exit_rule(current)
        return current
    BIG5.min_depth = 0

    @depthcontrol
    def CP1250(self, parent=None):
        current = UnlexerRule(name='CP1250', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CP1250', parent=current)
        self.exit_rule(current)
        return current
    CP1250.min_depth = 0

    @depthcontrol
    def CP1251(self, parent=None):
        current = UnlexerRule(name='CP1251', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CP1251', parent=current)
        self.exit_rule(current)
        return current
    CP1251.min_depth = 0

    @depthcontrol
    def CP1256(self, parent=None):
        current = UnlexerRule(name='CP1256', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CP1256', parent=current)
        self.exit_rule(current)
        return current
    CP1256.min_depth = 0

    @depthcontrol
    def CP1257(self, parent=None):
        current = UnlexerRule(name='CP1257', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CP1257', parent=current)
        self.exit_rule(current)
        return current
    CP1257.min_depth = 0

    @depthcontrol
    def CP850(self, parent=None):
        current = UnlexerRule(name='CP850', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CP850', parent=current)
        self.exit_rule(current)
        return current
    CP850.min_depth = 0

    @depthcontrol
    def CP852(self, parent=None):
        current = UnlexerRule(name='CP852', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CP852', parent=current)
        self.exit_rule(current)
        return current
    CP852.min_depth = 0

    @depthcontrol
    def CP866(self, parent=None):
        current = UnlexerRule(name='CP866', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CP866', parent=current)
        self.exit_rule(current)
        return current
    CP866.min_depth = 0

    @depthcontrol
    def CP932(self, parent=None):
        current = UnlexerRule(name='CP932', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CP932', parent=current)
        self.exit_rule(current)
        return current
    CP932.min_depth = 0

    @depthcontrol
    def DEC8(self, parent=None):
        current = UnlexerRule(name='DEC8', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DEC8', parent=current)
        self.exit_rule(current)
        return current
    DEC8.min_depth = 0

    @depthcontrol
    def EUCJPMS(self, parent=None):
        current = UnlexerRule(name='EUCJPMS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EUCJPMS', parent=current)
        self.exit_rule(current)
        return current
    EUCJPMS.min_depth = 0

    @depthcontrol
    def EUCKR(self, parent=None):
        current = UnlexerRule(name='EUCKR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EUCKR', parent=current)
        self.exit_rule(current)
        return current
    EUCKR.min_depth = 0

    @depthcontrol
    def GB2312(self, parent=None):
        current = UnlexerRule(name='GB2312', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GB2312', parent=current)
        self.exit_rule(current)
        return current
    GB2312.min_depth = 0

    @depthcontrol
    def GBK(self, parent=None):
        current = UnlexerRule(name='GBK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GBK', parent=current)
        self.exit_rule(current)
        return current
    GBK.min_depth = 0

    @depthcontrol
    def GEOSTD8(self, parent=None):
        current = UnlexerRule(name='GEOSTD8', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GEOSTD8', parent=current)
        self.exit_rule(current)
        return current
    GEOSTD8.min_depth = 0

    @depthcontrol
    def GREEK(self, parent=None):
        current = UnlexerRule(name='GREEK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GREEK', parent=current)
        self.exit_rule(current)
        return current
    GREEK.min_depth = 0

    @depthcontrol
    def HEBREW(self, parent=None):
        current = UnlexerRule(name='HEBREW', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='HEBREW', parent=current)
        self.exit_rule(current)
        return current
    HEBREW.min_depth = 0

    @depthcontrol
    def HP8(self, parent=None):
        current = UnlexerRule(name='HP8', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='HP8', parent=current)
        self.exit_rule(current)
        return current
    HP8.min_depth = 0

    @depthcontrol
    def KEYBCS2(self, parent=None):
        current = UnlexerRule(name='KEYBCS2', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='KEYBCS2', parent=current)
        self.exit_rule(current)
        return current
    KEYBCS2.min_depth = 0

    @depthcontrol
    def KOI8R(self, parent=None):
        current = UnlexerRule(name='KOI8R', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='KOI8R', parent=current)
        self.exit_rule(current)
        return current
    KOI8R.min_depth = 0

    @depthcontrol
    def KOI8U(self, parent=None):
        current = UnlexerRule(name='KOI8U', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='KOI8U', parent=current)
        self.exit_rule(current)
        return current
    KOI8U.min_depth = 0

    @depthcontrol
    def LATIN1(self, parent=None):
        current = UnlexerRule(name='LATIN1', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LATIN1', parent=current)
        self.exit_rule(current)
        return current
    LATIN1.min_depth = 0

    @depthcontrol
    def LATIN2(self, parent=None):
        current = UnlexerRule(name='LATIN2', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LATIN2', parent=current)
        self.exit_rule(current)
        return current
    LATIN2.min_depth = 0

    @depthcontrol
    def LATIN5(self, parent=None):
        current = UnlexerRule(name='LATIN5', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LATIN5', parent=current)
        self.exit_rule(current)
        return current
    LATIN5.min_depth = 0

    @depthcontrol
    def LATIN7(self, parent=None):
        current = UnlexerRule(name='LATIN7', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LATIN7', parent=current)
        self.exit_rule(current)
        return current
    LATIN7.min_depth = 0

    @depthcontrol
    def MACCE(self, parent=None):
        current = UnlexerRule(name='MACCE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MACCE', parent=current)
        self.exit_rule(current)
        return current
    MACCE.min_depth = 0

    @depthcontrol
    def MACROMAN(self, parent=None):
        current = UnlexerRule(name='MACROMAN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MACROMAN', parent=current)
        self.exit_rule(current)
        return current
    MACROMAN.min_depth = 0

    @depthcontrol
    def SJIS(self, parent=None):
        current = UnlexerRule(name='SJIS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SJIS', parent=current)
        self.exit_rule(current)
        return current
    SJIS.min_depth = 0

    @depthcontrol
    def SWE7(self, parent=None):
        current = UnlexerRule(name='SWE7', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SWE7', parent=current)
        self.exit_rule(current)
        return current
    SWE7.min_depth = 0

    @depthcontrol
    def TIS620(self, parent=None):
        current = UnlexerRule(name='TIS620', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TIS620', parent=current)
        self.exit_rule(current)
        return current
    TIS620.min_depth = 0

    @depthcontrol
    def UCS2(self, parent=None):
        current = UnlexerRule(name='UCS2', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UCS2', parent=current)
        self.exit_rule(current)
        return current
    UCS2.min_depth = 0

    @depthcontrol
    def UJIS(self, parent=None):
        current = UnlexerRule(name='UJIS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UJIS', parent=current)
        self.exit_rule(current)
        return current
    UJIS.min_depth = 0

    @depthcontrol
    def UTF16(self, parent=None):
        current = UnlexerRule(name='UTF16', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UTF16', parent=current)
        self.exit_rule(current)
        return current
    UTF16.min_depth = 0

    @depthcontrol
    def UTF16LE(self, parent=None):
        current = UnlexerRule(name='UTF16LE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UTF16LE', parent=current)
        self.exit_rule(current)
        return current
    UTF16LE.min_depth = 0

    @depthcontrol
    def UTF32(self, parent=None):
        current = UnlexerRule(name='UTF32', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UTF32', parent=current)
        self.exit_rule(current)
        return current
    UTF32.min_depth = 0

    @depthcontrol
    def UTF8(self, parent=None):
        current = UnlexerRule(name='UTF8', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UTF8', parent=current)
        self.exit_rule(current)
        return current
    UTF8.min_depth = 0

    @depthcontrol
    def UTF8MB3(self, parent=None):
        current = UnlexerRule(name='UTF8MB3', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UTF8MB3', parent=current)
        self.exit_rule(current)
        return current
    UTF8MB3.min_depth = 0

    @depthcontrol
    def UTF8MB4(self, parent=None):
        current = UnlexerRule(name='UTF8MB4', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UTF8MB4', parent=current)
        self.exit_rule(current)
        return current
    UTF8MB4.min_depth = 0

    @depthcontrol
    def ARCHIVE(self, parent=None):
        current = UnlexerRule(name='ARCHIVE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ARCHIVE', parent=current)
        self.exit_rule(current)
        return current
    ARCHIVE.min_depth = 0

    @depthcontrol
    def BLACKHOLE(self, parent=None):
        current = UnlexerRule(name='BLACKHOLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BLACKHOLE', parent=current)
        self.exit_rule(current)
        return current
    BLACKHOLE.min_depth = 0

    @depthcontrol
    def CSV(self, parent=None):
        current = UnlexerRule(name='CSV', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CSV', parent=current)
        self.exit_rule(current)
        return current
    CSV.min_depth = 0

    @depthcontrol
    def FEDERATED(self, parent=None):
        current = UnlexerRule(name='FEDERATED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FEDERATED', parent=current)
        self.exit_rule(current)
        return current
    FEDERATED.min_depth = 0

    @depthcontrol
    def INNODB(self, parent=None):
        current = UnlexerRule(name='INNODB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INNODB', parent=current)
        self.exit_rule(current)
        return current
    INNODB.min_depth = 0

    @depthcontrol
    def MEMORY(self, parent=None):
        current = UnlexerRule(name='MEMORY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MEMORY', parent=current)
        self.exit_rule(current)
        return current
    MEMORY.min_depth = 0

    @depthcontrol
    def MRG_MYISAM(self, parent=None):
        current = UnlexerRule(name='MRG_MYISAM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MRG_MYISAM', parent=current)
        self.exit_rule(current)
        return current
    MRG_MYISAM.min_depth = 0

    @depthcontrol
    def MYISAM(self, parent=None):
        current = UnlexerRule(name='MYISAM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MYISAM', parent=current)
        self.exit_rule(current)
        return current
    MYISAM.min_depth = 0

    @depthcontrol
    def NDB(self, parent=None):
        current = UnlexerRule(name='NDB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NDB', parent=current)
        self.exit_rule(current)
        return current
    NDB.min_depth = 0

    @depthcontrol
    def NDBCLUSTER(self, parent=None):
        current = UnlexerRule(name='NDBCLUSTER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NDBCLUSTER', parent=current)
        self.exit_rule(current)
        return current
    NDBCLUSTER.min_depth = 0

    @depthcontrol
    def PERFORMANCE_SCHEMA(self, parent=None):
        current = UnlexerRule(name='PERFORMANCE_SCHEMA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PERFORMANCE_SCHEMA', parent=current)
        self.exit_rule(current)
        return current
    PERFORMANCE_SCHEMA.min_depth = 0

    @depthcontrol
    def TOKUDB(self, parent=None):
        current = UnlexerRule(name='TOKUDB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TOKUDB', parent=current)
        self.exit_rule(current)
        return current
    TOKUDB.min_depth = 0

    @depthcontrol
    def REPEATABLE(self, parent=None):
        current = UnlexerRule(name='REPEATABLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REPEATABLE', parent=current)
        self.exit_rule(current)
        return current
    REPEATABLE.min_depth = 0

    @depthcontrol
    def COMMITTED(self, parent=None):
        current = UnlexerRule(name='COMMITTED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COMMITTED', parent=current)
        self.exit_rule(current)
        return current
    COMMITTED.min_depth = 0

    @depthcontrol
    def UNCOMMITTED(self, parent=None):
        current = UnlexerRule(name='UNCOMMITTED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNCOMMITTED', parent=current)
        self.exit_rule(current)
        return current
    UNCOMMITTED.min_depth = 0

    @depthcontrol
    def SERIALIZABLE(self, parent=None):
        current = UnlexerRule(name='SERIALIZABLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SERIALIZABLE', parent=current)
        self.exit_rule(current)
        return current
    SERIALIZABLE.min_depth = 0

    @depthcontrol
    def GEOMETRYCOLLECTION(self, parent=None):
        current = UnlexerRule(name='GEOMETRYCOLLECTION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GEOMETRYCOLLECTION', parent=current)
        self.exit_rule(current)
        return current
    GEOMETRYCOLLECTION.min_depth = 0

    @depthcontrol
    def GEOMCOLLECTION(self, parent=None):
        current = UnlexerRule(name='GEOMCOLLECTION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GEOMCOLLECTION', parent=current)
        self.exit_rule(current)
        return current
    GEOMCOLLECTION.min_depth = 0

    @depthcontrol
    def GEOMETRY(self, parent=None):
        current = UnlexerRule(name='GEOMETRY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GEOMETRY', parent=current)
        self.exit_rule(current)
        return current
    GEOMETRY.min_depth = 0

    @depthcontrol
    def LINESTRING(self, parent=None):
        current = UnlexerRule(name='LINESTRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LINESTRING', parent=current)
        self.exit_rule(current)
        return current
    LINESTRING.min_depth = 0

    @depthcontrol
    def MULTILINESTRING(self, parent=None):
        current = UnlexerRule(name='MULTILINESTRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MULTILINESTRING', parent=current)
        self.exit_rule(current)
        return current
    MULTILINESTRING.min_depth = 0

    @depthcontrol
    def MULTIPOINT(self, parent=None):
        current = UnlexerRule(name='MULTIPOINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MULTIPOINT', parent=current)
        self.exit_rule(current)
        return current
    MULTIPOINT.min_depth = 0

    @depthcontrol
    def MULTIPOLYGON(self, parent=None):
        current = UnlexerRule(name='MULTIPOLYGON', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MULTIPOLYGON', parent=current)
        self.exit_rule(current)
        return current
    MULTIPOLYGON.min_depth = 0

    @depthcontrol
    def POINT(self, parent=None):
        current = UnlexerRule(name='POINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='POINT', parent=current)
        self.exit_rule(current)
        return current
    POINT.min_depth = 0

    @depthcontrol
    def POLYGON(self, parent=None):
        current = UnlexerRule(name='POLYGON', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='POLYGON', parent=current)
        self.exit_rule(current)
        return current
    POLYGON.min_depth = 0

    @depthcontrol
    def ABS(self, parent=None):
        current = UnlexerRule(name='ABS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ABS', parent=current)
        self.exit_rule(current)
        return current
    ABS.min_depth = 0

    @depthcontrol
    def ACOS(self, parent=None):
        current = UnlexerRule(name='ACOS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ACOS', parent=current)
        self.exit_rule(current)
        return current
    ACOS.min_depth = 0

    @depthcontrol
    def ADDDATE(self, parent=None):
        current = UnlexerRule(name='ADDDATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ADDDATE', parent=current)
        self.exit_rule(current)
        return current
    ADDDATE.min_depth = 0

    @depthcontrol
    def ADDTIME(self, parent=None):
        current = UnlexerRule(name='ADDTIME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ADDTIME', parent=current)
        self.exit_rule(current)
        return current
    ADDTIME.min_depth = 0

    @depthcontrol
    def AES_DECRYPT(self, parent=None):
        current = UnlexerRule(name='AES_DECRYPT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='AES_DECRYPT', parent=current)
        self.exit_rule(current)
        return current
    AES_DECRYPT.min_depth = 0

    @depthcontrol
    def AES_ENCRYPT(self, parent=None):
        current = UnlexerRule(name='AES_ENCRYPT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='AES_ENCRYPT', parent=current)
        self.exit_rule(current)
        return current
    AES_ENCRYPT.min_depth = 0

    @depthcontrol
    def AREA(self, parent=None):
        current = UnlexerRule(name='AREA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='AREA', parent=current)
        self.exit_rule(current)
        return current
    AREA.min_depth = 0

    @depthcontrol
    def ASBINARY(self, parent=None):
        current = UnlexerRule(name='ASBINARY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ASBINARY', parent=current)
        self.exit_rule(current)
        return current
    ASBINARY.min_depth = 0

    @depthcontrol
    def ASIN(self, parent=None):
        current = UnlexerRule(name='ASIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ASIN', parent=current)
        self.exit_rule(current)
        return current
    ASIN.min_depth = 0

    @depthcontrol
    def ASTEXT(self, parent=None):
        current = UnlexerRule(name='ASTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ASTEXT', parent=current)
        self.exit_rule(current)
        return current
    ASTEXT.min_depth = 0

    @depthcontrol
    def ASWKB(self, parent=None):
        current = UnlexerRule(name='ASWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ASWKB', parent=current)
        self.exit_rule(current)
        return current
    ASWKB.min_depth = 0

    @depthcontrol
    def ASWKT(self, parent=None):
        current = UnlexerRule(name='ASWKT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ASWKT', parent=current)
        self.exit_rule(current)
        return current
    ASWKT.min_depth = 0

    @depthcontrol
    def ASYMMETRIC_DECRYPT(self, parent=None):
        current = UnlexerRule(name='ASYMMETRIC_DECRYPT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ASYMMETRIC_DECRYPT', parent=current)
        self.exit_rule(current)
        return current
    ASYMMETRIC_DECRYPT.min_depth = 0

    @depthcontrol
    def ASYMMETRIC_DERIVE(self, parent=None):
        current = UnlexerRule(name='ASYMMETRIC_DERIVE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ASYMMETRIC_DERIVE', parent=current)
        self.exit_rule(current)
        return current
    ASYMMETRIC_DERIVE.min_depth = 0

    @depthcontrol
    def ASYMMETRIC_ENCRYPT(self, parent=None):
        current = UnlexerRule(name='ASYMMETRIC_ENCRYPT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ASYMMETRIC_ENCRYPT', parent=current)
        self.exit_rule(current)
        return current
    ASYMMETRIC_ENCRYPT.min_depth = 0

    @depthcontrol
    def ASYMMETRIC_SIGN(self, parent=None):
        current = UnlexerRule(name='ASYMMETRIC_SIGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ASYMMETRIC_SIGN', parent=current)
        self.exit_rule(current)
        return current
    ASYMMETRIC_SIGN.min_depth = 0

    @depthcontrol
    def ASYMMETRIC_VERIFY(self, parent=None):
        current = UnlexerRule(name='ASYMMETRIC_VERIFY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ASYMMETRIC_VERIFY', parent=current)
        self.exit_rule(current)
        return current
    ASYMMETRIC_VERIFY.min_depth = 0

    @depthcontrol
    def ATAN(self, parent=None):
        current = UnlexerRule(name='ATAN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ATAN', parent=current)
        self.exit_rule(current)
        return current
    ATAN.min_depth = 0

    @depthcontrol
    def ATAN2(self, parent=None):
        current = UnlexerRule(name='ATAN2', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ATAN2', parent=current)
        self.exit_rule(current)
        return current
    ATAN2.min_depth = 0

    @depthcontrol
    def BENCHMARK(self, parent=None):
        current = UnlexerRule(name='BENCHMARK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BENCHMARK', parent=current)
        self.exit_rule(current)
        return current
    BENCHMARK.min_depth = 0

    @depthcontrol
    def BIN(self, parent=None):
        current = UnlexerRule(name='BIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BIN', parent=current)
        self.exit_rule(current)
        return current
    BIN.min_depth = 0

    @depthcontrol
    def BIT_COUNT(self, parent=None):
        current = UnlexerRule(name='BIT_COUNT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BIT_COUNT', parent=current)
        self.exit_rule(current)
        return current
    BIT_COUNT.min_depth = 0

    @depthcontrol
    def BIT_LENGTH(self, parent=None):
        current = UnlexerRule(name='BIT_LENGTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BIT_LENGTH', parent=current)
        self.exit_rule(current)
        return current
    BIT_LENGTH.min_depth = 0

    @depthcontrol
    def BUFFER(self, parent=None):
        current = UnlexerRule(name='BUFFER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BUFFER', parent=current)
        self.exit_rule(current)
        return current
    BUFFER.min_depth = 0

    @depthcontrol
    def CATALOG_NAME(self, parent=None):
        current = UnlexerRule(name='CATALOG_NAME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CATALOG_NAME', parent=current)
        self.exit_rule(current)
        return current
    CATALOG_NAME.min_depth = 0

    @depthcontrol
    def CEIL(self, parent=None):
        current = UnlexerRule(name='CEIL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CEIL', parent=current)
        self.exit_rule(current)
        return current
    CEIL.min_depth = 0

    @depthcontrol
    def CEILING(self, parent=None):
        current = UnlexerRule(name='CEILING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CEILING', parent=current)
        self.exit_rule(current)
        return current
    CEILING.min_depth = 0

    @depthcontrol
    def CENTROID(self, parent=None):
        current = UnlexerRule(name='CENTROID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CENTROID', parent=current)
        self.exit_rule(current)
        return current
    CENTROID.min_depth = 0

    @depthcontrol
    def CHARACTER_LENGTH(self, parent=None):
        current = UnlexerRule(name='CHARACTER_LENGTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CHARACTER_LENGTH', parent=current)
        self.exit_rule(current)
        return current
    CHARACTER_LENGTH.min_depth = 0

    @depthcontrol
    def CHARSET(self, parent=None):
        current = UnlexerRule(name='CHARSET', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CHARSET', parent=current)
        self.exit_rule(current)
        return current
    CHARSET.min_depth = 0

    @depthcontrol
    def CHAR_LENGTH(self, parent=None):
        current = UnlexerRule(name='CHAR_LENGTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CHAR_LENGTH', parent=current)
        self.exit_rule(current)
        return current
    CHAR_LENGTH.min_depth = 0

    @depthcontrol
    def COERCIBILITY(self, parent=None):
        current = UnlexerRule(name='COERCIBILITY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COERCIBILITY', parent=current)
        self.exit_rule(current)
        return current
    COERCIBILITY.min_depth = 0

    @depthcontrol
    def COLLATION(self, parent=None):
        current = UnlexerRule(name='COLLATION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COLLATION', parent=current)
        self.exit_rule(current)
        return current
    COLLATION.min_depth = 0

    @depthcontrol
    def COMPRESS(self, parent=None):
        current = UnlexerRule(name='COMPRESS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COMPRESS', parent=current)
        self.exit_rule(current)
        return current
    COMPRESS.min_depth = 0

    @depthcontrol
    def CONCAT(self, parent=None):
        current = UnlexerRule(name='CONCAT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONCAT', parent=current)
        self.exit_rule(current)
        return current
    CONCAT.min_depth = 0

    @depthcontrol
    def CONCAT_WS(self, parent=None):
        current = UnlexerRule(name='CONCAT_WS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONCAT_WS', parent=current)
        self.exit_rule(current)
        return current
    CONCAT_WS.min_depth = 0

    @depthcontrol
    def CONNECTION_ID(self, parent=None):
        current = UnlexerRule(name='CONNECTION_ID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONNECTION_ID', parent=current)
        self.exit_rule(current)
        return current
    CONNECTION_ID.min_depth = 0

    @depthcontrol
    def CONV(self, parent=None):
        current = UnlexerRule(name='CONV', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONV', parent=current)
        self.exit_rule(current)
        return current
    CONV.min_depth = 0

    @depthcontrol
    def CONVERT_TZ(self, parent=None):
        current = UnlexerRule(name='CONVERT_TZ', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CONVERT_TZ', parent=current)
        self.exit_rule(current)
        return current
    CONVERT_TZ.min_depth = 0

    @depthcontrol
    def COS(self, parent=None):
        current = UnlexerRule(name='COS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COS', parent=current)
        self.exit_rule(current)
        return current
    COS.min_depth = 0

    @depthcontrol
    def COT(self, parent=None):
        current = UnlexerRule(name='COT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='COT', parent=current)
        self.exit_rule(current)
        return current
    COT.min_depth = 0

    @depthcontrol
    def CRC32(self, parent=None):
        current = UnlexerRule(name='CRC32', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CRC32', parent=current)
        self.exit_rule(current)
        return current
    CRC32.min_depth = 0

    @depthcontrol
    def CREATE_ASYMMETRIC_PRIV_KEY(self, parent=None):
        current = UnlexerRule(name='CREATE_ASYMMETRIC_PRIV_KEY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CREATE_ASYMMETRIC_PRIV_KEY', parent=current)
        self.exit_rule(current)
        return current
    CREATE_ASYMMETRIC_PRIV_KEY.min_depth = 0

    @depthcontrol
    def CREATE_ASYMMETRIC_PUB_KEY(self, parent=None):
        current = UnlexerRule(name='CREATE_ASYMMETRIC_PUB_KEY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CREATE_ASYMMETRIC_PUB_KEY', parent=current)
        self.exit_rule(current)
        return current
    CREATE_ASYMMETRIC_PUB_KEY.min_depth = 0

    @depthcontrol
    def CREATE_DH_PARAMETERS(self, parent=None):
        current = UnlexerRule(name='CREATE_DH_PARAMETERS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CREATE_DH_PARAMETERS', parent=current)
        self.exit_rule(current)
        return current
    CREATE_DH_PARAMETERS.min_depth = 0

    @depthcontrol
    def CREATE_DIGEST(self, parent=None):
        current = UnlexerRule(name='CREATE_DIGEST', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CREATE_DIGEST', parent=current)
        self.exit_rule(current)
        return current
    CREATE_DIGEST.min_depth = 0

    @depthcontrol
    def CROSSES(self, parent=None):
        current = UnlexerRule(name='CROSSES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CROSSES', parent=current)
        self.exit_rule(current)
        return current
    CROSSES.min_depth = 0

    @depthcontrol
    def DATEDIFF(self, parent=None):
        current = UnlexerRule(name='DATEDIFF', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DATEDIFF', parent=current)
        self.exit_rule(current)
        return current
    DATEDIFF.min_depth = 0

    @depthcontrol
    def DATE_FORMAT(self, parent=None):
        current = UnlexerRule(name='DATE_FORMAT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DATE_FORMAT', parent=current)
        self.exit_rule(current)
        return current
    DATE_FORMAT.min_depth = 0

    @depthcontrol
    def DAYNAME(self, parent=None):
        current = UnlexerRule(name='DAYNAME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DAYNAME', parent=current)
        self.exit_rule(current)
        return current
    DAYNAME.min_depth = 0

    @depthcontrol
    def DAYOFMONTH(self, parent=None):
        current = UnlexerRule(name='DAYOFMONTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DAYOFMONTH', parent=current)
        self.exit_rule(current)
        return current
    DAYOFMONTH.min_depth = 0

    @depthcontrol
    def DAYOFWEEK(self, parent=None):
        current = UnlexerRule(name='DAYOFWEEK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DAYOFWEEK', parent=current)
        self.exit_rule(current)
        return current
    DAYOFWEEK.min_depth = 0

    @depthcontrol
    def DAYOFYEAR(self, parent=None):
        current = UnlexerRule(name='DAYOFYEAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DAYOFYEAR', parent=current)
        self.exit_rule(current)
        return current
    DAYOFYEAR.min_depth = 0

    @depthcontrol
    def DECODE(self, parent=None):
        current = UnlexerRule(name='DECODE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DECODE', parent=current)
        self.exit_rule(current)
        return current
    DECODE.min_depth = 0

    @depthcontrol
    def DEGREES(self, parent=None):
        current = UnlexerRule(name='DEGREES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DEGREES', parent=current)
        self.exit_rule(current)
        return current
    DEGREES.min_depth = 0

    @depthcontrol
    def DES_DECRYPT(self, parent=None):
        current = UnlexerRule(name='DES_DECRYPT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DES_DECRYPT', parent=current)
        self.exit_rule(current)
        return current
    DES_DECRYPT.min_depth = 0

    @depthcontrol
    def DES_ENCRYPT(self, parent=None):
        current = UnlexerRule(name='DES_ENCRYPT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DES_ENCRYPT', parent=current)
        self.exit_rule(current)
        return current
    DES_ENCRYPT.min_depth = 0

    @depthcontrol
    def DIMENSION(self, parent=None):
        current = UnlexerRule(name='DIMENSION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DIMENSION', parent=current)
        self.exit_rule(current)
        return current
    DIMENSION.min_depth = 0

    @depthcontrol
    def DISJOINT(self, parent=None):
        current = UnlexerRule(name='DISJOINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DISJOINT', parent=current)
        self.exit_rule(current)
        return current
    DISJOINT.min_depth = 0

    @depthcontrol
    def ELT(self, parent=None):
        current = UnlexerRule(name='ELT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ELT', parent=current)
        self.exit_rule(current)
        return current
    ELT.min_depth = 0

    @depthcontrol
    def ENCODE(self, parent=None):
        current = UnlexerRule(name='ENCODE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ENCODE', parent=current)
        self.exit_rule(current)
        return current
    ENCODE.min_depth = 0

    @depthcontrol
    def ENCRYPT(self, parent=None):
        current = UnlexerRule(name='ENCRYPT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ENCRYPT', parent=current)
        self.exit_rule(current)
        return current
    ENCRYPT.min_depth = 0

    @depthcontrol
    def ENDPOINT(self, parent=None):
        current = UnlexerRule(name='ENDPOINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ENDPOINT', parent=current)
        self.exit_rule(current)
        return current
    ENDPOINT.min_depth = 0

    @depthcontrol
    def ENVELOPE(self, parent=None):
        current = UnlexerRule(name='ENVELOPE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ENVELOPE', parent=current)
        self.exit_rule(current)
        return current
    ENVELOPE.min_depth = 0

    @depthcontrol
    def EQUALS(self, parent=None):
        current = UnlexerRule(name='EQUALS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EQUALS', parent=current)
        self.exit_rule(current)
        return current
    EQUALS.min_depth = 0

    @depthcontrol
    def EXP(self, parent=None):
        current = UnlexerRule(name='EXP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EXP', parent=current)
        self.exit_rule(current)
        return current
    EXP.min_depth = 0

    @depthcontrol
    def EXPORT_SET(self, parent=None):
        current = UnlexerRule(name='EXPORT_SET', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EXPORT_SET', parent=current)
        self.exit_rule(current)
        return current
    EXPORT_SET.min_depth = 0

    @depthcontrol
    def EXTERIORRING(self, parent=None):
        current = UnlexerRule(name='EXTERIORRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EXTERIORRING', parent=current)
        self.exit_rule(current)
        return current
    EXTERIORRING.min_depth = 0

    @depthcontrol
    def EXTRACTVALUE(self, parent=None):
        current = UnlexerRule(name='EXTRACTVALUE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='EXTRACTVALUE', parent=current)
        self.exit_rule(current)
        return current
    EXTRACTVALUE.min_depth = 0

    @depthcontrol
    def FIELD(self, parent=None):
        current = UnlexerRule(name='FIELD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FIELD', parent=current)
        self.exit_rule(current)
        return current
    FIELD.min_depth = 0

    @depthcontrol
    def FIND_IN_SET(self, parent=None):
        current = UnlexerRule(name='FIND_IN_SET', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FIND_IN_SET', parent=current)
        self.exit_rule(current)
        return current
    FIND_IN_SET.min_depth = 0

    @depthcontrol
    def FLOOR(self, parent=None):
        current = UnlexerRule(name='FLOOR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FLOOR', parent=current)
        self.exit_rule(current)
        return current
    FLOOR.min_depth = 0

    @depthcontrol
    def FORMAT(self, parent=None):
        current = UnlexerRule(name='FORMAT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FORMAT', parent=current)
        self.exit_rule(current)
        return current
    FORMAT.min_depth = 0

    @depthcontrol
    def FOUND_ROWS(self, parent=None):
        current = UnlexerRule(name='FOUND_ROWS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FOUND_ROWS', parent=current)
        self.exit_rule(current)
        return current
    FOUND_ROWS.min_depth = 0

    @depthcontrol
    def FROM_BASE64(self, parent=None):
        current = UnlexerRule(name='FROM_BASE64', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FROM_BASE64', parent=current)
        self.exit_rule(current)
        return current
    FROM_BASE64.min_depth = 0

    @depthcontrol
    def FROM_DAYS(self, parent=None):
        current = UnlexerRule(name='FROM_DAYS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FROM_DAYS', parent=current)
        self.exit_rule(current)
        return current
    FROM_DAYS.min_depth = 0

    @depthcontrol
    def FROM_UNIXTIME(self, parent=None):
        current = UnlexerRule(name='FROM_UNIXTIME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='FROM_UNIXTIME', parent=current)
        self.exit_rule(current)
        return current
    FROM_UNIXTIME.min_depth = 0

    @depthcontrol
    def GEOMCOLLFROMTEXT(self, parent=None):
        current = UnlexerRule(name='GEOMCOLLFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GEOMCOLLFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    GEOMCOLLFROMTEXT.min_depth = 0

    @depthcontrol
    def GEOMCOLLFROMWKB(self, parent=None):
        current = UnlexerRule(name='GEOMCOLLFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GEOMCOLLFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    GEOMCOLLFROMWKB.min_depth = 0

    @depthcontrol
    def GEOMETRYCOLLECTIONFROMTEXT(self, parent=None):
        current = UnlexerRule(name='GEOMETRYCOLLECTIONFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GEOMETRYCOLLECTIONFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    GEOMETRYCOLLECTIONFROMTEXT.min_depth = 0

    @depthcontrol
    def GEOMETRYCOLLECTIONFROMWKB(self, parent=None):
        current = UnlexerRule(name='GEOMETRYCOLLECTIONFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GEOMETRYCOLLECTIONFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    GEOMETRYCOLLECTIONFROMWKB.min_depth = 0

    @depthcontrol
    def GEOMETRYFROMTEXT(self, parent=None):
        current = UnlexerRule(name='GEOMETRYFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GEOMETRYFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    GEOMETRYFROMTEXT.min_depth = 0

    @depthcontrol
    def GEOMETRYFROMWKB(self, parent=None):
        current = UnlexerRule(name='GEOMETRYFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GEOMETRYFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    GEOMETRYFROMWKB.min_depth = 0

    @depthcontrol
    def GEOMETRYN(self, parent=None):
        current = UnlexerRule(name='GEOMETRYN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GEOMETRYN', parent=current)
        self.exit_rule(current)
        return current
    GEOMETRYN.min_depth = 0

    @depthcontrol
    def GEOMETRYTYPE(self, parent=None):
        current = UnlexerRule(name='GEOMETRYTYPE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GEOMETRYTYPE', parent=current)
        self.exit_rule(current)
        return current
    GEOMETRYTYPE.min_depth = 0

    @depthcontrol
    def GEOMFROMTEXT(self, parent=None):
        current = UnlexerRule(name='GEOMFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GEOMFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    GEOMFROMTEXT.min_depth = 0

    @depthcontrol
    def GEOMFROMWKB(self, parent=None):
        current = UnlexerRule(name='GEOMFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GEOMFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    GEOMFROMWKB.min_depth = 0

    @depthcontrol
    def GET_FORMAT(self, parent=None):
        current = UnlexerRule(name='GET_FORMAT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GET_FORMAT', parent=current)
        self.exit_rule(current)
        return current
    GET_FORMAT.min_depth = 0

    @depthcontrol
    def GET_LOCK(self, parent=None):
        current = UnlexerRule(name='GET_LOCK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GET_LOCK', parent=current)
        self.exit_rule(current)
        return current
    GET_LOCK.min_depth = 0

    @depthcontrol
    def GLENGTH(self, parent=None):
        current = UnlexerRule(name='GLENGTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GLENGTH', parent=current)
        self.exit_rule(current)
        return current
    GLENGTH.min_depth = 0

    @depthcontrol
    def GREATEST(self, parent=None):
        current = UnlexerRule(name='GREATEST', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GREATEST', parent=current)
        self.exit_rule(current)
        return current
    GREATEST.min_depth = 0

    @depthcontrol
    def GTID_SUBSET(self, parent=None):
        current = UnlexerRule(name='GTID_SUBSET', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GTID_SUBSET', parent=current)
        self.exit_rule(current)
        return current
    GTID_SUBSET.min_depth = 0

    @depthcontrol
    def GTID_SUBTRACT(self, parent=None):
        current = UnlexerRule(name='GTID_SUBTRACT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='GTID_SUBTRACT', parent=current)
        self.exit_rule(current)
        return current
    GTID_SUBTRACT.min_depth = 0

    @depthcontrol
    def HEX(self, parent=None):
        current = UnlexerRule(name='HEX', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='HEX', parent=current)
        self.exit_rule(current)
        return current
    HEX.min_depth = 0

    @depthcontrol
    def IFNULL(self, parent=None):
        current = UnlexerRule(name='IFNULL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IFNULL', parent=current)
        self.exit_rule(current)
        return current
    IFNULL.min_depth = 0

    @depthcontrol
    def INET6_ATON(self, parent=None):
        current = UnlexerRule(name='INET6_ATON', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INET6_ATON', parent=current)
        self.exit_rule(current)
        return current
    INET6_ATON.min_depth = 0

    @depthcontrol
    def INET6_NTOA(self, parent=None):
        current = UnlexerRule(name='INET6_NTOA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INET6_NTOA', parent=current)
        self.exit_rule(current)
        return current
    INET6_NTOA.min_depth = 0

    @depthcontrol
    def INET_ATON(self, parent=None):
        current = UnlexerRule(name='INET_ATON', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INET_ATON', parent=current)
        self.exit_rule(current)
        return current
    INET_ATON.min_depth = 0

    @depthcontrol
    def INET_NTOA(self, parent=None):
        current = UnlexerRule(name='INET_NTOA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INET_NTOA', parent=current)
        self.exit_rule(current)
        return current
    INET_NTOA.min_depth = 0

    @depthcontrol
    def INSTR(self, parent=None):
        current = UnlexerRule(name='INSTR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INSTR', parent=current)
        self.exit_rule(current)
        return current
    INSTR.min_depth = 0

    @depthcontrol
    def INTERIORRINGN(self, parent=None):
        current = UnlexerRule(name='INTERIORRINGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INTERIORRINGN', parent=current)
        self.exit_rule(current)
        return current
    INTERIORRINGN.min_depth = 0

    @depthcontrol
    def INTERSECTS(self, parent=None):
        current = UnlexerRule(name='INTERSECTS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='INTERSECTS', parent=current)
        self.exit_rule(current)
        return current
    INTERSECTS.min_depth = 0

    @depthcontrol
    def ISCLOSED(self, parent=None):
        current = UnlexerRule(name='ISCLOSED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ISCLOSED', parent=current)
        self.exit_rule(current)
        return current
    ISCLOSED.min_depth = 0

    @depthcontrol
    def ISEMPTY(self, parent=None):
        current = UnlexerRule(name='ISEMPTY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ISEMPTY', parent=current)
        self.exit_rule(current)
        return current
    ISEMPTY.min_depth = 0

    @depthcontrol
    def ISNULL(self, parent=None):
        current = UnlexerRule(name='ISNULL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ISNULL', parent=current)
        self.exit_rule(current)
        return current
    ISNULL.min_depth = 0

    @depthcontrol
    def ISSIMPLE(self, parent=None):
        current = UnlexerRule(name='ISSIMPLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ISSIMPLE', parent=current)
        self.exit_rule(current)
        return current
    ISSIMPLE.min_depth = 0

    @depthcontrol
    def IS_FREE_LOCK(self, parent=None):
        current = UnlexerRule(name='IS_FREE_LOCK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IS_FREE_LOCK', parent=current)
        self.exit_rule(current)
        return current
    IS_FREE_LOCK.min_depth = 0

    @depthcontrol
    def IS_IPV4(self, parent=None):
        current = UnlexerRule(name='IS_IPV4', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IS_IPV4', parent=current)
        self.exit_rule(current)
        return current
    IS_IPV4.min_depth = 0

    @depthcontrol
    def IS_IPV4_COMPAT(self, parent=None):
        current = UnlexerRule(name='IS_IPV4_COMPAT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IS_IPV4_COMPAT', parent=current)
        self.exit_rule(current)
        return current
    IS_IPV4_COMPAT.min_depth = 0

    @depthcontrol
    def IS_IPV4_MAPPED(self, parent=None):
        current = UnlexerRule(name='IS_IPV4_MAPPED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IS_IPV4_MAPPED', parent=current)
        self.exit_rule(current)
        return current
    IS_IPV4_MAPPED.min_depth = 0

    @depthcontrol
    def IS_IPV6(self, parent=None):
        current = UnlexerRule(name='IS_IPV6', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IS_IPV6', parent=current)
        self.exit_rule(current)
        return current
    IS_IPV6.min_depth = 0

    @depthcontrol
    def IS_USED_LOCK(self, parent=None):
        current = UnlexerRule(name='IS_USED_LOCK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IS_USED_LOCK', parent=current)
        self.exit_rule(current)
        return current
    IS_USED_LOCK.min_depth = 0

    @depthcontrol
    def LAST_INSERT_ID(self, parent=None):
        current = UnlexerRule(name='LAST_INSERT_ID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LAST_INSERT_ID', parent=current)
        self.exit_rule(current)
        return current
    LAST_INSERT_ID.min_depth = 0

    @depthcontrol
    def LCASE(self, parent=None):
        current = UnlexerRule(name='LCASE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LCASE', parent=current)
        self.exit_rule(current)
        return current
    LCASE.min_depth = 0

    @depthcontrol
    def LEAST(self, parent=None):
        current = UnlexerRule(name='LEAST', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LEAST', parent=current)
        self.exit_rule(current)
        return current
    LEAST.min_depth = 0

    @depthcontrol
    def LENGTH(self, parent=None):
        current = UnlexerRule(name='LENGTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LENGTH', parent=current)
        self.exit_rule(current)
        return current
    LENGTH.min_depth = 0

    @depthcontrol
    def LINEFROMTEXT(self, parent=None):
        current = UnlexerRule(name='LINEFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LINEFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    LINEFROMTEXT.min_depth = 0

    @depthcontrol
    def LINEFROMWKB(self, parent=None):
        current = UnlexerRule(name='LINEFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LINEFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    LINEFROMWKB.min_depth = 0

    @depthcontrol
    def LINESTRINGFROMTEXT(self, parent=None):
        current = UnlexerRule(name='LINESTRINGFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LINESTRINGFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    LINESTRINGFROMTEXT.min_depth = 0

    @depthcontrol
    def LINESTRINGFROMWKB(self, parent=None):
        current = UnlexerRule(name='LINESTRINGFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LINESTRINGFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    LINESTRINGFROMWKB.min_depth = 0

    @depthcontrol
    def LN(self, parent=None):
        current = UnlexerRule(name='LN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LN', parent=current)
        self.exit_rule(current)
        return current
    LN.min_depth = 0

    @depthcontrol
    def LOAD_FILE(self, parent=None):
        current = UnlexerRule(name='LOAD_FILE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LOAD_FILE', parent=current)
        self.exit_rule(current)
        return current
    LOAD_FILE.min_depth = 0

    @depthcontrol
    def LOCATE(self, parent=None):
        current = UnlexerRule(name='LOCATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LOCATE', parent=current)
        self.exit_rule(current)
        return current
    LOCATE.min_depth = 0

    @depthcontrol
    def LOG(self, parent=None):
        current = UnlexerRule(name='LOG', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LOG', parent=current)
        self.exit_rule(current)
        return current
    LOG.min_depth = 0

    @depthcontrol
    def LOG10(self, parent=None):
        current = UnlexerRule(name='LOG10', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LOG10', parent=current)
        self.exit_rule(current)
        return current
    LOG10.min_depth = 0

    @depthcontrol
    def LOG2(self, parent=None):
        current = UnlexerRule(name='LOG2', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LOG2', parent=current)
        self.exit_rule(current)
        return current
    LOG2.min_depth = 0

    @depthcontrol
    def LOWER(self, parent=None):
        current = UnlexerRule(name='LOWER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LOWER', parent=current)
        self.exit_rule(current)
        return current
    LOWER.min_depth = 0

    @depthcontrol
    def LPAD(self, parent=None):
        current = UnlexerRule(name='LPAD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LPAD', parent=current)
        self.exit_rule(current)
        return current
    LPAD.min_depth = 0

    @depthcontrol
    def LTRIM(self, parent=None):
        current = UnlexerRule(name='LTRIM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LTRIM', parent=current)
        self.exit_rule(current)
        return current
    LTRIM.min_depth = 0

    @depthcontrol
    def MAKEDATE(self, parent=None):
        current = UnlexerRule(name='MAKEDATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MAKEDATE', parent=current)
        self.exit_rule(current)
        return current
    MAKEDATE.min_depth = 0

    @depthcontrol
    def MAKETIME(self, parent=None):
        current = UnlexerRule(name='MAKETIME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MAKETIME', parent=current)
        self.exit_rule(current)
        return current
    MAKETIME.min_depth = 0

    @depthcontrol
    def MAKE_SET(self, parent=None):
        current = UnlexerRule(name='MAKE_SET', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MAKE_SET', parent=current)
        self.exit_rule(current)
        return current
    MAKE_SET.min_depth = 0

    @depthcontrol
    def MASTER_POS_WAIT(self, parent=None):
        current = UnlexerRule(name='MASTER_POS_WAIT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MASTER_POS_WAIT', parent=current)
        self.exit_rule(current)
        return current
    MASTER_POS_WAIT.min_depth = 0

    @depthcontrol
    def MBRCONTAINS(self, parent=None):
        current = UnlexerRule(name='MBRCONTAINS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MBRCONTAINS', parent=current)
        self.exit_rule(current)
        return current
    MBRCONTAINS.min_depth = 0

    @depthcontrol
    def MBRDISJOINT(self, parent=None):
        current = UnlexerRule(name='MBRDISJOINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MBRDISJOINT', parent=current)
        self.exit_rule(current)
        return current
    MBRDISJOINT.min_depth = 0

    @depthcontrol
    def MBREQUAL(self, parent=None):
        current = UnlexerRule(name='MBREQUAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MBREQUAL', parent=current)
        self.exit_rule(current)
        return current
    MBREQUAL.min_depth = 0

    @depthcontrol
    def MBRINTERSECTS(self, parent=None):
        current = UnlexerRule(name='MBRINTERSECTS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MBRINTERSECTS', parent=current)
        self.exit_rule(current)
        return current
    MBRINTERSECTS.min_depth = 0

    @depthcontrol
    def MBROVERLAPS(self, parent=None):
        current = UnlexerRule(name='MBROVERLAPS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MBROVERLAPS', parent=current)
        self.exit_rule(current)
        return current
    MBROVERLAPS.min_depth = 0

    @depthcontrol
    def MBRTOUCHES(self, parent=None):
        current = UnlexerRule(name='MBRTOUCHES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MBRTOUCHES', parent=current)
        self.exit_rule(current)
        return current
    MBRTOUCHES.min_depth = 0

    @depthcontrol
    def MBRWITHIN(self, parent=None):
        current = UnlexerRule(name='MBRWITHIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MBRWITHIN', parent=current)
        self.exit_rule(current)
        return current
    MBRWITHIN.min_depth = 0

    @depthcontrol
    def MD5(self, parent=None):
        current = UnlexerRule(name='MD5', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MD5', parent=current)
        self.exit_rule(current)
        return current
    MD5.min_depth = 0

    @depthcontrol
    def MLINEFROMTEXT(self, parent=None):
        current = UnlexerRule(name='MLINEFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MLINEFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    MLINEFROMTEXT.min_depth = 0

    @depthcontrol
    def MLINEFROMWKB(self, parent=None):
        current = UnlexerRule(name='MLINEFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MLINEFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    MLINEFROMWKB.min_depth = 0

    @depthcontrol
    def MONTHNAME(self, parent=None):
        current = UnlexerRule(name='MONTHNAME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MONTHNAME', parent=current)
        self.exit_rule(current)
        return current
    MONTHNAME.min_depth = 0

    @depthcontrol
    def MPOINTFROMTEXT(self, parent=None):
        current = UnlexerRule(name='MPOINTFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MPOINTFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    MPOINTFROMTEXT.min_depth = 0

    @depthcontrol
    def MPOINTFROMWKB(self, parent=None):
        current = UnlexerRule(name='MPOINTFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MPOINTFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    MPOINTFROMWKB.min_depth = 0

    @depthcontrol
    def MPOLYFROMTEXT(self, parent=None):
        current = UnlexerRule(name='MPOLYFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MPOLYFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    MPOLYFROMTEXT.min_depth = 0

    @depthcontrol
    def MPOLYFROMWKB(self, parent=None):
        current = UnlexerRule(name='MPOLYFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MPOLYFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    MPOLYFROMWKB.min_depth = 0

    @depthcontrol
    def MULTILINESTRINGFROMTEXT(self, parent=None):
        current = UnlexerRule(name='MULTILINESTRINGFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MULTILINESTRINGFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    MULTILINESTRINGFROMTEXT.min_depth = 0

    @depthcontrol
    def MULTILINESTRINGFROMWKB(self, parent=None):
        current = UnlexerRule(name='MULTILINESTRINGFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MULTILINESTRINGFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    MULTILINESTRINGFROMWKB.min_depth = 0

    @depthcontrol
    def MULTIPOINTFROMTEXT(self, parent=None):
        current = UnlexerRule(name='MULTIPOINTFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MULTIPOINTFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    MULTIPOINTFROMTEXT.min_depth = 0

    @depthcontrol
    def MULTIPOINTFROMWKB(self, parent=None):
        current = UnlexerRule(name='MULTIPOINTFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MULTIPOINTFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    MULTIPOINTFROMWKB.min_depth = 0

    @depthcontrol
    def MULTIPOLYGONFROMTEXT(self, parent=None):
        current = UnlexerRule(name='MULTIPOLYGONFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MULTIPOLYGONFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    MULTIPOLYGONFROMTEXT.min_depth = 0

    @depthcontrol
    def MULTIPOLYGONFROMWKB(self, parent=None):
        current = UnlexerRule(name='MULTIPOLYGONFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MULTIPOLYGONFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    MULTIPOLYGONFROMWKB.min_depth = 0

    @depthcontrol
    def NAME_CONST(self, parent=None):
        current = UnlexerRule(name='NAME_CONST', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NAME_CONST', parent=current)
        self.exit_rule(current)
        return current
    NAME_CONST.min_depth = 0

    @depthcontrol
    def NULLIF(self, parent=None):
        current = UnlexerRule(name='NULLIF', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NULLIF', parent=current)
        self.exit_rule(current)
        return current
    NULLIF.min_depth = 0

    @depthcontrol
    def NUMGEOMETRIES(self, parent=None):
        current = UnlexerRule(name='NUMGEOMETRIES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NUMGEOMETRIES', parent=current)
        self.exit_rule(current)
        return current
    NUMGEOMETRIES.min_depth = 0

    @depthcontrol
    def NUMINTERIORRINGS(self, parent=None):
        current = UnlexerRule(name='NUMINTERIORRINGS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NUMINTERIORRINGS', parent=current)
        self.exit_rule(current)
        return current
    NUMINTERIORRINGS.min_depth = 0

    @depthcontrol
    def NUMPOINTS(self, parent=None):
        current = UnlexerRule(name='NUMPOINTS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NUMPOINTS', parent=current)
        self.exit_rule(current)
        return current
    NUMPOINTS.min_depth = 0

    @depthcontrol
    def OCT(self, parent=None):
        current = UnlexerRule(name='OCT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OCT', parent=current)
        self.exit_rule(current)
        return current
    OCT.min_depth = 0

    @depthcontrol
    def OCTET_LENGTH(self, parent=None):
        current = UnlexerRule(name='OCTET_LENGTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OCTET_LENGTH', parent=current)
        self.exit_rule(current)
        return current
    OCTET_LENGTH.min_depth = 0

    @depthcontrol
    def ORD(self, parent=None):
        current = UnlexerRule(name='ORD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ORD', parent=current)
        self.exit_rule(current)
        return current
    ORD.min_depth = 0

    @depthcontrol
    def OVERLAPS(self, parent=None):
        current = UnlexerRule(name='OVERLAPS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='OVERLAPS', parent=current)
        self.exit_rule(current)
        return current
    OVERLAPS.min_depth = 0

    @depthcontrol
    def PERIOD_ADD(self, parent=None):
        current = UnlexerRule(name='PERIOD_ADD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PERIOD_ADD', parent=current)
        self.exit_rule(current)
        return current
    PERIOD_ADD.min_depth = 0

    @depthcontrol
    def PERIOD_DIFF(self, parent=None):
        current = UnlexerRule(name='PERIOD_DIFF', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PERIOD_DIFF', parent=current)
        self.exit_rule(current)
        return current
    PERIOD_DIFF.min_depth = 0

    @depthcontrol
    def PI(self, parent=None):
        current = UnlexerRule(name='PI', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PI', parent=current)
        self.exit_rule(current)
        return current
    PI.min_depth = 0

    @depthcontrol
    def POINTFROMTEXT(self, parent=None):
        current = UnlexerRule(name='POINTFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='POINTFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    POINTFROMTEXT.min_depth = 0

    @depthcontrol
    def POINTFROMWKB(self, parent=None):
        current = UnlexerRule(name='POINTFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='POINTFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    POINTFROMWKB.min_depth = 0

    @depthcontrol
    def POINTN(self, parent=None):
        current = UnlexerRule(name='POINTN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='POINTN', parent=current)
        self.exit_rule(current)
        return current
    POINTN.min_depth = 0

    @depthcontrol
    def POLYFROMTEXT(self, parent=None):
        current = UnlexerRule(name='POLYFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='POLYFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    POLYFROMTEXT.min_depth = 0

    @depthcontrol
    def POLYFROMWKB(self, parent=None):
        current = UnlexerRule(name='POLYFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='POLYFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    POLYFROMWKB.min_depth = 0

    @depthcontrol
    def POLYGONFROMTEXT(self, parent=None):
        current = UnlexerRule(name='POLYGONFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='POLYGONFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    POLYGONFROMTEXT.min_depth = 0

    @depthcontrol
    def POLYGONFROMWKB(self, parent=None):
        current = UnlexerRule(name='POLYGONFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='POLYGONFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    POLYGONFROMWKB.min_depth = 0

    @depthcontrol
    def POW(self, parent=None):
        current = UnlexerRule(name='POW', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='POW', parent=current)
        self.exit_rule(current)
        return current
    POW.min_depth = 0

    @depthcontrol
    def POWER(self, parent=None):
        current = UnlexerRule(name='POWER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='POWER', parent=current)
        self.exit_rule(current)
        return current
    POWER.min_depth = 0

    @depthcontrol
    def QUOTE(self, parent=None):
        current = UnlexerRule(name='QUOTE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='QUOTE', parent=current)
        self.exit_rule(current)
        return current
    QUOTE.min_depth = 0

    @depthcontrol
    def RADIANS(self, parent=None):
        current = UnlexerRule(name='RADIANS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RADIANS', parent=current)
        self.exit_rule(current)
        return current
    RADIANS.min_depth = 0

    @depthcontrol
    def RAND(self, parent=None):
        current = UnlexerRule(name='RAND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RAND', parent=current)
        self.exit_rule(current)
        return current
    RAND.min_depth = 0

    @depthcontrol
    def RANDOM_BYTES(self, parent=None):
        current = UnlexerRule(name='RANDOM_BYTES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RANDOM_BYTES', parent=current)
        self.exit_rule(current)
        return current
    RANDOM_BYTES.min_depth = 0

    @depthcontrol
    def RELEASE_LOCK(self, parent=None):
        current = UnlexerRule(name='RELEASE_LOCK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RELEASE_LOCK', parent=current)
        self.exit_rule(current)
        return current
    RELEASE_LOCK.min_depth = 0

    @depthcontrol
    def REVERSE(self, parent=None):
        current = UnlexerRule(name='REVERSE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='REVERSE', parent=current)
        self.exit_rule(current)
        return current
    REVERSE.min_depth = 0

    @depthcontrol
    def ROUND(self, parent=None):
        current = UnlexerRule(name='ROUND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ROUND', parent=current)
        self.exit_rule(current)
        return current
    ROUND.min_depth = 0

    @depthcontrol
    def ROW_COUNT(self, parent=None):
        current = UnlexerRule(name='ROW_COUNT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ROW_COUNT', parent=current)
        self.exit_rule(current)
        return current
    ROW_COUNT.min_depth = 0

    @depthcontrol
    def RPAD(self, parent=None):
        current = UnlexerRule(name='RPAD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RPAD', parent=current)
        self.exit_rule(current)
        return current
    RPAD.min_depth = 0

    @depthcontrol
    def RTRIM(self, parent=None):
        current = UnlexerRule(name='RTRIM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RTRIM', parent=current)
        self.exit_rule(current)
        return current
    RTRIM.min_depth = 0

    @depthcontrol
    def SEC_TO_TIME(self, parent=None):
        current = UnlexerRule(name='SEC_TO_TIME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SEC_TO_TIME', parent=current)
        self.exit_rule(current)
        return current
    SEC_TO_TIME.min_depth = 0

    @depthcontrol
    def SESSION_USER(self, parent=None):
        current = UnlexerRule(name='SESSION_USER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SESSION_USER', parent=current)
        self.exit_rule(current)
        return current
    SESSION_USER.min_depth = 0

    @depthcontrol
    def SHA(self, parent=None):
        current = UnlexerRule(name='SHA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SHA', parent=current)
        self.exit_rule(current)
        return current
    SHA.min_depth = 0

    @depthcontrol
    def SHA1(self, parent=None):
        current = UnlexerRule(name='SHA1', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SHA1', parent=current)
        self.exit_rule(current)
        return current
    SHA1.min_depth = 0

    @depthcontrol
    def SHA2(self, parent=None):
        current = UnlexerRule(name='SHA2', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SHA2', parent=current)
        self.exit_rule(current)
        return current
    SHA2.min_depth = 0

    @depthcontrol
    def SCHEMA_NAME(self, parent=None):
        current = UnlexerRule(name='SCHEMA_NAME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SCHEMA_NAME', parent=current)
        self.exit_rule(current)
        return current
    SCHEMA_NAME.min_depth = 0

    @depthcontrol
    def SIGN(self, parent=None):
        current = UnlexerRule(name='SIGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SIGN', parent=current)
        self.exit_rule(current)
        return current
    SIGN.min_depth = 0

    @depthcontrol
    def SIN(self, parent=None):
        current = UnlexerRule(name='SIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SIN', parent=current)
        self.exit_rule(current)
        return current
    SIN.min_depth = 0

    @depthcontrol
    def SLEEP(self, parent=None):
        current = UnlexerRule(name='SLEEP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SLEEP', parent=current)
        self.exit_rule(current)
        return current
    SLEEP.min_depth = 0

    @depthcontrol
    def SOUNDEX(self, parent=None):
        current = UnlexerRule(name='SOUNDEX', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SOUNDEX', parent=current)
        self.exit_rule(current)
        return current
    SOUNDEX.min_depth = 0

    @depthcontrol
    def SQL_THREAD_WAIT_AFTER_GTIDS(self, parent=None):
        current = UnlexerRule(name='SQL_THREAD_WAIT_AFTER_GTIDS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQL_THREAD_WAIT_AFTER_GTIDS', parent=current)
        self.exit_rule(current)
        return current
    SQL_THREAD_WAIT_AFTER_GTIDS.min_depth = 0

    @depthcontrol
    def SQRT(self, parent=None):
        current = UnlexerRule(name='SQRT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SQRT', parent=current)
        self.exit_rule(current)
        return current
    SQRT.min_depth = 0

    @depthcontrol
    def SRID(self, parent=None):
        current = UnlexerRule(name='SRID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SRID', parent=current)
        self.exit_rule(current)
        return current
    SRID.min_depth = 0

    @depthcontrol
    def STARTPOINT(self, parent=None):
        current = UnlexerRule(name='STARTPOINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STARTPOINT', parent=current)
        self.exit_rule(current)
        return current
    STARTPOINT.min_depth = 0

    @depthcontrol
    def STRCMP(self, parent=None):
        current = UnlexerRule(name='STRCMP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STRCMP', parent=current)
        self.exit_rule(current)
        return current
    STRCMP.min_depth = 0

    @depthcontrol
    def STR_TO_DATE(self, parent=None):
        current = UnlexerRule(name='STR_TO_DATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STR_TO_DATE', parent=current)
        self.exit_rule(current)
        return current
    STR_TO_DATE.min_depth = 0

    @depthcontrol
    def ST_AREA(self, parent=None):
        current = UnlexerRule(name='ST_AREA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_AREA', parent=current)
        self.exit_rule(current)
        return current
    ST_AREA.min_depth = 0

    @depthcontrol
    def ST_ASBINARY(self, parent=None):
        current = UnlexerRule(name='ST_ASBINARY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_ASBINARY', parent=current)
        self.exit_rule(current)
        return current
    ST_ASBINARY.min_depth = 0

    @depthcontrol
    def ST_ASTEXT(self, parent=None):
        current = UnlexerRule(name='ST_ASTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_ASTEXT', parent=current)
        self.exit_rule(current)
        return current
    ST_ASTEXT.min_depth = 0

    @depthcontrol
    def ST_ASWKB(self, parent=None):
        current = UnlexerRule(name='ST_ASWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_ASWKB', parent=current)
        self.exit_rule(current)
        return current
    ST_ASWKB.min_depth = 0

    @depthcontrol
    def ST_ASWKT(self, parent=None):
        current = UnlexerRule(name='ST_ASWKT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_ASWKT', parent=current)
        self.exit_rule(current)
        return current
    ST_ASWKT.min_depth = 0

    @depthcontrol
    def ST_BUFFER(self, parent=None):
        current = UnlexerRule(name='ST_BUFFER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_BUFFER', parent=current)
        self.exit_rule(current)
        return current
    ST_BUFFER.min_depth = 0

    @depthcontrol
    def ST_CENTROID(self, parent=None):
        current = UnlexerRule(name='ST_CENTROID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_CENTROID', parent=current)
        self.exit_rule(current)
        return current
    ST_CENTROID.min_depth = 0

    @depthcontrol
    def ST_CONTAINS(self, parent=None):
        current = UnlexerRule(name='ST_CONTAINS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_CONTAINS', parent=current)
        self.exit_rule(current)
        return current
    ST_CONTAINS.min_depth = 0

    @depthcontrol
    def ST_CROSSES(self, parent=None):
        current = UnlexerRule(name='ST_CROSSES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_CROSSES', parent=current)
        self.exit_rule(current)
        return current
    ST_CROSSES.min_depth = 0

    @depthcontrol
    def ST_DIFFERENCE(self, parent=None):
        current = UnlexerRule(name='ST_DIFFERENCE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_DIFFERENCE', parent=current)
        self.exit_rule(current)
        return current
    ST_DIFFERENCE.min_depth = 0

    @depthcontrol
    def ST_DIMENSION(self, parent=None):
        current = UnlexerRule(name='ST_DIMENSION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_DIMENSION', parent=current)
        self.exit_rule(current)
        return current
    ST_DIMENSION.min_depth = 0

    @depthcontrol
    def ST_DISJOINT(self, parent=None):
        current = UnlexerRule(name='ST_DISJOINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_DISJOINT', parent=current)
        self.exit_rule(current)
        return current
    ST_DISJOINT.min_depth = 0

    @depthcontrol
    def ST_DISTANCE(self, parent=None):
        current = UnlexerRule(name='ST_DISTANCE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_DISTANCE', parent=current)
        self.exit_rule(current)
        return current
    ST_DISTANCE.min_depth = 0

    @depthcontrol
    def ST_ENDPOINT(self, parent=None):
        current = UnlexerRule(name='ST_ENDPOINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_ENDPOINT', parent=current)
        self.exit_rule(current)
        return current
    ST_ENDPOINT.min_depth = 0

    @depthcontrol
    def ST_ENVELOPE(self, parent=None):
        current = UnlexerRule(name='ST_ENVELOPE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_ENVELOPE', parent=current)
        self.exit_rule(current)
        return current
    ST_ENVELOPE.min_depth = 0

    @depthcontrol
    def ST_EQUALS(self, parent=None):
        current = UnlexerRule(name='ST_EQUALS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_EQUALS', parent=current)
        self.exit_rule(current)
        return current
    ST_EQUALS.min_depth = 0

    @depthcontrol
    def ST_EXTERIORRING(self, parent=None):
        current = UnlexerRule(name='ST_EXTERIORRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_EXTERIORRING', parent=current)
        self.exit_rule(current)
        return current
    ST_EXTERIORRING.min_depth = 0

    @depthcontrol
    def ST_GEOMCOLLFROMTEXT(self, parent=None):
        current = UnlexerRule(name='ST_GEOMCOLLFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_GEOMCOLLFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    ST_GEOMCOLLFROMTEXT.min_depth = 0

    @depthcontrol
    def ST_GEOMCOLLFROMTXT(self, parent=None):
        current = UnlexerRule(name='ST_GEOMCOLLFROMTXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_GEOMCOLLFROMTXT', parent=current)
        self.exit_rule(current)
        return current
    ST_GEOMCOLLFROMTXT.min_depth = 0

    @depthcontrol
    def ST_GEOMCOLLFROMWKB(self, parent=None):
        current = UnlexerRule(name='ST_GEOMCOLLFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_GEOMCOLLFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    ST_GEOMCOLLFROMWKB.min_depth = 0

    @depthcontrol
    def ST_GEOMETRYCOLLECTIONFROMTEXT(self, parent=None):
        current = UnlexerRule(name='ST_GEOMETRYCOLLECTIONFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_GEOMETRYCOLLECTIONFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    ST_GEOMETRYCOLLECTIONFROMTEXT.min_depth = 0

    @depthcontrol
    def ST_GEOMETRYCOLLECTIONFROMWKB(self, parent=None):
        current = UnlexerRule(name='ST_GEOMETRYCOLLECTIONFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_GEOMETRYCOLLECTIONFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    ST_GEOMETRYCOLLECTIONFROMWKB.min_depth = 0

    @depthcontrol
    def ST_GEOMETRYFROMTEXT(self, parent=None):
        current = UnlexerRule(name='ST_GEOMETRYFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_GEOMETRYFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    ST_GEOMETRYFROMTEXT.min_depth = 0

    @depthcontrol
    def ST_GEOMETRYFROMWKB(self, parent=None):
        current = UnlexerRule(name='ST_GEOMETRYFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_GEOMETRYFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    ST_GEOMETRYFROMWKB.min_depth = 0

    @depthcontrol
    def ST_GEOMETRYN(self, parent=None):
        current = UnlexerRule(name='ST_GEOMETRYN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_GEOMETRYN', parent=current)
        self.exit_rule(current)
        return current
    ST_GEOMETRYN.min_depth = 0

    @depthcontrol
    def ST_GEOMETRYTYPE(self, parent=None):
        current = UnlexerRule(name='ST_GEOMETRYTYPE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_GEOMETRYTYPE', parent=current)
        self.exit_rule(current)
        return current
    ST_GEOMETRYTYPE.min_depth = 0

    @depthcontrol
    def ST_GEOMFROMTEXT(self, parent=None):
        current = UnlexerRule(name='ST_GEOMFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_GEOMFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    ST_GEOMFROMTEXT.min_depth = 0

    @depthcontrol
    def ST_GEOMFROMWKB(self, parent=None):
        current = UnlexerRule(name='ST_GEOMFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_GEOMFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    ST_GEOMFROMWKB.min_depth = 0

    @depthcontrol
    def ST_INTERIORRINGN(self, parent=None):
        current = UnlexerRule(name='ST_INTERIORRINGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_INTERIORRINGN', parent=current)
        self.exit_rule(current)
        return current
    ST_INTERIORRINGN.min_depth = 0

    @depthcontrol
    def ST_INTERSECTION(self, parent=None):
        current = UnlexerRule(name='ST_INTERSECTION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_INTERSECTION', parent=current)
        self.exit_rule(current)
        return current
    ST_INTERSECTION.min_depth = 0

    @depthcontrol
    def ST_INTERSECTS(self, parent=None):
        current = UnlexerRule(name='ST_INTERSECTS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_INTERSECTS', parent=current)
        self.exit_rule(current)
        return current
    ST_INTERSECTS.min_depth = 0

    @depthcontrol
    def ST_ISCLOSED(self, parent=None):
        current = UnlexerRule(name='ST_ISCLOSED', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_ISCLOSED', parent=current)
        self.exit_rule(current)
        return current
    ST_ISCLOSED.min_depth = 0

    @depthcontrol
    def ST_ISEMPTY(self, parent=None):
        current = UnlexerRule(name='ST_ISEMPTY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_ISEMPTY', parent=current)
        self.exit_rule(current)
        return current
    ST_ISEMPTY.min_depth = 0

    @depthcontrol
    def ST_ISSIMPLE(self, parent=None):
        current = UnlexerRule(name='ST_ISSIMPLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_ISSIMPLE', parent=current)
        self.exit_rule(current)
        return current
    ST_ISSIMPLE.min_depth = 0

    @depthcontrol
    def ST_LINEFROMTEXT(self, parent=None):
        current = UnlexerRule(name='ST_LINEFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_LINEFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    ST_LINEFROMTEXT.min_depth = 0

    @depthcontrol
    def ST_LINEFROMWKB(self, parent=None):
        current = UnlexerRule(name='ST_LINEFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_LINEFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    ST_LINEFROMWKB.min_depth = 0

    @depthcontrol
    def ST_LINESTRINGFROMTEXT(self, parent=None):
        current = UnlexerRule(name='ST_LINESTRINGFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_LINESTRINGFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    ST_LINESTRINGFROMTEXT.min_depth = 0

    @depthcontrol
    def ST_LINESTRINGFROMWKB(self, parent=None):
        current = UnlexerRule(name='ST_LINESTRINGFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_LINESTRINGFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    ST_LINESTRINGFROMWKB.min_depth = 0

    @depthcontrol
    def ST_NUMGEOMETRIES(self, parent=None):
        current = UnlexerRule(name='ST_NUMGEOMETRIES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_NUMGEOMETRIES', parent=current)
        self.exit_rule(current)
        return current
    ST_NUMGEOMETRIES.min_depth = 0

    @depthcontrol
    def ST_NUMINTERIORRING(self, parent=None):
        current = UnlexerRule(name='ST_NUMINTERIORRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_NUMINTERIORRING', parent=current)
        self.exit_rule(current)
        return current
    ST_NUMINTERIORRING.min_depth = 0

    @depthcontrol
    def ST_NUMINTERIORRINGS(self, parent=None):
        current = UnlexerRule(name='ST_NUMINTERIORRINGS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_NUMINTERIORRINGS', parent=current)
        self.exit_rule(current)
        return current
    ST_NUMINTERIORRINGS.min_depth = 0

    @depthcontrol
    def ST_NUMPOINTS(self, parent=None):
        current = UnlexerRule(name='ST_NUMPOINTS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_NUMPOINTS', parent=current)
        self.exit_rule(current)
        return current
    ST_NUMPOINTS.min_depth = 0

    @depthcontrol
    def ST_OVERLAPS(self, parent=None):
        current = UnlexerRule(name='ST_OVERLAPS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_OVERLAPS', parent=current)
        self.exit_rule(current)
        return current
    ST_OVERLAPS.min_depth = 0

    @depthcontrol
    def ST_POINTFROMTEXT(self, parent=None):
        current = UnlexerRule(name='ST_POINTFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_POINTFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    ST_POINTFROMTEXT.min_depth = 0

    @depthcontrol
    def ST_POINTFROMWKB(self, parent=None):
        current = UnlexerRule(name='ST_POINTFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_POINTFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    ST_POINTFROMWKB.min_depth = 0

    @depthcontrol
    def ST_POINTN(self, parent=None):
        current = UnlexerRule(name='ST_POINTN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_POINTN', parent=current)
        self.exit_rule(current)
        return current
    ST_POINTN.min_depth = 0

    @depthcontrol
    def ST_POLYFROMTEXT(self, parent=None):
        current = UnlexerRule(name='ST_POLYFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_POLYFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    ST_POLYFROMTEXT.min_depth = 0

    @depthcontrol
    def ST_POLYFROMWKB(self, parent=None):
        current = UnlexerRule(name='ST_POLYFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_POLYFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    ST_POLYFROMWKB.min_depth = 0

    @depthcontrol
    def ST_POLYGONFROMTEXT(self, parent=None):
        current = UnlexerRule(name='ST_POLYGONFROMTEXT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_POLYGONFROMTEXT', parent=current)
        self.exit_rule(current)
        return current
    ST_POLYGONFROMTEXT.min_depth = 0

    @depthcontrol
    def ST_POLYGONFROMWKB(self, parent=None):
        current = UnlexerRule(name='ST_POLYGONFROMWKB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_POLYGONFROMWKB', parent=current)
        self.exit_rule(current)
        return current
    ST_POLYGONFROMWKB.min_depth = 0

    @depthcontrol
    def ST_SRID(self, parent=None):
        current = UnlexerRule(name='ST_SRID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_SRID', parent=current)
        self.exit_rule(current)
        return current
    ST_SRID.min_depth = 0

    @depthcontrol
    def ST_STARTPOINT(self, parent=None):
        current = UnlexerRule(name='ST_STARTPOINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_STARTPOINT', parent=current)
        self.exit_rule(current)
        return current
    ST_STARTPOINT.min_depth = 0

    @depthcontrol
    def ST_SYMDIFFERENCE(self, parent=None):
        current = UnlexerRule(name='ST_SYMDIFFERENCE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_SYMDIFFERENCE', parent=current)
        self.exit_rule(current)
        return current
    ST_SYMDIFFERENCE.min_depth = 0

    @depthcontrol
    def ST_TOUCHES(self, parent=None):
        current = UnlexerRule(name='ST_TOUCHES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_TOUCHES', parent=current)
        self.exit_rule(current)
        return current
    ST_TOUCHES.min_depth = 0

    @depthcontrol
    def ST_UNION(self, parent=None):
        current = UnlexerRule(name='ST_UNION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_UNION', parent=current)
        self.exit_rule(current)
        return current
    ST_UNION.min_depth = 0

    @depthcontrol
    def ST_WITHIN(self, parent=None):
        current = UnlexerRule(name='ST_WITHIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_WITHIN', parent=current)
        self.exit_rule(current)
        return current
    ST_WITHIN.min_depth = 0

    @depthcontrol
    def ST_X(self, parent=None):
        current = UnlexerRule(name='ST_X', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_X', parent=current)
        self.exit_rule(current)
        return current
    ST_X.min_depth = 0

    @depthcontrol
    def ST_Y(self, parent=None):
        current = UnlexerRule(name='ST_Y', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='ST_Y', parent=current)
        self.exit_rule(current)
        return current
    ST_Y.min_depth = 0

    @depthcontrol
    def SUBDATE(self, parent=None):
        current = UnlexerRule(name='SUBDATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SUBDATE', parent=current)
        self.exit_rule(current)
        return current
    SUBDATE.min_depth = 0

    @depthcontrol
    def SUBSTRING_INDEX(self, parent=None):
        current = UnlexerRule(name='SUBSTRING_INDEX', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SUBSTRING_INDEX', parent=current)
        self.exit_rule(current)
        return current
    SUBSTRING_INDEX.min_depth = 0

    @depthcontrol
    def SUBTIME(self, parent=None):
        current = UnlexerRule(name='SUBTIME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SUBTIME', parent=current)
        self.exit_rule(current)
        return current
    SUBTIME.min_depth = 0

    @depthcontrol
    def SYSTEM_USER(self, parent=None):
        current = UnlexerRule(name='SYSTEM_USER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SYSTEM_USER', parent=current)
        self.exit_rule(current)
        return current
    SYSTEM_USER.min_depth = 0

    @depthcontrol
    def TAN(self, parent=None):
        current = UnlexerRule(name='TAN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TAN', parent=current)
        self.exit_rule(current)
        return current
    TAN.min_depth = 0

    @depthcontrol
    def TIMEDIFF(self, parent=None):
        current = UnlexerRule(name='TIMEDIFF', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TIMEDIFF', parent=current)
        self.exit_rule(current)
        return current
    TIMEDIFF.min_depth = 0

    @depthcontrol
    def TIMESTAMPADD(self, parent=None):
        current = UnlexerRule(name='TIMESTAMPADD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TIMESTAMPADD', parent=current)
        self.exit_rule(current)
        return current
    TIMESTAMPADD.min_depth = 0

    @depthcontrol
    def TIMESTAMPDIFF(self, parent=None):
        current = UnlexerRule(name='TIMESTAMPDIFF', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TIMESTAMPDIFF', parent=current)
        self.exit_rule(current)
        return current
    TIMESTAMPDIFF.min_depth = 0

    @depthcontrol
    def TIME_FORMAT(self, parent=None):
        current = UnlexerRule(name='TIME_FORMAT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TIME_FORMAT', parent=current)
        self.exit_rule(current)
        return current
    TIME_FORMAT.min_depth = 0

    @depthcontrol
    def TIME_TO_SEC(self, parent=None):
        current = UnlexerRule(name='TIME_TO_SEC', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TIME_TO_SEC', parent=current)
        self.exit_rule(current)
        return current
    TIME_TO_SEC.min_depth = 0

    @depthcontrol
    def TOUCHES(self, parent=None):
        current = UnlexerRule(name='TOUCHES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TOUCHES', parent=current)
        self.exit_rule(current)
        return current
    TOUCHES.min_depth = 0

    @depthcontrol
    def TO_BASE64(self, parent=None):
        current = UnlexerRule(name='TO_BASE64', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TO_BASE64', parent=current)
        self.exit_rule(current)
        return current
    TO_BASE64.min_depth = 0

    @depthcontrol
    def TO_DAYS(self, parent=None):
        current = UnlexerRule(name='TO_DAYS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TO_DAYS', parent=current)
        self.exit_rule(current)
        return current
    TO_DAYS.min_depth = 0

    @depthcontrol
    def TO_SECONDS(self, parent=None):
        current = UnlexerRule(name='TO_SECONDS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='TO_SECONDS', parent=current)
        self.exit_rule(current)
        return current
    TO_SECONDS.min_depth = 0

    @depthcontrol
    def UCASE(self, parent=None):
        current = UnlexerRule(name='UCASE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UCASE', parent=current)
        self.exit_rule(current)
        return current
    UCASE.min_depth = 0

    @depthcontrol
    def UNCOMPRESS(self, parent=None):
        current = UnlexerRule(name='UNCOMPRESS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNCOMPRESS', parent=current)
        self.exit_rule(current)
        return current
    UNCOMPRESS.min_depth = 0

    @depthcontrol
    def UNCOMPRESSED_LENGTH(self, parent=None):
        current = UnlexerRule(name='UNCOMPRESSED_LENGTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNCOMPRESSED_LENGTH', parent=current)
        self.exit_rule(current)
        return current
    UNCOMPRESSED_LENGTH.min_depth = 0

    @depthcontrol
    def UNHEX(self, parent=None):
        current = UnlexerRule(name='UNHEX', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNHEX', parent=current)
        self.exit_rule(current)
        return current
    UNHEX.min_depth = 0

    @depthcontrol
    def UNIX_TIMESTAMP(self, parent=None):
        current = UnlexerRule(name='UNIX_TIMESTAMP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UNIX_TIMESTAMP', parent=current)
        self.exit_rule(current)
        return current
    UNIX_TIMESTAMP.min_depth = 0

    @depthcontrol
    def UPDATEXML(self, parent=None):
        current = UnlexerRule(name='UPDATEXML', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UPDATEXML', parent=current)
        self.exit_rule(current)
        return current
    UPDATEXML.min_depth = 0

    @depthcontrol
    def UPPER(self, parent=None):
        current = UnlexerRule(name='UPPER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UPPER', parent=current)
        self.exit_rule(current)
        return current
    UPPER.min_depth = 0

    @depthcontrol
    def UUID(self, parent=None):
        current = UnlexerRule(name='UUID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UUID', parent=current)
        self.exit_rule(current)
        return current
    UUID.min_depth = 0

    @depthcontrol
    def UUID_SHORT(self, parent=None):
        current = UnlexerRule(name='UUID_SHORT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='UUID_SHORT', parent=current)
        self.exit_rule(current)
        return current
    UUID_SHORT.min_depth = 0

    @depthcontrol
    def VALIDATE_PASSWORD_STRENGTH(self, parent=None):
        current = UnlexerRule(name='VALIDATE_PASSWORD_STRENGTH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VALIDATE_PASSWORD_STRENGTH', parent=current)
        self.exit_rule(current)
        return current
    VALIDATE_PASSWORD_STRENGTH.min_depth = 0

    @depthcontrol
    def VERSION(self, parent=None):
        current = UnlexerRule(name='VERSION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='VERSION', parent=current)
        self.exit_rule(current)
        return current
    VERSION.min_depth = 0

    @depthcontrol
    def WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS(self, parent=None):
        current = UnlexerRule(name='WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS', parent=current)
        self.exit_rule(current)
        return current
    WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS.min_depth = 0

    @depthcontrol
    def WEEKDAY(self, parent=None):
        current = UnlexerRule(name='WEEKDAY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WEEKDAY', parent=current)
        self.exit_rule(current)
        return current
    WEEKDAY.min_depth = 0

    @depthcontrol
    def WEEKOFYEAR(self, parent=None):
        current = UnlexerRule(name='WEEKOFYEAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WEEKOFYEAR', parent=current)
        self.exit_rule(current)
        return current
    WEEKOFYEAR.min_depth = 0

    @depthcontrol
    def WEIGHT_STRING(self, parent=None):
        current = UnlexerRule(name='WEIGHT_STRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WEIGHT_STRING', parent=current)
        self.exit_rule(current)
        return current
    WEIGHT_STRING.min_depth = 0

    @depthcontrol
    def WITHIN(self, parent=None):
        current = UnlexerRule(name='WITHIN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WITHIN', parent=current)
        self.exit_rule(current)
        return current
    WITHIN.min_depth = 0

    @depthcontrol
    def YEARWEEK(self, parent=None):
        current = UnlexerRule(name='YEARWEEK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='YEARWEEK', parent=current)
        self.exit_rule(current)
        return current
    YEARWEEK.min_depth = 0

    @depthcontrol
    def Y_FUNCTION(self, parent=None):
        current = UnlexerRule(name='Y_FUNCTION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='Y', parent=current)
        self.exit_rule(current)
        return current
    Y_FUNCTION.min_depth = 0

    @depthcontrol
    def X_FUNCTION(self, parent=None):
        current = UnlexerRule(name='X_FUNCTION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='X', parent=current)
        self.exit_rule(current)
        return current
    X_FUNCTION.min_depth = 0

    @depthcontrol
    def VAR_ASSIGN(self, parent=None):
        current = UnlexerRule(name='VAR_ASSIGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=':=', parent=current)
        self.exit_rule(current)
        return current
    VAR_ASSIGN.min_depth = 0

    @depthcontrol
    def PLUS_ASSIGN(self, parent=None):
        current = UnlexerRule(name='PLUS_ASSIGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='+=', parent=current)
        self.exit_rule(current)
        return current
    PLUS_ASSIGN.min_depth = 0

    @depthcontrol
    def MINUS_ASSIGN(self, parent=None):
        current = UnlexerRule(name='MINUS_ASSIGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='-=', parent=current)
        self.exit_rule(current)
        return current
    MINUS_ASSIGN.min_depth = 0

    @depthcontrol
    def MULT_ASSIGN(self, parent=None):
        current = UnlexerRule(name='MULT_ASSIGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='*=', parent=current)
        self.exit_rule(current)
        return current
    MULT_ASSIGN.min_depth = 0

    @depthcontrol
    def DIV_ASSIGN(self, parent=None):
        current = UnlexerRule(name='DIV_ASSIGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='/=', parent=current)
        self.exit_rule(current)
        return current
    DIV_ASSIGN.min_depth = 0

    @depthcontrol
    def MOD_ASSIGN(self, parent=None):
        current = UnlexerRule(name='MOD_ASSIGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='%=', parent=current)
        self.exit_rule(current)
        return current
    MOD_ASSIGN.min_depth = 0

    @depthcontrol
    def AND_ASSIGN(self, parent=None):
        current = UnlexerRule(name='AND_ASSIGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='&=', parent=current)
        self.exit_rule(current)
        return current
    AND_ASSIGN.min_depth = 0

    @depthcontrol
    def XOR_ASSIGN(self, parent=None):
        current = UnlexerRule(name='XOR_ASSIGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='^=', parent=current)
        self.exit_rule(current)
        return current
    XOR_ASSIGN.min_depth = 0

    @depthcontrol
    def OR_ASSIGN(self, parent=None):
        current = UnlexerRule(name='OR_ASSIGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='|=', parent=current)
        self.exit_rule(current)
        return current
    OR_ASSIGN.min_depth = 0

    @depthcontrol
    def STAR(self, parent=None):
        current = UnlexerRule(name='STAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='*', parent=current)
        self.exit_rule(current)
        return current
    STAR.min_depth = 0

    @depthcontrol
    def DIVIDE(self, parent=None):
        current = UnlexerRule(name='DIVIDE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='/', parent=current)
        self.exit_rule(current)
        return current
    DIVIDE.min_depth = 0

    @depthcontrol
    def MODULE(self, parent=None):
        current = UnlexerRule(name='MODULE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='%', parent=current)
        self.exit_rule(current)
        return current
    MODULE.min_depth = 0

    @depthcontrol
    def PLUS(self, parent=None):
        current = UnlexerRule(name='PLUS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='+', parent=current)
        self.exit_rule(current)
        return current
    PLUS.min_depth = 0

    @depthcontrol
    def MINUSMINUS(self, parent=None):
        current = UnlexerRule(name='MINUSMINUS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='--', parent=current)
        self.exit_rule(current)
        return current
    MINUSMINUS.min_depth = 0

    @depthcontrol
    def MINUS(self, parent=None):
        current = UnlexerRule(name='MINUS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='-', parent=current)
        self.exit_rule(current)
        return current
    MINUS.min_depth = 0

    @depthcontrol
    def DIV(self, parent=None):
        current = UnlexerRule(name='DIV', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='DIV', parent=current)
        self.exit_rule(current)
        return current
    DIV.min_depth = 0

    @depthcontrol
    def MOD(self, parent=None):
        current = UnlexerRule(name='MOD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MOD', parent=current)
        self.exit_rule(current)
        return current
    MOD.min_depth = 0

    @depthcontrol
    def EQUAL_SYMBOL(self, parent=None):
        current = UnlexerRule(name='EQUAL_SYMBOL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='=', parent=current)
        self.exit_rule(current)
        return current
    EQUAL_SYMBOL.min_depth = 0

    @depthcontrol
    def GREATER_SYMBOL(self, parent=None):
        current = UnlexerRule(name='GREATER_SYMBOL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='>', parent=current)
        self.exit_rule(current)
        return current
    GREATER_SYMBOL.min_depth = 0

    @depthcontrol
    def LESS_SYMBOL(self, parent=None):
        current = UnlexerRule(name='LESS_SYMBOL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<', parent=current)
        self.exit_rule(current)
        return current
    LESS_SYMBOL.min_depth = 0

    @depthcontrol
    def EXCLAMATION_SYMBOL(self, parent=None):
        current = UnlexerRule(name='EXCLAMATION_SYMBOL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='!', parent=current)
        self.exit_rule(current)
        return current
    EXCLAMATION_SYMBOL.min_depth = 0

    @depthcontrol
    def BIT_NOT_OP(self, parent=None):
        current = UnlexerRule(name='BIT_NOT_OP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='~', parent=current)
        self.exit_rule(current)
        return current
    BIT_NOT_OP.min_depth = 0

    @depthcontrol
    def BIT_OR_OP(self, parent=None):
        current = UnlexerRule(name='BIT_OR_OP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='|', parent=current)
        self.exit_rule(current)
        return current
    BIT_OR_OP.min_depth = 0

    @depthcontrol
    def BIT_AND_OP(self, parent=None):
        current = UnlexerRule(name='BIT_AND_OP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='&', parent=current)
        self.exit_rule(current)
        return current
    BIT_AND_OP.min_depth = 0

    @depthcontrol
    def BIT_XOR_OP(self, parent=None):
        current = UnlexerRule(name='BIT_XOR_OP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='^', parent=current)
        self.exit_rule(current)
        return current
    BIT_XOR_OP.min_depth = 0

    @depthcontrol
    def DOT(self, parent=None):
        current = UnlexerRule(name='DOT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='.', parent=current)
        self.exit_rule(current)
        return current
    DOT.min_depth = 0

    @depthcontrol
    def LR_BRACKET(self, parent=None):
        current = UnlexerRule(name='LR_BRACKET', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.exit_rule(current)
        return current
    LR_BRACKET.min_depth = 0

    @depthcontrol
    def RR_BRACKET(self, parent=None):
        current = UnlexerRule(name='RR_BRACKET', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    RR_BRACKET.min_depth = 0

    @depthcontrol
    def COMMA(self, parent=None):
        current = UnlexerRule(name='COMMA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=',', parent=current)
        self.exit_rule(current)
        return current
    COMMA.min_depth = 0

    @depthcontrol
    def SEMI(self, parent=None):
        current = UnlexerRule(name='SEMI', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=';', parent=current)
        self.exit_rule(current)
        return current
    SEMI.min_depth = 0

    @depthcontrol
    def AT_SIGN(self, parent=None):
        current = UnlexerRule(name='AT_SIGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='@', parent=current)
        self.exit_rule(current)
        return current
    AT_SIGN.min_depth = 0

    @depthcontrol
    def ZERO_DECIMAL(self, parent=None):
        current = UnlexerRule(name='ZERO_DECIMAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='0', parent=current)
        self.exit_rule(current)
        return current
    ZERO_DECIMAL.min_depth = 0

    @depthcontrol
    def ONE_DECIMAL(self, parent=None):
        current = UnlexerRule(name='ONE_DECIMAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='1', parent=current)
        self.exit_rule(current)
        return current
    ONE_DECIMAL.min_depth = 0

    @depthcontrol
    def TWO_DECIMAL(self, parent=None):
        current = UnlexerRule(name='TWO_DECIMAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='2', parent=current)
        self.exit_rule(current)
        return current
    TWO_DECIMAL.min_depth = 0

    @depthcontrol
    def SINGLE_QUOTE_SYMB(self, parent=None):
        current = UnlexerRule(name='SINGLE_QUOTE_SYMB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='\'', parent=current)
        self.exit_rule(current)
        return current
    SINGLE_QUOTE_SYMB.min_depth = 0

    @depthcontrol
    def DOUBLE_QUOTE_SYMB(self, parent=None):
        current = UnlexerRule(name='DOUBLE_QUOTE_SYMB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='"', parent=current)
        self.exit_rule(current)
        return current
    DOUBLE_QUOTE_SYMB.min_depth = 0

    @depthcontrol
    def REVERSE_QUOTE_SYMB(self, parent=None):
        current = UnlexerRule(name='REVERSE_QUOTE_SYMB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='`', parent=current)
        self.exit_rule(current)
        return current
    REVERSE_QUOTE_SYMB.min_depth = 0

    @depthcontrol
    def COLON_SYMB(self, parent=None):
        current = UnlexerRule(name='COLON_SYMB', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=':', parent=current)
        self.exit_rule(current)
        return current
    COLON_SYMB.min_depth = 0

    @depthcontrol
    def QUOTE_SYMB(self, parent=None):
        current = UnlexerRule(name='QUOTE_SYMB', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.SINGLE_QUOTE_SYMB(parent=current)
        elif choice == 1:
            self.DOUBLE_QUOTE_SYMB(parent=current)
        elif choice == 2:
            self.REVERSE_QUOTE_SYMB(parent=current)
        self.exit_rule(current)
        return current
    QUOTE_SYMB.min_depth = 1

    @depthcontrol
    def CHARSET_REVERSE_QOUTE_STRING(self, parent=None):
        current = UnlexerRule(name='CHARSET_REVERSE_QOUTE_STRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='`', parent=current)
        self.CHARSET_NAME(parent=current)
        UnlexerRule(src='`', parent=current)
        self.exit_rule(current)
        return current
    CHARSET_REVERSE_QOUTE_STRING.min_depth = 2

    @depthcontrol
    def FILESIZE_LITERAL(self, parent=None):
        current = UnlexerRule(name='FILESIZE_LITERAL', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.DEC_DIGIT(parent=current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='K', parent=current)
        elif choice == 1:
            UnlexerRule(src='M', parent=current)
        elif choice == 2:
            UnlexerRule(src='G', parent=current)
        elif choice == 3:
            UnlexerRule(src='T', parent=current)
        self.exit_rule(current)
        return current
    FILESIZE_LITERAL.min_depth = 1

    @depthcontrol
    def START_NATIONAL_STRING_LITERAL(self, parent=None):
        current = UnlexerRule(name='START_NATIONAL_STRING_LITERAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='N', parent=current)
        self.SQUOTA_STRING(parent=current)
        self.exit_rule(current)
        return current
    START_NATIONAL_STRING_LITERAL.min_depth = 1

    @depthcontrol
    def STRING_LITERAL(self, parent=None):
        current = UnlexerRule(name='STRING_LITERAL', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.DQUOTA_STRING(parent=current)
        elif choice == 1:
            self.SQUOTA_STRING(parent=current)
        elif choice == 2:
            self.BQUOTA_STRING(parent=current)
        self.exit_rule(current)
        return current
    STRING_LITERAL.min_depth = 1

    @depthcontrol
    def DECIMAL_LITERAL(self, parent=None):
        current = UnlexerRule(name='DECIMAL_LITERAL', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.DEC_DIGIT(parent=current)
        self.exit_rule(current)
        return current
    DECIMAL_LITERAL.min_depth = 1

    @depthcontrol
    def HEXADECIMAL_LITERAL(self, parent=None):
        current = UnlexerRule(name='HEXADECIMAL_LITERAL', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='X', parent=current)
            UnlexerRule(src='\'', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=1, max=inf):
                    self.HEX_DIGIT(parent=current)
                    self.HEX_DIGIT(parent=current)
            UnlexerRule(src='\'', parent=current)
        elif choice == 1:
            UnlexerRule(src='0X', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 1, min=1, max=inf):
                    self.HEX_DIGIT(parent=current)
        self.exit_rule(current)
        return current
    HEXADECIMAL_LITERAL.min_depth = 1

    @depthcontrol
    def REAL_LITERAL(self, parent=None):
        current = UnlexerRule(name='REAL_LITERAL', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    if self.max_depth >= 0:
                        for _ in self.model.quantify(current, 1, min=1, max=inf):
                            self.DEC_DIGIT(parent=current)
            UnlexerRule(src='.', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 2, min=1, max=inf):
                    self.DEC_DIGIT(parent=current)
        elif choice == 1:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 3, min=1, max=inf):
                    self.DEC_DIGIT(parent=current)
            UnlexerRule(src='.', parent=current)
            self.EXPONENT_NUM_PART(parent=current)
        elif choice == 2:
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 4, min=0, max=1):
                    if self.max_depth >= 0:
                        for _ in self.model.quantify(current, 5, min=1, max=inf):
                            self.DEC_DIGIT(parent=current)
            UnlexerRule(src='.', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 6, min=1, max=inf):
                    self.DEC_DIGIT(parent=current)
            self.EXPONENT_NUM_PART(parent=current)
        elif choice == 3:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 7, min=1, max=inf):
                    self.DEC_DIGIT(parent=current)
            self.EXPONENT_NUM_PART(parent=current)
        self.exit_rule(current)
        return current
    REAL_LITERAL.min_depth = 1

    @depthcontrol
    def NULL_SPEC_LITERAL(self, parent=None):
        current = UnlexerRule(name='NULL_SPEC_LITERAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='\\', parent=current)
        UnlexerRule(src='N', parent=current)
        self.exit_rule(current)
        return current
    NULL_SPEC_LITERAL.min_depth = 0

    @depthcontrol
    def BIT_STRING(self, parent=None):
        current = UnlexerRule(name='BIT_STRING', parent=parent)
        self.enter_rule(current)
        self.BIT_STRING_L(parent=current)
        self.exit_rule(current)
        return current
    BIT_STRING.min_depth = 1

    @depthcontrol
    def STRING_CHARSET_NAME(self, parent=None):
        current = UnlexerRule(name='STRING_CHARSET_NAME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='_', parent=current)
        self.CHARSET_NAME(parent=current)
        self.exit_rule(current)
        return current
    STRING_CHARSET_NAME.min_depth = 2

    @depthcontrol
    def DOT_ID(self, parent=None):
        current = UnlexerRule(name='DOT_ID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='.', parent=current)
        self.ID_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    DOT_ID.min_depth = 1

    @depthcontrol
    def ID(self, parent=None):
        current = UnlexerRule(name='ID', parent=parent)
        self.enter_rule(current)
        self.ID_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    ID.min_depth = 1

    @depthcontrol
    def REVERSE_QUOTE_ID(self, parent=None):
        current = UnlexerRule(name='REVERSE_QUOTE_ID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='`', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[4]), parent=current)
        UnlexerRule(src='`', parent=current)
        self.exit_rule(current)
        return current
    REVERSE_QUOTE_ID.min_depth = 0

    @depthcontrol
    def STRING_USER_NAME(self, parent=None):
        current = UnlexerRule(name='STRING_USER_NAME', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.SQUOTA_STRING(parent=current)
        elif choice == 1:
            self.DQUOTA_STRING(parent=current)
        elif choice == 2:
            self.BQUOTA_STRING(parent=current)
        elif choice == 3:
            self.ID_LITERAL(parent=current)
        UnlexerRule(src='@', parent=current)
        choice = self.model.choice(current, 1, [0 if [1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            self.SQUOTA_STRING(parent=current)
        elif choice == 1:
            self.DQUOTA_STRING(parent=current)
        elif choice == 2:
            self.BQUOTA_STRING(parent=current)
        elif choice == 3:
            self.ID_LITERAL(parent=current)
        elif choice == 4:
            self.IP_ADDRESS(parent=current)
        self.exit_rule(current)
        return current
    STRING_USER_NAME.min_depth = 1

    @depthcontrol
    def IP_ADDRESS(self, parent=None):
        current = UnlexerRule(name='IP_ADDRESS', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src=self.model.charset(current, 0, self._charsets[5]), parent=current)
            UnlexerRule(src='.', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 1, min=1, max=inf):
                    UnlexerRule(src=self.model.charset(current, 1, self._charsets[6]), parent=current)
        elif choice == 1:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 2, min=1, max=inf):
                    UnlexerRule(src=self.model.charset(current, 2, self._charsets[7]), parent=current)
            UnlexerRule(src=':', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 3, min=1, max=inf):
                    UnlexerRule(src=self.model.charset(current, 3, self._charsets[8]), parent=current)
        self.exit_rule(current)
        return current
    IP_ADDRESS.min_depth = 0

    @depthcontrol
    def LOCAL_ID(self, parent=None):
        current = UnlexerRule(name='LOCAL_ID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='@', parent=current)
        choice = self.model.choice(current, 0, [0 if [0, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src=self.model.charset(current, 0, self._charsets[9]), parent=current)
        elif choice == 1:
            self.SQUOTA_STRING(parent=current)
        elif choice == 2:
            self.DQUOTA_STRING(parent=current)
        elif choice == 3:
            self.BQUOTA_STRING(parent=current)
        self.exit_rule(current)
        return current
    LOCAL_ID.min_depth = 0

    @depthcontrol
    def GLOBAL_ID(self, parent=None):
        current = UnlexerRule(name='GLOBAL_ID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='@', parent=current)
        UnlexerRule(src='@', parent=current)
        choice = self.model.choice(current, 0, [0 if [0, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src=self.model.charset(current, 0, self._charsets[10]), parent=current)
        elif choice == 1:
            self.BQUOTA_STRING(parent=current)
        self.exit_rule(current)
        return current
    GLOBAL_ID.min_depth = 0

    @depthcontrol
    def CHARSET_NAME(self, parent=None):
        current = UnlexerRule(name='CHARSET_NAME', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.ARMSCII8(parent=current)
        elif choice == 1:
            self.ASCII(parent=current)
        elif choice == 2:
            self.BIG5(parent=current)
        elif choice == 3:
            self.BINARY(parent=current)
        elif choice == 4:
            self.CP1250(parent=current)
        elif choice == 5:
            self.CP1251(parent=current)
        elif choice == 6:
            self.CP1256(parent=current)
        elif choice == 7:
            self.CP1257(parent=current)
        elif choice == 8:
            self.CP850(parent=current)
        elif choice == 9:
            self.CP852(parent=current)
        elif choice == 10:
            self.CP866(parent=current)
        elif choice == 11:
            self.CP932(parent=current)
        elif choice == 12:
            self.DEC8(parent=current)
        elif choice == 13:
            self.EUCJPMS(parent=current)
        elif choice == 14:
            self.EUCKR(parent=current)
        elif choice == 15:
            self.GB2312(parent=current)
        elif choice == 16:
            self.GBK(parent=current)
        elif choice == 17:
            self.GEOSTD8(parent=current)
        elif choice == 18:
            self.GREEK(parent=current)
        elif choice == 19:
            self.HEBREW(parent=current)
        elif choice == 20:
            self.HP8(parent=current)
        elif choice == 21:
            self.KEYBCS2(parent=current)
        elif choice == 22:
            self.KOI8R(parent=current)
        elif choice == 23:
            self.KOI8U(parent=current)
        elif choice == 24:
            self.LATIN1(parent=current)
        elif choice == 25:
            self.LATIN2(parent=current)
        elif choice == 26:
            self.LATIN5(parent=current)
        elif choice == 27:
            self.LATIN7(parent=current)
        elif choice == 28:
            self.MACCE(parent=current)
        elif choice == 29:
            self.MACROMAN(parent=current)
        elif choice == 30:
            self.SJIS(parent=current)
        elif choice == 31:
            self.SWE7(parent=current)
        elif choice == 32:
            self.TIS620(parent=current)
        elif choice == 33:
            self.UCS2(parent=current)
        elif choice == 34:
            self.UJIS(parent=current)
        elif choice == 35:
            self.UTF16(parent=current)
        elif choice == 36:
            self.UTF16LE(parent=current)
        elif choice == 37:
            self.UTF32(parent=current)
        elif choice == 38:
            self.UTF8(parent=current)
        elif choice == 39:
            self.UTF8MB3(parent=current)
        elif choice == 40:
            self.UTF8MB4(parent=current)
        self.exit_rule(current)
        return current
    CHARSET_NAME.min_depth = 1

    @depthcontrol
    def EXPONENT_NUM_PART(self, parent=None):
        current = UnlexerRule(name='EXPONENT_NUM_PART', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='E', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[11]), parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=1, max=inf):
                self.DEC_DIGIT(parent=current)
        self.exit_rule(current)
        return current
    EXPONENT_NUM_PART.min_depth = 1

    @depthcontrol
    def ID_LITERAL(self, parent=None):
        current = UnlexerRule(name='ID_LITERAL', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[12]), parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 1, self._charsets[13]), parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 2, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 2, self._charsets[14]), parent=current)
        self.exit_rule(current)
        return current
    ID_LITERAL.min_depth = 0

    @depthcontrol
    def DQUOTA_STRING(self, parent=None):
        current = UnlexerRule(name='DQUOTA_STRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='"', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    UnlexerRule(src='\\', parent=current)
                    UnlexerRule(src=self.model.charset(current, 0, self._charsets[0]), parent=current)
                elif choice == 1:
                    UnlexerRule(src='""', parent=current)
                elif choice == 2:
                    UnlexerRule(src=self.model.charset(current, 1, self._charsets[15]), parent=current)
        UnlexerRule(src='"', parent=current)
        self.exit_rule(current)
        return current
    DQUOTA_STRING.min_depth = 0

    @depthcontrol
    def SQUOTA_STRING(self, parent=None):
        current = UnlexerRule(name='SQUOTA_STRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='\'', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    UnlexerRule(src='\\', parent=current)
                    UnlexerRule(src=self.model.charset(current, 0, self._charsets[0]), parent=current)
                elif choice == 1:
                    UnlexerRule(src='\'\'', parent=current)
                elif choice == 2:
                    UnlexerRule(src=self.model.charset(current, 1, self._charsets[16]), parent=current)
        UnlexerRule(src='\'', parent=current)
        self.exit_rule(current)
        return current
    SQUOTA_STRING.min_depth = 0

    @depthcontrol
    def BQUOTA_STRING(self, parent=None):
        current = UnlexerRule(name='BQUOTA_STRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='`', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    UnlexerRule(src='\\', parent=current)
                    UnlexerRule(src=self.model.charset(current, 0, self._charsets[0]), parent=current)
                elif choice == 1:
                    UnlexerRule(src='``', parent=current)
                elif choice == 2:
                    UnlexerRule(src=self.model.charset(current, 1, self._charsets[17]), parent=current)
        UnlexerRule(src='`', parent=current)
        self.exit_rule(current)
        return current
    BQUOTA_STRING.min_depth = 0

    @depthcontrol
    def HEX_DIGIT(self, parent=None):
        current = UnlexerRule(name='HEX_DIGIT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[18]), parent=current)
        self.exit_rule(current)
        return current
    HEX_DIGIT.min_depth = 0

    @depthcontrol
    def DEC_DIGIT(self, parent=None):
        current = UnlexerRule(name='DEC_DIGIT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[19]), parent=current)
        self.exit_rule(current)
        return current
    DEC_DIGIT.min_depth = 0

    @depthcontrol
    def BIT_STRING_L(self, parent=None):
        current = UnlexerRule(name='BIT_STRING_L', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='B', parent=current)
        UnlexerRule(src='\'', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[20]), parent=current)
        UnlexerRule(src='\'', parent=current)
        self.exit_rule(current)
        return current
    BIT_STRING_L.min_depth = 0

    @depthcontrol
    def ERROR_RECONGNIGION(self, parent=None):
        current = UnlexerRule(name='ERROR_RECONGNIGION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[0]), parent=current)
        self.exit_rule(current)
        return current
    ERROR_RECONGNIGION.min_depth = 0

    @depthcontrol
    def root(self, parent=None):
        current = UnparserRule(name='root', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.sqlStatements(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.MINUSMINUS(parent=current)
        self.EOF(parent=current)
        self.exit_rule(current)
        return current
    root.min_depth = 1

    @depthcontrol
    def sqlStatements(self, parent=None):
        current = UnparserRule(name='sqlStatements', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [4, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.sqlStatement(parent=current)
                    if self.max_depth >= 1:
                        for _ in self.model.quantify(current, 1, min=0, max=1):
                            self.MINUSMINUS(parent=current)
                    if self.max_depth >= 1:
                        for _ in self.model.quantify(current, 2, min=0, max=1):
                            self.SEMI(parent=current)
                elif choice == 1:
                    self.emptyStatement(parent=current)
        choice = self.model.choice(current, 1, [0 if [4, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.sqlStatement(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 3, min=0, max=1):
                    if self.max_depth >= 1:
                        for _ in self.model.quantify(current, 4, min=0, max=1):
                            self.MINUSMINUS(parent=current)
                    self.SEMI(parent=current)
        elif choice == 1:
            self.emptyStatement(parent=current)
        self.exit_rule(current)
        return current
    sqlStatements.min_depth = 2

    @depthcontrol
    def sqlStatement(self, parent=None):
        current = UnparserRule(name='sqlStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 5, 3, 3, 4, 3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.ddlStatement(parent=current)
        elif choice == 1:
            self.dmlStatement(parent=current)
        elif choice == 2:
            self.transactionStatement(parent=current)
        elif choice == 3:
            self.replicationStatement(parent=current)
        elif choice == 4:
            self.preparedStatement(parent=current)
        elif choice == 5:
            self.administrationStatement(parent=current)
        elif choice == 6:
            self.utilityStatement(parent=current)
        self.exit_rule(current)
        return current
    sqlStatement.min_depth = 3

    @depthcontrol
    def emptyStatement(self, parent=None):
        current = UnparserRule(name='emptyStatement', parent=parent)
        self.enter_rule(current)
        self.SEMI(parent=current)
        self.exit_rule(current)
        return current
    emptyStatement.min_depth = 1

    @depthcontrol
    def ddlStatement(self, parent=None):
        current = UnparserRule(name='ddlStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 5, 5, 3, 4, 4, 4, 6, 3, 3, 5, 5, 4, 4, 4, 2, 3, 4, 4, 5, 3, 5, 3, 4, 5, 3, 4, 4, 3, 6, 3, 4, 4, 6, 5][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.createDatabase(parent=current)
        elif choice == 1:
            self.createEvent(parent=current)
        elif choice == 2:
            self.createIndex(parent=current)
        elif choice == 3:
            self.createLogfileGroup(parent=current)
        elif choice == 4:
            self.createProcedure(parent=current)
        elif choice == 5:
            self.createFunction(parent=current)
        elif choice == 6:
            self.createServer(parent=current)
        elif choice == 7:
            self.createTable(parent=current)
        elif choice == 8:
            self.createTablespaceInnodb(parent=current)
        elif choice == 9:
            self.createTablespaceNdb(parent=current)
        elif choice == 10:
            self.createTrigger(parent=current)
        elif choice == 11:
            self.createView(parent=current)
        elif choice == 12:
            self.alterDatabase(parent=current)
        elif choice == 13:
            self.alterEvent(parent=current)
        elif choice == 14:
            self.alterFunction(parent=current)
        elif choice == 15:
            self.alterInstance(parent=current)
        elif choice == 16:
            self.alterLogfileGroup(parent=current)
        elif choice == 17:
            self.alterProcedure(parent=current)
        elif choice == 18:
            self.alterServer(parent=current)
        elif choice == 19:
            self.alterTable(parent=current)
        elif choice == 20:
            self.alterTablespace(parent=current)
        elif choice == 21:
            self.alterView(parent=current)
        elif choice == 22:
            self.dropDatabase(parent=current)
        elif choice == 23:
            self.dropEvent(parent=current)
        elif choice == 24:
            self.dropIndex(parent=current)
        elif choice == 25:
            self.dropLogfileGroup(parent=current)
        elif choice == 26:
            self.dropProcedure(parent=current)
        elif choice == 27:
            self.dropFunction(parent=current)
        elif choice == 28:
            self.dropServer(parent=current)
        elif choice == 29:
            self.dropTable(parent=current)
        elif choice == 30:
            self.dropTablespace(parent=current)
        elif choice == 31:
            self.dropTrigger(parent=current)
        elif choice == 32:
            self.dropView(parent=current)
        elif choice == 33:
            self.renameTable(parent=current)
        elif choice == 34:
            self.truncateTable(parent=current)
        self.exit_rule(current)
        return current
    ddlStatement.min_depth = 2

    @depthcontrol
    def dmlStatement(self, parent=None):
        current = UnparserRule(name='dmlStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 5, 6, 6, 5, 4, 5, 5, 10, 6][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.selectStatement(parent=current)
        elif choice == 1:
            self.insertStatement(parent=current)
        elif choice == 2:
            self.updateStatement(parent=current)
        elif choice == 3:
            self.deleteStatement(parent=current)
        elif choice == 4:
            self.replaceStatement(parent=current)
        elif choice == 5:
            self.callStatement(parent=current)
        elif choice == 6:
            self.loadDataStatement(parent=current)
        elif choice == 7:
            self.loadXmlStatement(parent=current)
        elif choice == 8:
            self.doStatement(parent=current)
        elif choice == 9:
            self.handlerStatement(parent=current)
        self.exit_rule(current)
        return current
    dmlStatement.min_depth = 4

    @depthcontrol
    def transactionStatement(self, parent=None):
        current = UnparserRule(name='transactionStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2, 2, 2, 3, 3, 3, 6, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.startTransaction(parent=current)
        elif choice == 1:
            self.beginWork(parent=current)
        elif choice == 2:
            self.commitWork(parent=current)
        elif choice == 3:
            self.rollbackWork(parent=current)
        elif choice == 4:
            self.savepointStatement(parent=current)
        elif choice == 5:
            self.rollbackStatement(parent=current)
        elif choice == 6:
            self.releaseStatement(parent=current)
        elif choice == 7:
            self.lockTables(parent=current)
        elif choice == 8:
            self.unlockTables(parent=current)
        self.exit_rule(current)
        return current
    transactionStatement.min_depth = 2

    @depthcontrol
    def replicationStatement(self, parent=None):
        current = UnparserRule(name='replicationStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 6, 3, 2, 2, 2, 2, 2, 2, 5, 5, 5, 5, 5, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.changeMaster(parent=current)
        elif choice == 1:
            self.changeReplicationFilter(parent=current)
        elif choice == 2:
            self.purgeBinaryLogs(parent=current)
        elif choice == 3:
            self.resetMaster(parent=current)
        elif choice == 4:
            self.resetSlave(parent=current)
        elif choice == 5:
            self.startSlave(parent=current)
        elif choice == 6:
            self.stopSlave(parent=current)
        elif choice == 7:
            self.startGroupReplication(parent=current)
        elif choice == 8:
            self.stopGroupReplication(parent=current)
        elif choice == 9:
            self.xaStartTransaction(parent=current)
        elif choice == 10:
            self.xaEndTransaction(parent=current)
        elif choice == 11:
            self.xaPrepareStatement(parent=current)
        elif choice == 12:
            self.xaCommitWork(parent=current)
        elif choice == 13:
            self.xaRollbackWork(parent=current)
        elif choice == 14:
            self.xaRecoverWork(parent=current)
        self.exit_rule(current)
        return current
    replicationStatement.min_depth = 2

    @depthcontrol
    def preparedStatement(self, parent=None):
        current = UnparserRule(name='preparedStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.prepareStatement(parent=current)
        elif choice == 1:
            self.executeStatement(parent=current)
        elif choice == 2:
            self.deallocatePrepare(parent=current)
        self.exit_rule(current)
        return current
    preparedStatement.min_depth = 3

    @depthcontrol
    def compoundStatement(self, parent=None):
        current = UnparserRule(name='compoundStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 6, 9, 3, 5, 9, 9, 3, 9, 4][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.blockStatement(parent=current)
        elif choice == 1:
            self.caseStatement(parent=current)
        elif choice == 2:
            self.ifStatement(parent=current)
        elif choice == 3:
            self.leaveStatement(parent=current)
        elif choice == 4:
            self.loopStatement(parent=current)
        elif choice == 5:
            self.repeatStatement(parent=current)
        elif choice == 6:
            self.whileStatement(parent=current)
        elif choice == 7:
            self.iterateStatement(parent=current)
        elif choice == 8:
            self.returnStatement(parent=current)
        elif choice == 9:
            self.cursorStatement(parent=current)
        self.exit_rule(current)
        return current
    compoundStatement.min_depth = 2

    @depthcontrol
    def administrationStatement(self, parent=None):
        current = UnparserRule(name='administrationStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [6, 7, 4, 3, 4, 5, 4, 4, 6, 6, 6, 6, 6, 3, 3, 3, 3, 3, 3, 6, 4, 3, 6, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.alterUser(parent=current)
        elif choice == 1:
            self.createUser(parent=current)
        elif choice == 2:
            self.dropUser(parent=current)
        elif choice == 3:
            self.grantStatement(parent=current)
        elif choice == 4:
            self.grantProxy(parent=current)
        elif choice == 5:
            self.renameUser(parent=current)
        elif choice == 6:
            self.revokeStatement(parent=current)
        elif choice == 7:
            self.revokeProxy(parent=current)
        elif choice == 8:
            self.analyzeTable(parent=current)
        elif choice == 9:
            self.checkTable(parent=current)
        elif choice == 10:
            self.checksumTable(parent=current)
        elif choice == 11:
            self.optimizeTable(parent=current)
        elif choice == 12:
            self.repairTable(parent=current)
        elif choice == 13:
            self.createUdfunction(parent=current)
        elif choice == 14:
            self.installPlugin(parent=current)
        elif choice == 15:
            self.uninstallPlugin(parent=current)
        elif choice == 16:
            self.setStatement(parent=current)
        elif choice == 17:
            self.showStatement(parent=current)
        elif choice == 18:
            self.binlogStatement(parent=current)
        elif choice == 19:
            self.cacheIndexStatement(parent=current)
        elif choice == 20:
            self.flushStatement(parent=current)
        elif choice == 21:
            self.killStatement(parent=current)
        elif choice == 22:
            self.loadIndexIntoCache(parent=current)
        elif choice == 23:
            self.resetStatement(parent=current)
        elif choice == 24:
            self.shutdownStatement(parent=current)
        self.exit_rule(current)
        return current
    administrationStatement.min_depth = 2

    @depthcontrol
    def utilityStatement(self, parent=None):
        current = UnparserRule(name='utilityStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 5, 3, 3, 2, 2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.simpleDescribeStatement(parent=current)
        elif choice == 1:
            self.fullDescribeStatement(parent=current)
        elif choice == 2:
            self.helpStatement(parent=current)
        elif choice == 3:
            self.useStatement(parent=current)
        elif choice == 4:
            self.signalStatement(parent=current)
        elif choice == 5:
            self.resignalStatement(parent=current)
        elif choice == 6:
            self.diagnosticsStatement(parent=current)
        self.exit_rule(current)
        return current
    utilityStatement.min_depth = 2

    @depthcontrol
    def createDatabase(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='createDatabase', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.DATABASE(parent=current)
        elif choice == 1:
            self.SCHEMA(parent=current)
        local_ctx['dbFormat'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ifNotExists(parent=current)
        self.uid(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                self.createDatabaseOption(parent=current)
        self.exit_rule(current)
        return current
    createDatabase.min_depth = 2

    @depthcontrol
    def createEvent(self, parent=None):
        current = UnparserRule(name='createEvent', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ownerStatement(parent=current)
        self.EVENT(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.ifNotExists(parent=current)
        self.fullId(parent=current)
        self.ON(parent=current)
        self.SCHEDULE(parent=current)
        self.scheduleExpression(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.ON(parent=current)
                self.COMPLETION(parent=current)
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 3, min=0, max=1):
                        self.NOT(parent=current)
                self.PRESERVE(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.enableType(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 5, min=0, max=1):
                self.COMMENT(parent=current)
                self.STRING_LITERAL(parent=current)
        self.DO(parent=current)
        self.routineBody(parent=current)
        self.exit_rule(current)
        return current
    createEvent.min_depth = 4

    @depthcontrol
    def createIndex(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='createIndex', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.ONLINE(parent=current)
                elif choice == 1:
                    self.OFFLINE(parent=current)
                local_ctx['intimeAction'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                choice = self.model.choice(current, 1, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    self.UNIQUE(parent=current)
                elif choice == 1:
                    self.FULLTEXT(parent=current)
                elif choice == 2:
                    self.SPATIAL(parent=current)
                local_ctx['indexCategory'] = current.last_child
        self.INDEX(parent=current)
        self.uid(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.indexType(parent=current)
        self.ON(parent=current)
        self.tableName(parent=current)
        self.indexColumnNames(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 3, min=0, max=inf):
                self.indexOption(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 4, min=0, max=inf):
                choice = self.model.choice(current, 2, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.ALGORITHM(parent=current)
                    if self.max_depth >= 0:
                        for _ in self.model.quantify(current, 5, min=0, max=1):
                            UnlexerRule(src='=', parent=current)
                    choice = self.model.choice(current, 3, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                    if choice == 0:
                        self.DEFAULT(parent=current)
                    elif choice == 1:
                        self.INPLACE(parent=current)
                    elif choice == 2:
                        self.COPY(parent=current)
                    local_ctx['algType'] = current.last_child
                elif choice == 1:
                    self.LOCK(parent=current)
                    if self.max_depth >= 0:
                        for _ in self.model.quantify(current, 6, min=0, max=1):
                            UnlexerRule(src='=', parent=current)
                    choice = self.model.choice(current, 4, [0 if [1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
                    if choice == 0:
                        self.DEFAULT(parent=current)
                    elif choice == 1:
                        self.NONE(parent=current)
                    elif choice == 2:
                        self.SHARED(parent=current)
                    elif choice == 3:
                        self.EXCLUSIVE(parent=current)
                    local_ctx['lockType'] = current.last_child
        self.exit_rule(current)
        return current
    createIndex.min_depth = 4

    @depthcontrol
    def createLogfileGroup(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='createLogfileGroup', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        self.LOGFILE(parent=current)
        self.GROUP(parent=current)
        self.uid(parent=current)
        self.ADD(parent=current)
        self.UNDOFILE(parent=current)
        self.STRING_LITERAL(parent=current)
        local_ctx['undoFile'] = current.last_child
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.INITIAL_SIZE(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        UnlexerRule(src='=', parent=current)
                self.fileSizeLiteral(parent=current)
                local_ctx['initSize'] = current.last_child
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.UNDO_BUFFER_SIZE(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 3, min=0, max=1):
                        UnlexerRule(src='=', parent=current)
                self.fileSizeLiteral(parent=current)
                local_ctx['undoSize'] = current.last_child
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.REDO_BUFFER_SIZE(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 5, min=0, max=1):
                        UnlexerRule(src='=', parent=current)
                self.fileSizeLiteral(parent=current)
                local_ctx['redoSize'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 6, min=0, max=1):
                self.NODEGROUP(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 7, min=0, max=1):
                        UnlexerRule(src='=', parent=current)
                self.uid(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 8, min=0, max=1):
                self.WAIT(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 9, min=0, max=1):
                self.COMMENT(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 10, min=0, max=1):
                        UnlexerRule(src='=', parent=current)
                self.STRING_LITERAL(parent=current)
                local_ctx['comment'] = current.last_child
        self.ENGINE(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 11, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.engineName(parent=current)
        self.exit_rule(current)
        return current
    createLogfileGroup.min_depth = 2

    @depthcontrol
    def createProcedure(self, parent=None):
        current = UnparserRule(name='createProcedure', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ownerStatement(parent=current)
        self.PROCEDURE(parent=current)
        self.fullId(parent=current)
        UnlexerRule(src='(', parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.procedureParameter(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 2, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.procedureParameter(parent=current)
        UnlexerRule(src=')', parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 3, min=0, max=inf):
                self.routineOption(parent=current)
        self.routineBody(parent=current)
        self.exit_rule(current)
        return current
    createProcedure.min_depth = 3

    @depthcontrol
    def createFunction(self, parent=None):
        current = UnparserRule(name='createFunction', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ownerStatement(parent=current)
        self.FUNCTION(parent=current)
        self.fullId(parent=current)
        UnlexerRule(src='(', parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.functionParameter(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 2, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.functionParameter(parent=current)
        UnlexerRule(src=')', parent=current)
        self.RETURNS(parent=current)
        self.dataType(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 3, min=0, max=inf):
                self.routineOption(parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 9][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.routineBody(parent=current)
        elif choice == 1:
            self.returnStatement(parent=current)
        self.exit_rule(current)
        return current
    createFunction.min_depth = 3

    @depthcontrol
    def createServer(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='createServer', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        self.SERVER(parent=current)
        self.uid(parent=current)
        self.FOREIGN(parent=current)
        self.DATA(parent=current)
        self.WRAPPER(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.MYSQL(parent=current)
        elif choice == 1:
            self.STRING_LITERAL(parent=current)
        local_ctx['wrapperName'] = current.last_child
        self.OPTIONS(parent=current)
        UnlexerRule(src='(', parent=current)
        self.serverOption(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.serverOption(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    createServer.min_depth = 3

    @depthcontrol
    def createTable(self, parent=None):
        current = UnparserRule(name='createTable', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 5, 8][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.createTable_copyCreateTable(parent=current)
        elif choice == 1:
            self.createTable_queryCreateTable(parent=current)
        elif choice == 2:
            self.createTable_columnCreateTable(parent=current)
        self.exit_rule(current)
        return current
    createTable.min_depth = 5

    @depthcontrol
    def createTablespaceInnodb(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='createTablespaceInnodb', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        self.TABLESPACE(parent=current)
        self.uid(parent=current)
        self.ADD(parent=current)
        self.DATAFILE(parent=current)
        self.STRING_LITERAL(parent=current)
        local_ctx['datafile'] = current.last_child
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.FILE_BLOCK_SIZE(parent=current)
                UnlexerRule(src='=', parent=current)
                self.fileSizeLiteral(parent=current)
                local_ctx['fileBlockSize'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.ENGINE(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        UnlexerRule(src='=', parent=current)
                self.engineName(parent=current)
        self.exit_rule(current)
        return current
    createTablespaceInnodb.min_depth = 2

    @depthcontrol
    def createTablespaceNdb(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='createTablespaceNdb', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        self.TABLESPACE(parent=current)
        self.uid(parent=current)
        self.ADD(parent=current)
        self.DATAFILE(parent=current)
        self.STRING_LITERAL(parent=current)
        local_ctx['datafile'] = current.last_child
        self.USE(parent=current)
        self.LOGFILE(parent=current)
        self.GROUP(parent=current)
        self.uid(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.EXTENT_SIZE(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        UnlexerRule(src='=', parent=current)
                self.fileSizeLiteral(parent=current)
                local_ctx['extentSize'] = current.last_child
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.INITIAL_SIZE(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 3, min=0, max=1):
                        UnlexerRule(src='=', parent=current)
                self.fileSizeLiteral(parent=current)
                local_ctx['initialSize'] = current.last_child
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.AUTOEXTEND_SIZE(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 5, min=0, max=1):
                        UnlexerRule(src='=', parent=current)
                self.fileSizeLiteral(parent=current)
                local_ctx['autoextendSize'] = current.last_child
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 6, min=0, max=1):
                self.MAX_SIZE(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 7, min=0, max=1):
                        UnlexerRule(src='=', parent=current)
                self.fileSizeLiteral(parent=current)
                local_ctx['maxSize'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 8, min=0, max=1):
                self.NODEGROUP(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 9, min=0, max=1):
                        UnlexerRule(src='=', parent=current)
                self.uid(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 10, min=0, max=1):
                self.WAIT(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 11, min=0, max=1):
                self.COMMENT(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 12, min=0, max=1):
                        UnlexerRule(src='=', parent=current)
                self.STRING_LITERAL(parent=current)
                local_ctx['comment'] = current.last_child
        self.ENGINE(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 13, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.engineName(parent=current)
        self.exit_rule(current)
        return current
    createTablespaceNdb.min_depth = 2

    @depthcontrol
    def createTrigger(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='createTrigger', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ownerStatement(parent=current)
        self.TRIGGER(parent=current)
        self.fullId(parent=current)
        local_ctx['thisTrigger'] = current.last_child
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.BEFORE(parent=current)
        elif choice == 1:
            self.AFTER(parent=current)
        local_ctx['triggerTime'] = current.last_child
        choice = self.model.choice(current, 1, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.INSERT(parent=current)
        elif choice == 1:
            self.UPDATE(parent=current)
        elif choice == 2:
            self.DELETE(parent=current)
        local_ctx['triggerEvent'] = current.last_child
        self.ON(parent=current)
        self.tableName(parent=current)
        self.FOR(parent=current)
        self.EACH(parent=current)
        self.ROW(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                choice = self.model.choice(current, 2, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.FOLLOWS(parent=current)
                elif choice == 1:
                    self.PRECEDES(parent=current)
                local_ctx['triggerPlace'] = current.last_child
                self.fullId(parent=current)
                local_ctx['otherTrigger'] = current.last_child
        self.routineBody(parent=current)
        self.exit_rule(current)
        return current
    createTrigger.min_depth = 4

    @depthcontrol
    def createView(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='createView', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.OR(parent=current)
                self.REPLACE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.ALGORITHM(parent=current)
                UnlexerRule(src='=', parent=current)
                choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    self.UNDEFINED(parent=current)
                elif choice == 1:
                    self.MERGE(parent=current)
                elif choice == 2:
                    self.TEMPTABLE(parent=current)
                local_ctx['algType'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.ownerStatement(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.SQL(parent=current)
                self.SECURITY(parent=current)
                choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.DEFINER(parent=current)
                elif choice == 1:
                    self.INVOKER(parent=current)
                local_ctx['secContext'] = current.last_child
        self.VIEW(parent=current)
        self.fullId(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                UnlexerRule(src='(', parent=current)
                self.uidList(parent=current)
                UnlexerRule(src=')', parent=current)
        self.AS(parent=current)
        self.selectStatement(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 5, min=0, max=1):
                self.WITH(parent=current)
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 6, min=0, max=1):
                        choice = self.model.choice(current, 2, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                        if choice == 0:
                            self.CASCADED(parent=current)
                        elif choice == 1:
                            self.LOCAL(parent=current)
                        local_ctx['checkOption'] = current.last_child
                self.CHECK(parent=current)
                self.OPTION(parent=current)
        self.exit_rule(current)
        return current
    createView.min_depth = 4

    @depthcontrol
    def createDatabaseOption(self, parent=None):
        current = UnparserRule(name='createDatabaseOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.DEFAULT(parent=current)
            choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.CHARACTER(parent=current)
                self.SET(parent=current)
            elif choice == 1:
                self.CHARSET(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    UnlexerRule(src='=', parent=current)
            choice = self.model.choice(current, 2, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.charsetName(parent=current)
            elif choice == 1:
                self.DEFAULT(parent=current)
        elif choice == 1:
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    self.DEFAULT(parent=current)
            self.COLLATE(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 3, min=0, max=1):
                    UnlexerRule(src='=', parent=current)
            self.collationName(parent=current)
        self.exit_rule(current)
        return current
    createDatabaseOption.min_depth = 1

    @depthcontrol
    def ownerStatement(self, parent=None):
        current = UnparserRule(name='ownerStatement', parent=parent)
        self.enter_rule(current)
        self.DEFINER(parent=current)
        UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.userName(parent=current)
        elif choice == 1:
            self.CURRENT_USER(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src='(', parent=current)
                    UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    ownerStatement.min_depth = 1

    @depthcontrol
    def scheduleExpression(self, parent=None):
        current = UnparserRule(name='scheduleExpression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.scheduleExpression_preciseSchedule(parent=current)
        elif choice == 1:
            self.scheduleExpression_intervalSchedule(parent=current)
        self.exit_rule(current)
        return current
    scheduleExpression.min_depth = 3

    @depthcontrol
    def timestampValue(self, parent=None):
        current = UnparserRule(name='timestampValue', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 3, 2, 8][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.CURRENT_TIMESTAMP(parent=current)
        elif choice == 1:
            self.stringLiteral(parent=current)
        elif choice == 2:
            self.decimalLiteral(parent=current)
        elif choice == 3:
            self.expression(parent=current)
        self.exit_rule(current)
        return current
    timestampValue.min_depth = 1

    @depthcontrol
    def intervalExpr(self, parent=None):
        current = UnparserRule(name='intervalExpr', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='+', parent=current)
        self.INTERVAL(parent=current)
        choice = self.model.choice(current, 0, [0 if [2, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.decimalLiteral(parent=current)
        elif choice == 1:
            self.expression(parent=current)
        self.intervalType(parent=current)
        self.exit_rule(current)
        return current
    intervalExpr.min_depth = 2

    @depthcontrol
    def intervalType(self, parent=None):
        current = UnparserRule(name='intervalType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.intervalTypeBase(parent=current)
        elif choice == 1:
            self.YEAR(parent=current)
        elif choice == 2:
            self.YEAR_MONTH(parent=current)
        elif choice == 3:
            self.DAY_HOUR(parent=current)
        elif choice == 4:
            self.DAY_MINUTE(parent=current)
        elif choice == 5:
            self.DAY_SECOND(parent=current)
        elif choice == 6:
            self.HOUR_MINUTE(parent=current)
        elif choice == 7:
            self.HOUR_SECOND(parent=current)
        elif choice == 8:
            self.MINUTE_SECOND(parent=current)
        elif choice == 9:
            self.SECOND_MICROSECOND(parent=current)
        elif choice == 10:
            self.MINUTE_MICROSECOND(parent=current)
        elif choice == 11:
            self.HOUR_MICROSECOND(parent=current)
        elif choice == 12:
            self.DAY_MICROSECOND(parent=current)
        self.exit_rule(current)
        return current
    intervalType.min_depth = 1

    @depthcontrol
    def enableType(self, parent=None):
        current = UnparserRule(name='enableType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.ENABLE(parent=current)
        elif choice == 1:
            self.DISABLE(parent=current)
        elif choice == 2:
            self.DISABLE(parent=current)
            self.ON(parent=current)
            self.SLAVE(parent=current)
        self.exit_rule(current)
        return current
    enableType.min_depth = 1

    @depthcontrol
    def indexType(self, parent=None):
        current = UnparserRule(name='indexType', parent=parent)
        self.enter_rule(current)
        self.USING(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.BTREE(parent=current)
        elif choice == 1:
            self.HASH(parent=current)
        self.exit_rule(current)
        return current
    indexType.min_depth = 1

    @depthcontrol
    def indexOption(self, parent=None):
        current = UnparserRule(name='indexOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 2, 2, 2, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.KEY_BLOCK_SIZE(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src='=', parent=current)
            self.fileSizeLiteral(parent=current)
        elif choice == 1:
            self.indexType(parent=current)
        elif choice == 2:
            self.WITH(parent=current)
            self.PARSER(parent=current)
            self.uid(parent=current)
        elif choice == 3:
            self.COMMENT(parent=current)
            self.STRING_LITERAL(parent=current)
        elif choice == 4:
            self.INVISIBLE(parent=current)
        elif choice == 5:
            self.VISIBLE(parent=current)
        self.exit_rule(current)
        return current
    indexOption.min_depth = 1

    @depthcontrol
    def procedureParameter(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='procedureParameter', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    self.IN(parent=current)
                elif choice == 1:
                    self.OUT(parent=current)
                elif choice == 2:
                    self.INOUT(parent=current)
                local_ctx['direction'] = current.last_child
        self.uid(parent=current)
        self.dataType(parent=current)
        self.exit_rule(current)
        return current
    procedureParameter.min_depth = 3

    @depthcontrol
    def functionParameter(self, parent=None):
        current = UnparserRule(name='functionParameter', parent=parent)
        self.enter_rule(current)
        self.uid(parent=current)
        self.dataType(parent=current)
        self.exit_rule(current)
        return current
    functionParameter.min_depth = 3

    @depthcontrol
    def routineOption(self, parent=None):
        current = UnparserRule(name='routineOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 2, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            self.routineOption_routineComment(parent=current)
        elif choice == 1:
            self.routineOption_routineLanguage(parent=current)
        elif choice == 2:
            self.routineOption_routineBehavior(parent=current)
        elif choice == 3:
            self.routineOption_routineData(parent=current)
        elif choice == 4:
            self.routineOption_routineSecurity(parent=current)
        self.exit_rule(current)
        return current
    routineOption.min_depth = 2

    @depthcontrol
    def serverOption(self, parent=None):
        current = UnparserRule(name='serverOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2, 2, 2, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.HOST(parent=current)
            self.STRING_LITERAL(parent=current)
        elif choice == 1:
            self.DATABASE(parent=current)
            self.STRING_LITERAL(parent=current)
        elif choice == 2:
            self.USER(parent=current)
            self.STRING_LITERAL(parent=current)
        elif choice == 3:
            self.PASSWORD(parent=current)
            self.STRING_LITERAL(parent=current)
        elif choice == 4:
            self.SOCKET(parent=current)
            self.STRING_LITERAL(parent=current)
        elif choice == 5:
            self.OWNER(parent=current)
            self.STRING_LITERAL(parent=current)
        elif choice == 6:
            self.PORT(parent=current)
            self.decimalLiteral(parent=current)
        self.exit_rule(current)
        return current
    serverOption.min_depth = 2

    @depthcontrol
    def createDefinitions(self, parent=None):
        current = UnparserRule(name='createDefinitions', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.createDefinition(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.createDefinition(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    createDefinitions.min_depth = 6

    @depthcontrol
    def createDefinition(self, parent=None):
        current = UnparserRule(name='createDefinition', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 7, 7][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.createDefinition_columnDeclaration(parent=current)
        elif choice == 1:
            self.createDefinition_constraintDeclaration(parent=current)
        elif choice == 2:
            self.createDefinition_indexDeclaration(parent=current)
        self.exit_rule(current)
        return current
    createDefinition.min_depth = 5

    @depthcontrol
    def columnDefinition(self, parent=None):
        current = UnparserRule(name='columnDefinition', parent=parent)
        self.enter_rule(current)
        self.dataType(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.columnConstraint(parent=current)
        self.exit_rule(current)
        return current
    columnDefinition.min_depth = 3

    @depthcontrol
    def columnConstraint(self, parent=None):
        current = UnparserRule(name='columnConstraint', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3, 2, 2, 2, 3, 2, 2, 6, 4, 9, 2, 9][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.columnConstraint_nullColumnConstraint(parent=current)
        elif choice == 1:
            self.columnConstraint_defaultColumnConstraint(parent=current)
        elif choice == 2:
            self.columnConstraint_autoIncrementColumnConstraint(parent=current)
        elif choice == 3:
            self.columnConstraint_primaryKeyColumnConstraint(parent=current)
        elif choice == 4:
            self.columnConstraint_uniqueKeyColumnConstraint(parent=current)
        elif choice == 5:
            self.columnConstraint_commentColumnConstraint(parent=current)
        elif choice == 6:
            self.columnConstraint_formatColumnConstraint(parent=current)
        elif choice == 7:
            self.columnConstraint_storageColumnConstraint(parent=current)
        elif choice == 8:
            self.columnConstraint_referenceColumnConstraint(parent=current)
        elif choice == 9:
            self.columnConstraint_collateColumnConstraint(parent=current)
        elif choice == 10:
            self.columnConstraint_generatedColumnConstraint(parent=current)
        elif choice == 11:
            self.columnConstraint_serialDefaultColumnConstraint(parent=current)
        elif choice == 12:
            self.columnConstraint_checkColumnConstraint(parent=current)
        self.exit_rule(current)
        return current
    columnConstraint.min_depth = 2

    @depthcontrol
    def tableConstraint(self, parent=None):
        current = UnparserRule(name='tableConstraint', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 5, 6, 9][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.tableConstraint_primaryKeyTableConstraint(parent=current)
        elif choice == 1:
            self.tableConstraint_uniqueKeyTableConstraint(parent=current)
        elif choice == 2:
            self.tableConstraint_foreignKeyTableConstraint(parent=current)
        elif choice == 3:
            self.tableConstraint_checkTableConstraint(parent=current)
        self.exit_rule(current)
        return current
    tableConstraint.min_depth = 5

    @depthcontrol
    def referenceDefinition(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='referenceDefinition', parent=parent)
        self.enter_rule(current)
        self.REFERENCES(parent=current)
        self.tableName(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.indexColumnNames(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.MATCH(parent=current)
                choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    self.FULL(parent=current)
                elif choice == 1:
                    self.PARTIAL(parent=current)
                elif choice == 2:
                    self.SIMPLE(parent=current)
                local_ctx['matchType'] = current.last_child
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.referenceAction(parent=current)
        self.exit_rule(current)
        return current
    referenceDefinition.min_depth = 4

    @depthcontrol
    def referenceAction(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='referenceAction', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.ON(parent=current)
            self.DELETE(parent=current)
            self.referenceControlType(parent=current)
            local_ctx['onDelete'] = current.last_child
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.ON(parent=current)
                    self.UPDATE(parent=current)
                    self.referenceControlType(parent=current)
                    local_ctx['onUpdate'] = current.last_child
        elif choice == 1:
            self.ON(parent=current)
            self.UPDATE(parent=current)
            self.referenceControlType(parent=current)
            local_ctx['onUpdate'] = current.last_child
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    self.ON(parent=current)
                    self.DELETE(parent=current)
                    self.referenceControlType(parent=current)
                    local_ctx['onDelete'] = current.last_child
        self.exit_rule(current)
        return current
    referenceAction.min_depth = 2

    @depthcontrol
    def referenceControlType(self, parent=None):
        current = UnparserRule(name='referenceControlType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.RESTRICT(parent=current)
        elif choice == 1:
            self.CASCADE(parent=current)
        elif choice == 2:
            self.SET(parent=current)
            self.NULL_LITERAL(parent=current)
        elif choice == 3:
            self.NO(parent=current)
            self.ACTION(parent=current)
        self.exit_rule(current)
        return current
    referenceControlType.min_depth = 1

    @depthcontrol
    def indexColumnDefinition(self, parent=None):
        current = UnparserRule(name='indexColumnDefinition', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 5][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.indexColumnDefinition_simpleIndexDeclaration(parent=current)
        elif choice == 1:
            self.indexColumnDefinition_specialIndexDeclaration(parent=current)
        self.exit_rule(current)
        return current
    indexColumnDefinition.min_depth = 5

    @depthcontrol
    def tableOption(self, parent=None):
        current = UnparserRule(name='tableOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3, 3, 2, 2, 4, 3, 3, 3, 3, 2, 3, 3, 2, 4, 3, 3, 2, 3, 2, 2, 2, 3, 3, 3, 6][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.tableOption_tableOptionEngine(parent=current)
        elif choice == 1:
            self.tableOption_tableOptionAutoIncrement(parent=current)
        elif choice == 2:
            self.tableOption_tableOptionAverage(parent=current)
        elif choice == 3:
            self.tableOption_tableOptionCharset(parent=current)
        elif choice == 4:
            self.tableOption_tableOptionChecksum(parent=current)
        elif choice == 5:
            self.tableOption_tableOptionCollate(parent=current)
        elif choice == 6:
            self.tableOption_tableOptionComment(parent=current)
        elif choice == 7:
            self.tableOption_tableOptionCompression(parent=current)
        elif choice == 8:
            self.tableOption_tableOptionConnection(parent=current)
        elif choice == 9:
            self.tableOption_tableOptionDataDirectory(parent=current)
        elif choice == 10:
            self.tableOption_tableOptionDelay(parent=current)
        elif choice == 11:
            self.tableOption_tableOptionEncryption(parent=current)
        elif choice == 12:
            self.tableOption_tableOptionIndexDirectory(parent=current)
        elif choice == 13:
            self.tableOption_tableOptionInsertMethod(parent=current)
        elif choice == 14:
            self.tableOption_tableOptionKeyBlockSize(parent=current)
        elif choice == 15:
            self.tableOption_tableOptionMaxRows(parent=current)
        elif choice == 16:
            self.tableOption_tableOptionMinRows(parent=current)
        elif choice == 17:
            self.tableOption_tableOptionPackKeys(parent=current)
        elif choice == 18:
            self.tableOption_tableOptionPassword(parent=current)
        elif choice == 19:
            self.tableOption_tableOptionRowFormat(parent=current)
        elif choice == 20:
            self.tableOption_tableOptionRecalculation(parent=current)
        elif choice == 21:
            self.tableOption_tableOptionPersistent(parent=current)
        elif choice == 22:
            self.tableOption_tableOptionSamplePage(parent=current)
        elif choice == 23:
            self.tableOption_tableOptionTablespace(parent=current)
        elif choice == 24:
            self.tableOption_tableOptionTablespace(parent=current)
        elif choice == 25:
            self.tableOption_tableOptionUnion(parent=current)
        self.exit_rule(current)
        return current
    tableOption.min_depth = 2

    @depthcontrol
    def tablespaceStorage(self, parent=None):
        current = UnparserRule(name='tablespaceStorage', parent=parent)
        self.enter_rule(current)
        self.STORAGE(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.DISK(parent=current)
        elif choice == 1:
            self.MEMORY(parent=current)
        elif choice == 2:
            self.DEFAULT(parent=current)
        self.exit_rule(current)
        return current
    tablespaceStorage.min_depth = 1

    @depthcontrol
    def partitionDefinitions(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='partitionDefinitions', parent=parent)
        self.enter_rule(current)
        self.PARTITION(parent=current)
        self.BY(parent=current)
        self.partitionFunctionDefinition(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.PARTITIONS(parent=current)
                self.decimalLiteral(parent=current)
                local_ctx['count'] = current.last_child
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.SUBPARTITION(parent=current)
                self.BY(parent=current)
                self.subpartitionFunctionDefinition(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        self.SUBPARTITIONS(parent=current)
                        self.decimalLiteral(parent=current)
                        local_ctx['subCount'] = current.last_child
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                UnlexerRule(src='(', parent=current)
                self.partitionDefinition(parent=current)
                if self.max_depth >= 4:
                    for _ in self.model.quantify(current, 4, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.partitionDefinition(parent=current)
                UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    partitionDefinitions.min_depth = 5

    @depthcontrol
    def partitionFunctionDefinition(self, parent=None):
        current = UnparserRule(name='partitionFunctionDefinition', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [9, 4, 4, 4][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.partitionFunctionDefinition_partitionFunctionHash(parent=current)
        elif choice == 1:
            self.partitionFunctionDefinition_partitionFunctionKey(parent=current)
        elif choice == 2:
            self.partitionFunctionDefinition_partitionFunctionRange(parent=current)
        elif choice == 3:
            self.partitionFunctionDefinition_partitionFunctionList(parent=current)
        self.exit_rule(current)
        return current
    partitionFunctionDefinition.min_depth = 4

    @depthcontrol
    def subpartitionFunctionDefinition(self, parent=None):
        current = UnparserRule(name='subpartitionFunctionDefinition', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [9, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.subpartitionFunctionDefinition_subPartitionFunctionHash(parent=current)
        elif choice == 1:
            self.subpartitionFunctionDefinition_subPartitionFunctionKey(parent=current)
        self.exit_rule(current)
        return current
    subpartitionFunctionDefinition.min_depth = 4

    @depthcontrol
    def partitionDefinition(self, parent=None):
        current = UnparserRule(name='partitionDefinition', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3, 3, 4, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            self.partitionDefinition_partitionComparison(parent=current)
        elif choice == 1:
            self.partitionDefinition_partitionComparison(parent=current)
        elif choice == 2:
            self.partitionDefinition_partitionListAtom(parent=current)
        elif choice == 3:
            self.partitionDefinition_partitionListVector(parent=current)
        elif choice == 4:
            self.partitionDefinition_partitionSimple(parent=current)
        self.exit_rule(current)
        return current
    partitionDefinition.min_depth = 3

    @depthcontrol
    def partitionDefinerAtom(self, parent=None):
        current = UnparserRule(name='partitionDefinerAtom', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 8, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.constant(parent=current)
        elif choice == 1:
            self.expression(parent=current)
        elif choice == 2:
            self.MAXVALUE(parent=current)
        self.exit_rule(current)
        return current
    partitionDefinerAtom.min_depth = 1

    @depthcontrol
    def partitionDefinerVector(self, parent=None):
        current = UnparserRule(name='partitionDefinerVector', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.partitionDefinerAtom(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=',', parent=current)
                self.partitionDefinerAtom(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    partitionDefinerVector.min_depth = 2

    @depthcontrol
    def subpartitionDefinition(self, parent=None):
        current = UnparserRule(name='subpartitionDefinition', parent=parent)
        self.enter_rule(current)
        self.SUBPARTITION(parent=current)
        self.uid(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.partitionOption(parent=current)
        self.exit_rule(current)
        return current
    subpartitionDefinition.min_depth = 2

    @depthcontrol
    def partitionOption(self, parent=None):
        current = UnparserRule(name='partitionOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3, 3, 3, 3, 3, 3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.partitionOption_partitionOptionEngine(parent=current)
        elif choice == 1:
            self.partitionOption_partitionOptionComment(parent=current)
        elif choice == 2:
            self.partitionOption_partitionOptionDataDirectory(parent=current)
        elif choice == 3:
            self.partitionOption_partitionOptionIndexDirectory(parent=current)
        elif choice == 4:
            self.partitionOption_partitionOptionMaxRows(parent=current)
        elif choice == 5:
            self.partitionOption_partitionOptionMinRows(parent=current)
        elif choice == 6:
            self.partitionOption_partitionOptionTablespace(parent=current)
        elif choice == 7:
            self.partitionOption_partitionOptionNodeGroup(parent=current)
        self.exit_rule(current)
        return current
    partitionOption.min_depth = 3

    @depthcontrol
    def alterDatabase(self, parent=None):
        current = UnparserRule(name='alterDatabase', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.alterDatabase_alterSimpleDatabase(parent=current)
        elif choice == 1:
            self.alterDatabase_alterUpgradeName(parent=current)
        self.exit_rule(current)
        return current
    alterDatabase.min_depth = 3

    @depthcontrol
    def alterEvent(self, parent=None):
        current = UnparserRule(name='alterEvent', parent=parent)
        self.enter_rule(current)
        self.ALTER(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ownerStatement(parent=current)
        self.EVENT(parent=current)
        self.fullId(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.ON(parent=current)
                self.SCHEDULE(parent=current)
                self.scheduleExpression(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.ON(parent=current)
                self.COMPLETION(parent=current)
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 3, min=0, max=1):
                        self.NOT(parent=current)
                self.PRESERVE(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.RENAME(parent=current)
                self.TO(parent=current)
                self.fullId(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 5, min=0, max=1):
                self.enableType(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 6, min=0, max=1):
                self.COMMENT(parent=current)
                self.STRING_LITERAL(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 7, min=0, max=1):
                self.DO(parent=current)
                self.routineBody(parent=current)
        self.exit_rule(current)
        return current
    alterEvent.min_depth = 3

    @depthcontrol
    def alterFunction(self, parent=None):
        current = UnparserRule(name='alterFunction', parent=parent)
        self.enter_rule(current)
        self.ALTER(parent=current)
        self.FUNCTION(parent=current)
        self.fullId(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.routineOption(parent=current)
        self.exit_rule(current)
        return current
    alterFunction.min_depth = 3

    @depthcontrol
    def alterInstance(self, parent=None):
        current = UnparserRule(name='alterInstance', parent=parent)
        self.enter_rule(current)
        self.ALTER(parent=current)
        self.INSTANCE(parent=current)
        self.ROTATE(parent=current)
        self.INNODB(parent=current)
        self.MASTER(parent=current)
        self.KEY(parent=current)
        self.exit_rule(current)
        return current
    alterInstance.min_depth = 1

    @depthcontrol
    def alterLogfileGroup(self, parent=None):
        current = UnparserRule(name='alterLogfileGroup', parent=parent)
        self.enter_rule(current)
        self.ALTER(parent=current)
        self.LOGFILE(parent=current)
        self.GROUP(parent=current)
        self.uid(parent=current)
        self.ADD(parent=current)
        self.UNDOFILE(parent=current)
        self.STRING_LITERAL(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.INITIAL_SIZE(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        UnlexerRule(src='=', parent=current)
                self.fileSizeLiteral(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.WAIT(parent=current)
        self.ENGINE(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.engineName(parent=current)
        self.exit_rule(current)
        return current
    alterLogfileGroup.min_depth = 2

    @depthcontrol
    def alterProcedure(self, parent=None):
        current = UnparserRule(name='alterProcedure', parent=parent)
        self.enter_rule(current)
        self.ALTER(parent=current)
        self.PROCEDURE(parent=current)
        self.fullId(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.routineOption(parent=current)
        self.exit_rule(current)
        return current
    alterProcedure.min_depth = 3

    @depthcontrol
    def alterServer(self, parent=None):
        current = UnparserRule(name='alterServer', parent=parent)
        self.enter_rule(current)
        self.ALTER(parent=current)
        self.SERVER(parent=current)
        self.uid(parent=current)
        self.OPTIONS(parent=current)
        UnlexerRule(src='(', parent=current)
        self.serverOption(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.serverOption(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    alterServer.min_depth = 3

    @depthcontrol
    def alterTable(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterTable', parent=parent)
        self.enter_rule(current)
        self.ALTER(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.ONLINE(parent=current)
                elif choice == 1:
                    self.OFFLINE(parent=current)
                local_ctx['intimeAction'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.IGNORE(parent=current)
        self.TABLE(parent=current)
        self.tableName(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.alterSpecification(parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 3, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.alterSpecification(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.partitionDefinitions(parent=current)
        self.exit_rule(current)
        return current
    alterTable.min_depth = 4

    @depthcontrol
    def alterTablespace(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterTablespace', parent=parent)
        self.enter_rule(current)
        self.ALTER(parent=current)
        self.TABLESPACE(parent=current)
        self.uid(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.ADD(parent=current)
        elif choice == 1:
            self.DROP(parent=current)
        local_ctx['objectAction'] = current.last_child
        self.DATAFILE(parent=current)
        self.STRING_LITERAL(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.INITIAL_SIZE(parent=current)
                UnlexerRule(src='=', parent=current)
                self.fileSizeLiteral(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.WAIT(parent=current)
        self.ENGINE(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.engineName(parent=current)
        self.exit_rule(current)
        return current
    alterTablespace.min_depth = 2

    @depthcontrol
    def alterView(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterView', parent=parent)
        self.enter_rule(current)
        self.ALTER(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ALGORITHM(parent=current)
                UnlexerRule(src='=', parent=current)
                choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    self.UNDEFINED(parent=current)
                elif choice == 1:
                    self.MERGE(parent=current)
                elif choice == 2:
                    self.TEMPTABLE(parent=current)
                local_ctx['algType'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.ownerStatement(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.SQL(parent=current)
                self.SECURITY(parent=current)
                choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.DEFINER(parent=current)
                elif choice == 1:
                    self.INVOKER(parent=current)
                local_ctx['secContext'] = current.last_child
        self.VIEW(parent=current)
        self.fullId(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                UnlexerRule(src='(', parent=current)
                self.uidList(parent=current)
                UnlexerRule(src=')', parent=current)
        self.AS(parent=current)
        self.selectStatement(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.WITH(parent=current)
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 5, min=0, max=1):
                        choice = self.model.choice(current, 2, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                        if choice == 0:
                            self.CASCADED(parent=current)
                        elif choice == 1:
                            self.LOCAL(parent=current)
                        local_ctx['checkOpt'] = current.last_child
                self.CHECK(parent=current)
                self.OPTION(parent=current)
        self.exit_rule(current)
        return current
    alterView.min_depth = 4

    @depthcontrol
    def alterSpecification(self, parent=None):
        current = UnparserRule(name='alterSpecification', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 5, 5, 5, 5, 5, 5, 6, 9, 2, 3, 5, 3, 2, 5, 3, 3, 2, 3, 3, 3, 3, 2, 2, 3, 4, 3, 3, 2, 2, 2, 2, 5, 4, 2, 2, 2, 3, 5, 5, 2, 2, 2, 2, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.alterSpecification_alterByTableOption(parent=current)
        elif choice == 1:
            self.alterSpecification_alterByAddColumn(parent=current)
        elif choice == 2:
            self.alterSpecification_alterByAddColumns(parent=current)
        elif choice == 3:
            self.alterSpecification_alterByAddIndex(parent=current)
        elif choice == 4:
            self.alterSpecification_alterByAddPrimaryKey(parent=current)
        elif choice == 5:
            self.alterSpecification_alterByAddUniqueKey(parent=current)
        elif choice == 6:
            self.alterSpecification_alterByAddSpecialIndex(parent=current)
        elif choice == 7:
            self.alterSpecification_alterByAddForeignKey(parent=current)
        elif choice == 8:
            self.alterSpecification_alterByAddCheckTableConstraint(parent=current)
        elif choice == 9:
            self.alterSpecification_alterBySetAlgorithm(parent=current)
        elif choice == 10:
            self.alterSpecification_alterByChangeDefault(parent=current)
        elif choice == 11:
            self.alterSpecification_alterByChangeColumn(parent=current)
        elif choice == 12:
            self.alterSpecification_alterByRenameColumn(parent=current)
        elif choice == 13:
            self.alterSpecification_alterByLock(parent=current)
        elif choice == 14:
            self.alterSpecification_alterByModifyColumn(parent=current)
        elif choice == 15:
            self.alterSpecification_alterByDropColumn(parent=current)
        elif choice == 16:
            self.alterSpecification_alterByDropConstraintCheck(parent=current)
        elif choice == 17:
            self.alterSpecification_alterByDropPrimaryKey(parent=current)
        elif choice == 18:
            self.alterSpecification_alterByRenameIndex(parent=current)
        elif choice == 19:
            self.alterSpecification_alterByAlterIndexVisibility(parent=current)
        elif choice == 20:
            self.alterSpecification_alterByDropIndex(parent=current)
        elif choice == 21:
            self.alterSpecification_alterByDropForeignKey(parent=current)
        elif choice == 22:
            self.alterSpecification_alterByDisableKeys(parent=current)
        elif choice == 23:
            self.alterSpecification_alterByEnableKeys(parent=current)
        elif choice == 24:
            self.alterSpecification_alterByRename(parent=current)
        elif choice == 25:
            self.alterSpecification_alterByOrder(parent=current)
        elif choice == 26:
            self.alterSpecification_alterByConvertCharset(parent=current)
        elif choice == 27:
            self.alterSpecification_alterByDefaultCharset(parent=current)
        elif choice == 28:
            self.alterSpecification_alterByDiscardTablespace(parent=current)
        elif choice == 29:
            self.alterSpecification_alterByImportTablespace(parent=current)
        elif choice == 30:
            self.alterSpecification_alterByForce(parent=current)
        elif choice == 31:
            self.alterSpecification_alterByValidate(parent=current)
        elif choice == 32:
            self.alterSpecification_alterByAddPartition(parent=current)
        elif choice == 33:
            self.alterSpecification_alterByDropPartition(parent=current)
        elif choice == 34:
            self.alterSpecification_alterByDiscardPartition(parent=current)
        elif choice == 35:
            self.alterSpecification_alterByImportPartition(parent=current)
        elif choice == 36:
            self.alterSpecification_alterByTruncatePartition(parent=current)
        elif choice == 37:
            self.alterSpecification_alterByCoalescePartition(parent=current)
        elif choice == 38:
            self.alterSpecification_alterByReorganizePartition(parent=current)
        elif choice == 39:
            self.alterSpecification_alterByExchangePartition(parent=current)
        elif choice == 40:
            self.alterSpecification_alterByAnalyzePartition(parent=current)
        elif choice == 41:
            self.alterSpecification_alterByCheckPartition(parent=current)
        elif choice == 42:
            self.alterSpecification_alterByOptimizePartition(parent=current)
        elif choice == 43:
            self.alterSpecification_alterByRebuildPartition(parent=current)
        elif choice == 44:
            self.alterSpecification_alterByRepairPartition(parent=current)
        elif choice == 45:
            self.alterSpecification_alterByRemovePartitioning(parent=current)
        elif choice == 46:
            self.alterSpecification_alterByUpgradePartitioning(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification.min_depth = 2

    @depthcontrol
    def dropDatabase(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='dropDatabase', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.DATABASE(parent=current)
        elif choice == 1:
            self.SCHEMA(parent=current)
        local_ctx['dbFormat'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ifExists(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    dropDatabase.min_depth = 2

    @depthcontrol
    def dropEvent(self, parent=None):
        current = UnparserRule(name='dropEvent', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        self.EVENT(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ifExists(parent=current)
        self.fullId(parent=current)
        self.exit_rule(current)
        return current
    dropEvent.min_depth = 3

    @depthcontrol
    def dropIndex(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='dropIndex', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        self.INDEX(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.ONLINE(parent=current)
                elif choice == 1:
                    self.OFFLINE(parent=current)
                local_ctx['intimeAction'] = current.last_child
        self.uid(parent=current)
        self.ON(parent=current)
        self.tableName(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.ALGORITHM(parent=current)
                    if self.max_depth >= 0:
                        for _ in self.model.quantify(current, 2, min=0, max=1):
                            UnlexerRule(src='=', parent=current)
                    choice = self.model.choice(current, 2, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                    if choice == 0:
                        self.DEFAULT(parent=current)
                    elif choice == 1:
                        self.INPLACE(parent=current)
                    elif choice == 2:
                        self.COPY(parent=current)
                    local_ctx['algType'] = current.last_child
                elif choice == 1:
                    self.LOCK(parent=current)
                    if self.max_depth >= 0:
                        for _ in self.model.quantify(current, 3, min=0, max=1):
                            UnlexerRule(src='=', parent=current)
                    choice = self.model.choice(current, 3, [0 if [1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
                    if choice == 0:
                        self.DEFAULT(parent=current)
                    elif choice == 1:
                        self.NONE(parent=current)
                    elif choice == 2:
                        self.SHARED(parent=current)
                    elif choice == 3:
                        self.EXCLUSIVE(parent=current)
                    local_ctx['lockType'] = current.last_child
        self.exit_rule(current)
        return current
    dropIndex.min_depth = 4

    @depthcontrol
    def dropLogfileGroup(self, parent=None):
        current = UnparserRule(name='dropLogfileGroup', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        self.LOGFILE(parent=current)
        self.GROUP(parent=current)
        self.uid(parent=current)
        self.ENGINE(parent=current)
        UnlexerRule(src='=', parent=current)
        self.engineName(parent=current)
        self.exit_rule(current)
        return current
    dropLogfileGroup.min_depth = 2

    @depthcontrol
    def dropProcedure(self, parent=None):
        current = UnparserRule(name='dropProcedure', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        self.PROCEDURE(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ifExists(parent=current)
        self.fullId(parent=current)
        self.exit_rule(current)
        return current
    dropProcedure.min_depth = 3

    @depthcontrol
    def dropFunction(self, parent=None):
        current = UnparserRule(name='dropFunction', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        self.FUNCTION(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ifExists(parent=current)
        self.fullId(parent=current)
        self.exit_rule(current)
        return current
    dropFunction.min_depth = 3

    @depthcontrol
    def dropServer(self, parent=None):
        current = UnparserRule(name='dropServer', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        self.SERVER(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ifExists(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    dropServer.min_depth = 2

    @depthcontrol
    def dropTable(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='dropTable', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.TEMPORARY(parent=current)
        self.TABLE(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.ifExists(parent=current)
        self.tables(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.RESTRICT(parent=current)
                elif choice == 1:
                    self.CASCADE(parent=current)
                local_ctx['dropType'] = current.last_child
        self.exit_rule(current)
        return current
    dropTable.min_depth = 5

    @depthcontrol
    def dropTablespace(self, parent=None):
        current = UnparserRule(name='dropTablespace', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        self.TABLESPACE(parent=current)
        self.uid(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ENGINE(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        UnlexerRule(src='=', parent=current)
                self.engineName(parent=current)
        self.exit_rule(current)
        return current
    dropTablespace.min_depth = 2

    @depthcontrol
    def dropTrigger(self, parent=None):
        current = UnparserRule(name='dropTrigger', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        self.TRIGGER(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ifExists(parent=current)
        self.fullId(parent=current)
        self.exit_rule(current)
        return current
    dropTrigger.min_depth = 3

    @depthcontrol
    def dropView(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='dropView', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        self.VIEW(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ifExists(parent=current)
        self.fullId(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.fullId(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.RESTRICT(parent=current)
                elif choice == 1:
                    self.CASCADE(parent=current)
                local_ctx['dropType'] = current.last_child
        self.exit_rule(current)
        return current
    dropView.min_depth = 3

    @depthcontrol
    def renameTable(self, parent=None):
        current = UnparserRule(name='renameTable', parent=parent)
        self.enter_rule(current)
        self.RENAME(parent=current)
        self.TABLE(parent=current)
        self.renameTableClause(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.renameTableClause(parent=current)
        self.exit_rule(current)
        return current
    renameTable.min_depth = 5

    @depthcontrol
    def renameTableClause(self, parent=None):
        current = UnparserRule(name='renameTableClause', parent=parent)
        self.enter_rule(current)
        self.tableName(parent=current)
        self.TO(parent=current)
        self.tableName(parent=current)
        self.exit_rule(current)
        return current
    renameTableClause.min_depth = 4

    @depthcontrol
    def truncateTable(self, parent=None):
        current = UnparserRule(name='truncateTable', parent=parent)
        self.enter_rule(current)
        self.TRUNCATE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.TABLE(parent=current)
        self.tableName(parent=current)
        self.exit_rule(current)
        return current
    truncateTable.min_depth = 4

    @depthcontrol
    def callStatement(self, parent=None):
        current = UnparserRule(name='callStatement', parent=parent)
        self.enter_rule(current)
        self.CALL(parent=current)
        self.fullId(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='(', parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        choice = self.model.choice(current, 0, [0 if [3, 9][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                        if choice == 0:
                            self.constants(parent=current)
                        elif choice == 1:
                            self.expressions(parent=current)
                UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    callStatement.min_depth = 3

    @depthcontrol
    def deleteStatement(self, parent=None):
        current = UnparserRule(name='deleteStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 10][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.singleDeleteStatement(parent=current)
        elif choice == 1:
            self.multipleDeleteStatement(parent=current)
        self.exit_rule(current)
        return current
    deleteStatement.min_depth = 5

    @depthcontrol
    def doStatement(self, parent=None):
        current = UnparserRule(name='doStatement', parent=parent)
        self.enter_rule(current)
        self.DO(parent=current)
        self.expressions(parent=current)
        self.exit_rule(current)
        return current
    doStatement.min_depth = 9

    @depthcontrol
    def handlerStatement(self, parent=None):
        current = UnparserRule(name='handlerStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 5, 5, 5][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.handlerOpenStatement(parent=current)
        elif choice == 1:
            self.handlerReadIndexStatement(parent=current)
        elif choice == 2:
            self.handlerReadStatement(parent=current)
        elif choice == 3:
            self.handlerCloseStatement(parent=current)
        self.exit_rule(current)
        return current
    handlerStatement.min_depth = 5

    @depthcontrol
    def insertStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='insertStatement', parent=parent)
        self.enter_rule(current)
        self.INSERT(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    self.LOW_PRIORITY(parent=current)
                elif choice == 1:
                    self.DELAYED(parent=current)
                elif choice == 2:
                    self.HIGH_PRIORITY(parent=current)
                local_ctx['priority'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.IGNORE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.INTO(parent=current)
        self.tableName(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.PARTITION(parent=current)
                UnlexerRule(src='(', parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 4, min=0, max=1):
                        self.uidList(parent=current)
                        local_ctx['partitions'] = current.last_child
                UnlexerRule(src=')', parent=current)
        choice = self.model.choice(current, 1, [0 if [2, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 5, min=0, max=1):
                    UnlexerRule(src='(', parent=current)
                    self.uidList(parent=current)
                    local_ctx['columns'] = current.last_child
                    UnlexerRule(src=')', parent=current)
            self.insertStatementValue(parent=current)
        elif choice == 1:
            self.SET(parent=current)
            self.updatedElement(parent=current)
            local_ctx['setFirst'] = current.last_child
            if self.max_depth >= 4:
                for _ in self.model.quantify(current, 6, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.updatedElement(parent=current)
                    local_ctx['setElements'] = current.last_child
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 7, min=0, max=1):
                self.ON(parent=current)
                self.DUPLICATE(parent=current)
                self.KEY(parent=current)
                self.UPDATE(parent=current)
                self.updatedElement(parent=current)
                local_ctx['duplicatedFirst'] = current.last_child
                if self.max_depth >= 4:
                    for _ in self.model.quantify(current, 8, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.updatedElement(parent=current)
                        local_ctx['duplicatedElements'] = current.last_child
        self.exit_rule(current)
        return current
    insertStatement.min_depth = 4

    @depthcontrol
    def loadDataStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='loadDataStatement', parent=parent)
        self.enter_rule(current)
        self.LOAD(parent=current)
        self.DATA(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.LOW_PRIORITY(parent=current)
                elif choice == 1:
                    self.CONCURRENT(parent=current)
                local_ctx['priority'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.LOCAL(parent=current)
        self.INFILE(parent=current)
        self.STRING_LITERAL(parent=current)
        local_ctx['filename'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.REPLACE(parent=current)
                elif choice == 1:
                    self.IGNORE(parent=current)
                local_ctx['violation'] = current.last_child
        self.INTO(parent=current)
        self.TABLE(parent=current)
        self.tableName(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.PARTITION(parent=current)
                UnlexerRule(src='(', parent=current)
                self.uidList(parent=current)
                UnlexerRule(src=')', parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.CHARACTER(parent=current)
                self.SET(parent=current)
                self.charsetName(parent=current)
                local_ctx['charset'] = current.last_child
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 5, min=0, max=1):
                choice = self.model.choice(current, 2, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.FIELDS(parent=current)
                elif choice == 1:
                    self.COLUMNS(parent=current)
                local_ctx['fieldsFormat'] = current.last_child
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 6, min=1, max=inf):
                        self.selectFieldsInto(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 7, min=0, max=1):
                self.LINES(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 8, min=1, max=inf):
                        self.selectLinesInto(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 9, min=0, max=1):
                self.IGNORE(parent=current)
                self.decimalLiteral(parent=current)
                choice = self.model.choice(current, 3, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.LINES(parent=current)
                elif choice == 1:
                    self.ROWS(parent=current)
                local_ctx['linesFormat'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 10, min=0, max=1):
                UnlexerRule(src='(', parent=current)
                self.assignmentField(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 11, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.assignmentField(parent=current)
                UnlexerRule(src=')', parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 12, min=0, max=1):
                self.SET(parent=current)
                self.updatedElement(parent=current)
                if self.max_depth >= 4:
                    for _ in self.model.quantify(current, 13, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.updatedElement(parent=current)
        self.exit_rule(current)
        return current
    loadDataStatement.min_depth = 4

    @depthcontrol
    def loadXmlStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='loadXmlStatement', parent=parent)
        self.enter_rule(current)
        self.LOAD(parent=current)
        self.XML(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.LOW_PRIORITY(parent=current)
                elif choice == 1:
                    self.CONCURRENT(parent=current)
                local_ctx['priority'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.LOCAL(parent=current)
        self.INFILE(parent=current)
        self.STRING_LITERAL(parent=current)
        local_ctx['filename'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.REPLACE(parent=current)
                elif choice == 1:
                    self.IGNORE(parent=current)
                local_ctx['violation'] = current.last_child
        self.INTO(parent=current)
        self.TABLE(parent=current)
        self.tableName(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.CHARACTER(parent=current)
                self.SET(parent=current)
                self.charsetName(parent=current)
                local_ctx['charset'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.ROWS(parent=current)
                self.IDENTIFIED(parent=current)
                self.BY(parent=current)
                UnlexerRule(src='<', parent=current)
                self.STRING_LITERAL(parent=current)
                local_ctx['tag'] = current.last_child
                UnlexerRule(src='>', parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 5, min=0, max=1):
                self.IGNORE(parent=current)
                self.decimalLiteral(parent=current)
                choice = self.model.choice(current, 2, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.LINES(parent=current)
                elif choice == 1:
                    self.ROWS(parent=current)
                local_ctx['linesFormat'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 6, min=0, max=1):
                UnlexerRule(src='(', parent=current)
                self.assignmentField(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 7, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.assignmentField(parent=current)
                UnlexerRule(src=')', parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 8, min=0, max=1):
                self.SET(parent=current)
                self.updatedElement(parent=current)
                if self.max_depth >= 4:
                    for _ in self.model.quantify(current, 9, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.updatedElement(parent=current)
        self.exit_rule(current)
        return current
    loadXmlStatement.min_depth = 4

    @depthcontrol
    def replaceStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='replaceStatement', parent=parent)
        self.enter_rule(current)
        self.REPLACE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.LOW_PRIORITY(parent=current)
                elif choice == 1:
                    self.DELAYED(parent=current)
                local_ctx['priority'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.INTO(parent=current)
        self.tableName(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.PARTITION(parent=current)
                UnlexerRule(src='(', parent=current)
                self.uidList(parent=current)
                local_ctx['partitions'] = current.last_child
                UnlexerRule(src=')', parent=current)
        choice = self.model.choice(current, 1, [0 if [2, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 3, min=0, max=1):
                    UnlexerRule(src='(', parent=current)
                    self.uidList(parent=current)
                    local_ctx['columns'] = current.last_child
                    UnlexerRule(src=')', parent=current)
            self.insertStatementValue(parent=current)
        elif choice == 1:
            self.SET(parent=current)
            self.updatedElement(parent=current)
            local_ctx['setFirst'] = current.last_child
            if self.max_depth >= 4:
                for _ in self.model.quantify(current, 4, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.updatedElement(parent=current)
                    local_ctx['setElements'] = current.last_child
        self.exit_rule(current)
        return current
    replaceStatement.min_depth = 4

    @depthcontrol
    def selectStatement(self, parent=None):
        current = UnparserRule(name='selectStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 4, 4, 5][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.selectStatement_simpleSelect(parent=current)
        elif choice == 1:
            self.selectStatement_parenthesisSelect(parent=current)
        elif choice == 2:
            self.selectStatement_unionSelect(parent=current)
        elif choice == 3:
            self.selectStatement_unionParenthesisSelect(parent=current)
        self.exit_rule(current)
        return current
    selectStatement.min_depth = 3

    @depthcontrol
    def updateStatement(self, parent=None):
        current = UnparserRule(name='updateStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 10][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.singleUpdateStatement(parent=current)
        elif choice == 1:
            self.multipleUpdateStatement(parent=current)
        self.exit_rule(current)
        return current
    updateStatement.min_depth = 5

    @depthcontrol
    def insertStatementValue(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='insertStatementValue', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.selectStatement(parent=current)
        elif choice == 1:
            choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.VALUES(parent=current)
            elif choice == 1:
                self.VALUE(parent=current)
            local_ctx['insertFormat'] = current.last_child
            UnlexerRule(src='(', parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.expressionsWithDefaults(parent=current)
            UnlexerRule(src=')', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 1, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    UnlexerRule(src='(', parent=current)
                    if self.max_depth >= 3:
                        for _ in self.model.quantify(current, 2, min=0, max=1):
                            self.expressionsWithDefaults(parent=current)
                    UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    insertStatementValue.min_depth = 1

    @depthcontrol
    def updatedElement(self, parent=None):
        current = UnparserRule(name='updatedElement', parent=parent)
        self.enter_rule(current)
        self.fullColumnName(parent=current)
        UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 0, [0 if [8, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.expression(parent=current)
        elif choice == 1:
            self.DEFAULT(parent=current)
        self.exit_rule(current)
        return current
    updatedElement.min_depth = 3

    @depthcontrol
    def assignmentField(self, parent=None):
        current = UnparserRule(name='assignmentField', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.uid(parent=current)
        elif choice == 1:
            self.LOCAL_ID(parent=current)
        self.exit_rule(current)
        return current
    assignmentField.min_depth = 1

    @depthcontrol
    def lockClause(self, parent=None):
        current = UnparserRule(name='lockClause', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.FOR(parent=current)
            self.UPDATE(parent=current)
        elif choice == 1:
            self.LOCK(parent=current)
            self.IN(parent=current)
            self.SHARE(parent=current)
            self.MODE(parent=current)
        self.exit_rule(current)
        return current
    lockClause.min_depth = 1

    @depthcontrol
    def singleDeleteStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='singleDeleteStatement', parent=parent)
        self.enter_rule(current)
        self.DELETE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.LOW_PRIORITY(parent=current)
                local_ctx['priority'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.QUICK(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.IGNORE(parent=current)
        self.FROM(parent=current)
        self.tableName(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.PARTITION(parent=current)
                UnlexerRule(src='(', parent=current)
                self.uidList(parent=current)
                UnlexerRule(src=')', parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.WHERE(parent=current)
                self.expression(parent=current)
        if self.max_depth >= 10:
            for _ in self.model.quantify(current, 5, min=0, max=1):
                self.orderByClause(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 6, min=0, max=1):
                self.LIMIT(parent=current)
                self.limitClauseAtom(parent=current)
        self.exit_rule(current)
        return current
    singleDeleteStatement.min_depth = 4

    @depthcontrol
    def multipleDeleteStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='multipleDeleteStatement', parent=parent)
        self.enter_rule(current)
        self.DELETE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.LOW_PRIORITY(parent=current)
                local_ctx['priority'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.QUICK(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.IGNORE(parent=current)
        choice = self.model.choice(current, 0, [0 if [9, 9][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.tableName(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 3, min=0, max=1):
                    UnlexerRule(src='.', parent=current)
                    UnlexerRule(src='*', parent=current)
            if self.max_depth >= 4:
                for _ in self.model.quantify(current, 4, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.tableName(parent=current)
                    if self.max_depth >= 0:
                        for _ in self.model.quantify(current, 5, min=0, max=1):
                            UnlexerRule(src='.', parent=current)
                            UnlexerRule(src='*', parent=current)
            self.FROM(parent=current)
            self.tableSources(parent=current)
        elif choice == 1:
            self.FROM(parent=current)
            self.tableName(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 6, min=0, max=1):
                    UnlexerRule(src='.', parent=current)
                    UnlexerRule(src='*', parent=current)
            if self.max_depth >= 4:
                for _ in self.model.quantify(current, 7, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.tableName(parent=current)
                    if self.max_depth >= 0:
                        for _ in self.model.quantify(current, 8, min=0, max=1):
                            UnlexerRule(src='.', parent=current)
                            UnlexerRule(src='*', parent=current)
            self.USING(parent=current)
            self.tableSources(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 9, min=0, max=1):
                self.WHERE(parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    multipleDeleteStatement.min_depth = 9

    @depthcontrol
    def handlerOpenStatement(self, parent=None):
        current = UnparserRule(name='handlerOpenStatement', parent=parent)
        self.enter_rule(current)
        self.HANDLER(parent=current)
        self.tableName(parent=current)
        self.OPEN(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.AS(parent=current)
                self.uid(parent=current)
        self.exit_rule(current)
        return current
    handlerOpenStatement.min_depth = 4

    @depthcontrol
    def handlerReadIndexStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='handlerReadIndexStatement', parent=parent)
        self.enter_rule(current)
        self.HANDLER(parent=current)
        self.tableName(parent=current)
        self.READ(parent=current)
        self.uid(parent=current)
        local_ctx['index'] = current.last_child
        choice = self.model.choice(current, 0, [0 if [3, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.comparisonOperator(parent=current)
            UnlexerRule(src='(', parent=current)
            self.constants(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 1:
            choice = self.model.choice(current, 1, [0 if [1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
            if choice == 0:
                self.FIRST(parent=current)
            elif choice == 1:
                self.NEXT(parent=current)
            elif choice == 2:
                self.PREV(parent=current)
            elif choice == 3:
                self.LAST(parent=current)
            local_ctx['moveOrder'] = current.last_child
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.WHERE(parent=current)
                self.expression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.LIMIT(parent=current)
                self.limitClauseAtom(parent=current)
        self.exit_rule(current)
        return current
    handlerReadIndexStatement.min_depth = 4

    @depthcontrol
    def handlerReadStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='handlerReadStatement', parent=parent)
        self.enter_rule(current)
        self.HANDLER(parent=current)
        self.tableName(parent=current)
        self.READ(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.FIRST(parent=current)
        elif choice == 1:
            self.NEXT(parent=current)
        local_ctx['moveOrder'] = current.last_child
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.WHERE(parent=current)
                self.expression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.LIMIT(parent=current)
                self.limitClauseAtom(parent=current)
        self.exit_rule(current)
        return current
    handlerReadStatement.min_depth = 4

    @depthcontrol
    def handlerCloseStatement(self, parent=None):
        current = UnparserRule(name='handlerCloseStatement', parent=parent)
        self.enter_rule(current)
        self.HANDLER(parent=current)
        self.tableName(parent=current)
        self.CLOSE(parent=current)
        self.exit_rule(current)
        return current
    handlerCloseStatement.min_depth = 4

    @depthcontrol
    def singleUpdateStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='singleUpdateStatement', parent=parent)
        self.enter_rule(current)
        self.UPDATE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.LOW_PRIORITY(parent=current)
                local_ctx['priority'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.IGNORE(parent=current)
        self.tableName(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 3, min=0, max=1):
                        self.AS(parent=current)
                self.uid(parent=current)
        self.SET(parent=current)
        self.updatedElement(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 4, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.updatedElement(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 5, min=0, max=1):
                self.WHERE(parent=current)
                self.expression(parent=current)
        if self.max_depth >= 10:
            for _ in self.model.quantify(current, 6, min=0, max=1):
                self.orderByClause(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 7, min=0, max=1):
                self.limitClause(parent=current)
        self.exit_rule(current)
        return current
    singleUpdateStatement.min_depth = 4

    @depthcontrol
    def multipleUpdateStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='multipleUpdateStatement', parent=parent)
        self.enter_rule(current)
        self.UPDATE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.LOW_PRIORITY(parent=current)
                local_ctx['priority'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.IGNORE(parent=current)
        self.tableSources(parent=current)
        self.SET(parent=current)
        self.updatedElement(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 2, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.updatedElement(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.WHERE(parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    multipleUpdateStatement.min_depth = 9

    @depthcontrol
    def orderByClause(self, parent=None):
        current = UnparserRule(name='orderByClause', parent=parent)
        self.enter_rule(current)
        self.ORDER(parent=current)
        self.BY(parent=current)
        self.orderByExpression(parent=current)
        if self.max_depth >= 9:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.orderByExpression(parent=current)
        self.exit_rule(current)
        return current
    orderByClause.min_depth = 9

    @depthcontrol
    def orderByExpression(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='orderByExpression', parent=parent)
        self.enter_rule(current)
        self.expression(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.ASC(parent=current)
                elif choice == 1:
                    self.DESC(parent=current)
                local_ctx['order'] = current.last_child
        self.exit_rule(current)
        return current
    orderByExpression.min_depth = 8

    @depthcontrol
    def tableSources(self, parent=None):
        current = UnparserRule(name='tableSources', parent=parent)
        self.enter_rule(current)
        self.tableSource(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.tableSource(parent=current)
        self.exit_rule(current)
        return current
    tableSources.min_depth = 8

    @depthcontrol
    def tableSource(self, parent=None):
        current = UnparserRule(name='tableSource', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [7, 7][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.tableSource_tableSourceBase(parent=current)
        elif choice == 1:
            self.tableSource_tableSourceNested(parent=current)
        self.exit_rule(current)
        return current
    tableSource.min_depth = 7

    @depthcontrol
    def tableSourceItem(self, parent=None):
        current = UnparserRule(name='tableSourceItem', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 5, 10][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.tableSourceItem_atomTableItem(parent=current)
        elif choice == 1:
            self.tableSourceItem_subqueryTableItem(parent=current)
        elif choice == 2:
            self.tableSourceItem_tableSourcesItem(parent=current)
        self.exit_rule(current)
        return current
    tableSourceItem.min_depth = 5

    @depthcontrol
    def indexHint(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='indexHint', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.USE(parent=current)
        elif choice == 1:
            self.IGNORE(parent=current)
        elif choice == 2:
            self.FORCE(parent=current)
        local_ctx['indexHintAction'] = current.last_child
        choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.INDEX(parent=current)
        elif choice == 1:
            self.KEY(parent=current)
        local_ctx['keyFormat'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.FOR(parent=current)
                self.indexHintType(parent=current)
        UnlexerRule(src='(', parent=current)
        self.uidList(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    indexHint.min_depth = 3

    @depthcontrol
    def indexHintType(self, parent=None):
        current = UnparserRule(name='indexHintType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.JOIN(parent=current)
        elif choice == 1:
            self.ORDER(parent=current)
            self.BY(parent=current)
        elif choice == 2:
            self.GROUP(parent=current)
            self.BY(parent=current)
        self.exit_rule(current)
        return current
    indexHintType.min_depth = 1

    @depthcontrol
    def joinPart(self, parent=None):
        current = UnparserRule(name='joinPart', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [7, 7, 7, 7][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.joinPart_innerJoin(parent=current)
        elif choice == 1:
            self.joinPart_straightJoin(parent=current)
        elif choice == 2:
            self.joinPart_outerJoin(parent=current)
        elif choice == 3:
            self.joinPart_naturalJoin(parent=current)
        self.exit_rule(current)
        return current
    joinPart.min_depth = 7

    @depthcontrol
    def queryExpression(self, parent=None):
        current = UnparserRule(name='queryExpression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='(', parent=current)
            self.querySpecification(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 1:
            UnlexerRule(src='(', parent=current)
            self.queryExpression(parent=current)
            UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    queryExpression.min_depth = 2

    @depthcontrol
    def queryExpressionNointo(self, parent=None):
        current = UnparserRule(name='queryExpressionNointo', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='(', parent=current)
            self.querySpecificationNointo(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 1:
            UnlexerRule(src='(', parent=current)
            self.queryExpressionNointo(parent=current)
            UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    queryExpressionNointo.min_depth = 2

    @depthcontrol
    def querySpecification(self, parent=None):
        current = UnparserRule(name='querySpecification', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.SELECT(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    self.selectSpec(parent=current)
            self.selectElements(parent=current)
            if self.max_depth >= 4:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    self.selectIntoExpression(parent=current)
            if self.max_depth >= 10:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    self.fromClause(parent=current)
            if self.max_depth >= 10:
                for _ in self.model.quantify(current, 3, min=0, max=1):
                    self.groupByClause(parent=current)
            if self.max_depth >= 9:
                for _ in self.model.quantify(current, 4, min=0, max=1):
                    self.havingClause(parent=current)
            if self.max_depth >= 10:
                for _ in self.model.quantify(current, 5, min=0, max=1):
                    self.orderByClause(parent=current)
            if self.max_depth >= 4:
                for _ in self.model.quantify(current, 6, min=0, max=1):
                    self.limitClause(parent=current)
        elif choice == 1:
            self.SELECT(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 7, min=0, max=inf):
                    self.selectSpec(parent=current)
            self.selectElements(parent=current)
            if self.max_depth >= 10:
                for _ in self.model.quantify(current, 8, min=0, max=1):
                    self.fromClause(parent=current)
            if self.max_depth >= 10:
                for _ in self.model.quantify(current, 9, min=0, max=1):
                    self.groupByClause(parent=current)
            if self.max_depth >= 9:
                for _ in self.model.quantify(current, 10, min=0, max=1):
                    self.havingClause(parent=current)
            if self.max_depth >= 10:
                for _ in self.model.quantify(current, 11, min=0, max=1):
                    self.orderByClause(parent=current)
            if self.max_depth >= 4:
                for _ in self.model.quantify(current, 12, min=0, max=1):
                    self.limitClause(parent=current)
            if self.max_depth >= 4:
                for _ in self.model.quantify(current, 13, min=0, max=1):
                    self.selectIntoExpression(parent=current)
        self.exit_rule(current)
        return current
    querySpecification.min_depth = 1

    @depthcontrol
    def querySpecificationNointo(self, parent=None):
        current = UnparserRule(name='querySpecificationNointo', parent=parent)
        self.enter_rule(current)
        self.SELECT(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.selectSpec(parent=current)
        self.selectElements(parent=current)
        if self.max_depth >= 10:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.fromClause(parent=current)
        if self.max_depth >= 10:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.groupByClause(parent=current)
        if self.max_depth >= 9:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.havingClause(parent=current)
        if self.max_depth >= 10:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.orderByClause(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 5, min=0, max=1):
                self.limitClause(parent=current)
        self.exit_rule(current)
        return current
    querySpecificationNointo.min_depth = 1

    @depthcontrol
    def unionParenthesis(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='unionParenthesis', parent=parent)
        self.enter_rule(current)
        self.UNION(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.ALL(parent=current)
                elif choice == 1:
                    self.DISTINCT(parent=current)
                local_ctx['unionType'] = current.last_child
        self.queryExpressionNointo(parent=current)
        self.exit_rule(current)
        return current
    unionParenthesis.min_depth = 3

    @depthcontrol
    def unionStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='unionStatement', parent=parent)
        self.enter_rule(current)
        self.UNION(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.ALL(parent=current)
                elif choice == 1:
                    self.DISTINCT(parent=current)
                local_ctx['unionType'] = current.last_child
        choice = self.model.choice(current, 1, [0 if [2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.querySpecificationNointo(parent=current)
        elif choice == 1:
            self.queryExpressionNointo(parent=current)
        self.exit_rule(current)
        return current
    unionStatement.min_depth = 2

    @depthcontrol
    def selectSpec(self, parent=None):
        current = UnparserRule(name='selectSpec', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            choice = self.model.choice(current, 1, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
            if choice == 0:
                self.ALL(parent=current)
            elif choice == 1:
                self.DISTINCT(parent=current)
            elif choice == 2:
                self.DISTINCTROW(parent=current)
        elif choice == 1:
            self.HIGH_PRIORITY(parent=current)
        elif choice == 2:
            self.STRAIGHT_JOIN(parent=current)
        elif choice == 3:
            self.SQL_SMALL_RESULT(parent=current)
        elif choice == 4:
            self.SQL_BIG_RESULT(parent=current)
        elif choice == 5:
            self.SQL_BUFFER_RESULT(parent=current)
        elif choice == 6:
            choice = self.model.choice(current, 2, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.SQL_CACHE(parent=current)
            elif choice == 1:
                self.SQL_NO_CACHE(parent=current)
        elif choice == 7:
            self.SQL_CALC_FOUND_ROWS(parent=current)
        self.exit_rule(current)
        return current
    selectSpec.min_depth = 1

    @depthcontrol
    def selectElements(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='selectElements', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 5][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='*', parent=current)
            local_ctx['star'] = current.last_child
        elif choice == 1:
            self.selectElement(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.selectElement(parent=current)
        self.exit_rule(current)
        return current
    selectElements.min_depth = 0

    @depthcontrol
    def selectElement(self, parent=None):
        current = UnparserRule(name='selectElement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 4, 5, 9][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.selectElement_selectStarElement(parent=current)
        elif choice == 1:
            self.selectElement_selectColumnElement(parent=current)
        elif choice == 2:
            self.selectElement_selectFunctionElement(parent=current)
        elif choice == 3:
            self.selectElement_selectExpressionElement(parent=current)
        self.exit_rule(current)
        return current
    selectElement.min_depth = 4

    @depthcontrol
    def selectIntoExpression(self, parent=None):
        current = UnparserRule(name='selectIntoExpression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.selectIntoExpression_selectIntoVariables(parent=current)
        elif choice == 1:
            self.selectIntoExpression_selectIntoDumpFile(parent=current)
        elif choice == 2:
            self.selectIntoExpression_selectIntoTextFile(parent=current)
        self.exit_rule(current)
        return current
    selectIntoExpression.min_depth = 3

    @depthcontrol
    def selectFieldsInto(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='selectFieldsInto', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.TERMINATED(parent=current)
            self.BY(parent=current)
            self.STRING_LITERAL(parent=current)
            local_ctx['terminationField'] = current.last_child
        elif choice == 1:
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.OPTIONALLY(parent=current)
            self.ENCLOSED(parent=current)
            self.BY(parent=current)
            self.STRING_LITERAL(parent=current)
            local_ctx['enclosion'] = current.last_child
        elif choice == 2:
            self.ESCAPED(parent=current)
            self.BY(parent=current)
            self.STRING_LITERAL(parent=current)
            local_ctx['escaping'] = current.last_child
        self.exit_rule(current)
        return current
    selectFieldsInto.min_depth = 2

    @depthcontrol
    def selectLinesInto(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='selectLinesInto', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.STARTING(parent=current)
            self.BY(parent=current)
            self.STRING_LITERAL(parent=current)
            local_ctx['starting'] = current.last_child
        elif choice == 1:
            self.TERMINATED(parent=current)
            self.BY(parent=current)
            self.STRING_LITERAL(parent=current)
            local_ctx['terminationLine'] = current.last_child
        self.exit_rule(current)
        return current
    selectLinesInto.min_depth = 2

    @depthcontrol
    def fromClause(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='fromClause', parent=parent)
        self.enter_rule(current)
        self.FROM(parent=current)
        self.tableSources(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.WHERE(parent=current)
                self.expression(parent=current)
                local_ctx['whereExpr'] = current.last_child
        self.exit_rule(current)
        return current
    fromClause.min_depth = 9

    @depthcontrol
    def groupByClause(self, parent=None):
        current = UnparserRule(name='groupByClause', parent=parent)
        self.enter_rule(current)
        self.GROUP(parent=current)
        self.BY(parent=current)
        self.groupByItem(parent=current)
        if self.max_depth >= 9:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.groupByItem(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.WITH(parent=current)
                self.ROLLUP(parent=current)
        self.exit_rule(current)
        return current
    groupByClause.min_depth = 9

    @depthcontrol
    def havingClause(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='havingClause', parent=parent)
        self.enter_rule(current)
        self.HAVING(parent=current)
        self.expression(parent=current)
        local_ctx['havingExpr'] = current.last_child
        self.exit_rule(current)
        return current
    havingClause.min_depth = 8

    @depthcontrol
    def groupByItem(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='groupByItem', parent=parent)
        self.enter_rule(current)
        self.expression(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.ASC(parent=current)
                elif choice == 1:
                    self.DESC(parent=current)
                local_ctx['order'] = current.last_child
        self.exit_rule(current)
        return current
    groupByItem.min_depth = 8

    @depthcontrol
    def limitClause(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='limitClause', parent=parent)
        self.enter_rule(current)
        self.LIMIT(parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.limitClauseAtom(parent=current)
                    local_ctx['offset'] = current.last_child
                    UnlexerRule(src=',', parent=current)
            self.limitClauseAtom(parent=current)
            local_ctx['limit'] = current.last_child
        elif choice == 1:
            self.limitClauseAtom(parent=current)
            local_ctx['limit'] = current.last_child
            self.OFFSET(parent=current)
            self.limitClauseAtom(parent=current)
            local_ctx['offset'] = current.last_child
        self.exit_rule(current)
        return current
    limitClause.min_depth = 3

    @depthcontrol
    def limitClauseAtom(self, parent=None):
        current = UnparserRule(name='limitClauseAtom', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.decimalLiteral(parent=current)
        elif choice == 1:
            self.mysqlVariable(parent=current)
        elif choice == 2:
            self.simpleId(parent=current)
        self.exit_rule(current)
        return current
    limitClauseAtom.min_depth = 2

    @depthcontrol
    def startTransaction(self, parent=None):
        current = UnparserRule(name='startTransaction', parent=parent)
        self.enter_rule(current)
        self.START(parent=current)
        self.TRANSACTION(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.transactionMode(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.transactionMode(parent=current)
        self.exit_rule(current)
        return current
    startTransaction.min_depth = 1

    @depthcontrol
    def beginWork(self, parent=None):
        current = UnparserRule(name='beginWork', parent=parent)
        self.enter_rule(current)
        self.BEGIN(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.WORK(parent=current)
        self.exit_rule(current)
        return current
    beginWork.min_depth = 1

    @depthcontrol
    def commitWork(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='commitWork', parent=parent)
        self.enter_rule(current)
        self.COMMIT(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.WORK(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.AND(parent=current)
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        self.NO(parent=current)
                        local_ctx['nochain'] = current.last_child
                self.CHAIN(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 4, min=0, max=1):
                        self.NO(parent=current)
                        local_ctx['norelease'] = current.last_child
                self.RELEASE(parent=current)
        self.exit_rule(current)
        return current
    commitWork.min_depth = 1

    @depthcontrol
    def rollbackWork(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='rollbackWork', parent=parent)
        self.enter_rule(current)
        self.ROLLBACK(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.WORK(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.AND(parent=current)
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        self.NO(parent=current)
                        local_ctx['nochain'] = current.last_child
                self.CHAIN(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 4, min=0, max=1):
                        self.NO(parent=current)
                        local_ctx['norelease'] = current.last_child
                self.RELEASE(parent=current)
        self.exit_rule(current)
        return current
    rollbackWork.min_depth = 1

    @depthcontrol
    def savepointStatement(self, parent=None):
        current = UnparserRule(name='savepointStatement', parent=parent)
        self.enter_rule(current)
        self.SAVEPOINT(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    savepointStatement.min_depth = 2

    @depthcontrol
    def rollbackStatement(self, parent=None):
        current = UnparserRule(name='rollbackStatement', parent=parent)
        self.enter_rule(current)
        self.ROLLBACK(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.WORK(parent=current)
        self.TO(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.SAVEPOINT(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    rollbackStatement.min_depth = 2

    @depthcontrol
    def releaseStatement(self, parent=None):
        current = UnparserRule(name='releaseStatement', parent=parent)
        self.enter_rule(current)
        self.RELEASE(parent=current)
        self.SAVEPOINT(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    releaseStatement.min_depth = 2

    @depthcontrol
    def lockTables(self, parent=None):
        current = UnparserRule(name='lockTables', parent=parent)
        self.enter_rule(current)
        self.LOCK(parent=current)
        self.TABLES(parent=current)
        self.lockTableElement(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.lockTableElement(parent=current)
        self.exit_rule(current)
        return current
    lockTables.min_depth = 5

    @depthcontrol
    def unlockTables(self, parent=None):
        current = UnparserRule(name='unlockTables', parent=parent)
        self.enter_rule(current)
        self.UNLOCK(parent=current)
        self.TABLES(parent=current)
        self.exit_rule(current)
        return current
    unlockTables.min_depth = 1

    @depthcontrol
    def setAutocommitStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='setAutocommitStatement', parent=parent)
        self.enter_rule(current)
        self.SET(parent=current)
        self.AUTOCOMMIT(parent=current)
        UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='0', parent=current)
        elif choice == 1:
            UnlexerRule(src='1', parent=current)
        local_ctx['autocommitValue'] = current.last_child
        self.exit_rule(current)
        return current
    setAutocommitStatement.min_depth = 1

    @depthcontrol
    def setTransactionStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='setTransactionStatement', parent=parent)
        self.enter_rule(current)
        self.SET(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.GLOBAL(parent=current)
                elif choice == 1:
                    self.SESSION(parent=current)
                local_ctx['transactionContext'] = current.last_child
        self.TRANSACTION(parent=current)
        self.transactionOption(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.transactionOption(parent=current)
        self.exit_rule(current)
        return current
    setTransactionStatement.min_depth = 2

    @depthcontrol
    def transactionMode(self, parent=None):
        current = UnparserRule(name='transactionMode', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.WITH(parent=current)
            self.CONSISTENT(parent=current)
            self.SNAPSHOT(parent=current)
        elif choice == 1:
            self.READ(parent=current)
            self.WRITE(parent=current)
        elif choice == 2:
            self.READ(parent=current)
            self.ONLY(parent=current)
        self.exit_rule(current)
        return current
    transactionMode.min_depth = 1

    @depthcontrol
    def lockTableElement(self, parent=None):
        current = UnparserRule(name='lockTableElement', parent=parent)
        self.enter_rule(current)
        self.tableName(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.AS(parent=current)
                self.uid(parent=current)
        self.lockAction(parent=current)
        self.exit_rule(current)
        return current
    lockTableElement.min_depth = 4

    @depthcontrol
    def lockAction(self, parent=None):
        current = UnparserRule(name='lockAction', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.READ(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.LOCAL(parent=current)
        elif choice == 1:
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    self.LOW_PRIORITY(parent=current)
            self.WRITE(parent=current)
        self.exit_rule(current)
        return current
    lockAction.min_depth = 1

    @depthcontrol
    def transactionOption(self, parent=None):
        current = UnparserRule(name='transactionOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.ISOLATION(parent=current)
            self.LEVEL(parent=current)
            self.transactionLevel(parent=current)
        elif choice == 1:
            self.READ(parent=current)
            self.WRITE(parent=current)
        elif choice == 2:
            self.READ(parent=current)
            self.ONLY(parent=current)
        self.exit_rule(current)
        return current
    transactionOption.min_depth = 1

    @depthcontrol
    def transactionLevel(self, parent=None):
        current = UnparserRule(name='transactionLevel', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.REPEATABLE(parent=current)
            self.READ(parent=current)
        elif choice == 1:
            self.READ(parent=current)
            self.COMMITTED(parent=current)
        elif choice == 2:
            self.READ(parent=current)
            self.UNCOMMITTED(parent=current)
        elif choice == 3:
            self.SERIALIZABLE(parent=current)
        self.exit_rule(current)
        return current
    transactionLevel.min_depth = 1

    @depthcontrol
    def changeMaster(self, parent=None):
        current = UnparserRule(name='changeMaster', parent=parent)
        self.enter_rule(current)
        self.CHANGE(parent=current)
        self.MASTER(parent=current)
        self.TO(parent=current)
        self.masterOption(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.masterOption(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.channelOption(parent=current)
        self.exit_rule(current)
        return current
    changeMaster.min_depth = 3

    @depthcontrol
    def changeReplicationFilter(self, parent=None):
        current = UnparserRule(name='changeReplicationFilter', parent=parent)
        self.enter_rule(current)
        self.CHANGE(parent=current)
        self.REPLICATION(parent=current)
        self.FILTER(parent=current)
        self.replicationFilter(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.replicationFilter(parent=current)
        self.exit_rule(current)
        return current
    changeReplicationFilter.min_depth = 5

    @depthcontrol
    def purgeBinaryLogs(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='purgeBinaryLogs', parent=parent)
        self.enter_rule(current)
        self.PURGE(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.BINARY(parent=current)
        elif choice == 1:
            self.MASTER(parent=current)
        local_ctx['purgeFormat'] = current.last_child
        self.LOGS(parent=current)
        choice = self.model.choice(current, 1, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.TO(parent=current)
            self.STRING_LITERAL(parent=current)
            local_ctx['fileName'] = current.last_child
        elif choice == 1:
            self.BEFORE(parent=current)
            self.STRING_LITERAL(parent=current)
            local_ctx['timeValue'] = current.last_child
        self.exit_rule(current)
        return current
    purgeBinaryLogs.min_depth = 2

    @depthcontrol
    def resetMaster(self, parent=None):
        current = UnparserRule(name='resetMaster', parent=parent)
        self.enter_rule(current)
        self.RESET(parent=current)
        self.MASTER(parent=current)
        self.exit_rule(current)
        return current
    resetMaster.min_depth = 1

    @depthcontrol
    def resetSlave(self, parent=None):
        current = UnparserRule(name='resetSlave', parent=parent)
        self.enter_rule(current)
        self.RESET(parent=current)
        self.SLAVE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ALL(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.channelOption(parent=current)
        self.exit_rule(current)
        return current
    resetSlave.min_depth = 1

    @depthcontrol
    def startSlave(self, parent=None):
        current = UnparserRule(name='startSlave', parent=parent)
        self.enter_rule(current)
        self.START(parent=current)
        self.SLAVE(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.threadType(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.threadType(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.UNTIL(parent=current)
                self.untilOption(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 3, min=0, max=inf):
                self.connectionOption(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.channelOption(parent=current)
        self.exit_rule(current)
        return current
    startSlave.min_depth = 1

    @depthcontrol
    def stopSlave(self, parent=None):
        current = UnparserRule(name='stopSlave', parent=parent)
        self.enter_rule(current)
        self.STOP(parent=current)
        self.SLAVE(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.threadType(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.threadType(parent=current)
        self.exit_rule(current)
        return current
    stopSlave.min_depth = 1

    @depthcontrol
    def startGroupReplication(self, parent=None):
        current = UnparserRule(name='startGroupReplication', parent=parent)
        self.enter_rule(current)
        self.START(parent=current)
        self.GROUP_REPLICATION(parent=current)
        self.exit_rule(current)
        return current
    startGroupReplication.min_depth = 1

    @depthcontrol
    def stopGroupReplication(self, parent=None):
        current = UnparserRule(name='stopGroupReplication', parent=parent)
        self.enter_rule(current)
        self.STOP(parent=current)
        self.GROUP_REPLICATION(parent=current)
        self.exit_rule(current)
        return current
    stopGroupReplication.min_depth = 1

    @depthcontrol
    def masterOption(self, parent=None):
        current = UnparserRule(name='masterOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3, 3, 3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            self.masterOption_masterStringOption(parent=current)
        elif choice == 1:
            self.masterOption_masterDecimalOption(parent=current)
        elif choice == 2:
            self.masterOption_masterBoolOption(parent=current)
        elif choice == 3:
            self.masterOption_masterRealOption(parent=current)
        elif choice == 4:
            self.masterOption_masterUidListOption(parent=current)
        self.exit_rule(current)
        return current
    masterOption.min_depth = 2

    @depthcontrol
    def stringMasterOption(self, parent=None):
        current = UnparserRule(name='stringMasterOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.MASTER_BIND(parent=current)
        elif choice == 1:
            self.MASTER_HOST(parent=current)
        elif choice == 2:
            self.MASTER_USER(parent=current)
        elif choice == 3:
            self.MASTER_PASSWORD(parent=current)
        elif choice == 4:
            self.MASTER_LOG_FILE(parent=current)
        elif choice == 5:
            self.RELAY_LOG_FILE(parent=current)
        elif choice == 6:
            self.MASTER_SSL_CA(parent=current)
        elif choice == 7:
            self.MASTER_SSL_CAPATH(parent=current)
        elif choice == 8:
            self.MASTER_SSL_CERT(parent=current)
        elif choice == 9:
            self.MASTER_SSL_CRL(parent=current)
        elif choice == 10:
            self.MASTER_SSL_CRLPATH(parent=current)
        elif choice == 11:
            self.MASTER_SSL_KEY(parent=current)
        elif choice == 12:
            self.MASTER_SSL_CIPHER(parent=current)
        elif choice == 13:
            self.MASTER_TLS_VERSION(parent=current)
        self.exit_rule(current)
        return current
    stringMasterOption.min_depth = 1

    @depthcontrol
    def decimalMasterOption(self, parent=None):
        current = UnparserRule(name='decimalMasterOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.MASTER_PORT(parent=current)
        elif choice == 1:
            self.MASTER_CONNECT_RETRY(parent=current)
        elif choice == 2:
            self.MASTER_RETRY_COUNT(parent=current)
        elif choice == 3:
            self.MASTER_DELAY(parent=current)
        elif choice == 4:
            self.MASTER_LOG_POS(parent=current)
        elif choice == 5:
            self.RELAY_LOG_POS(parent=current)
        self.exit_rule(current)
        return current
    decimalMasterOption.min_depth = 1

    @depthcontrol
    def boolMasterOption(self, parent=None):
        current = UnparserRule(name='boolMasterOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.MASTER_AUTO_POSITION(parent=current)
        elif choice == 1:
            self.MASTER_SSL(parent=current)
        elif choice == 2:
            self.MASTER_SSL_VERIFY_SERVER_CERT(parent=current)
        self.exit_rule(current)
        return current
    boolMasterOption.min_depth = 1

    @depthcontrol
    def channelOption(self, parent=None):
        current = UnparserRule(name='channelOption', parent=parent)
        self.enter_rule(current)
        self.FOR(parent=current)
        self.CHANNEL(parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    channelOption.min_depth = 2

    @depthcontrol
    def replicationFilter(self, parent=None):
        current = UnparserRule(name='replicationFilter', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 4, 6, 6, 4, 4, 6][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.replicationFilter_doDbReplication(parent=current)
        elif choice == 1:
            self.replicationFilter_ignoreDbReplication(parent=current)
        elif choice == 2:
            self.replicationFilter_doTableReplication(parent=current)
        elif choice == 3:
            self.replicationFilter_ignoreTableReplication(parent=current)
        elif choice == 4:
            self.replicationFilter_wildDoTableReplication(parent=current)
        elif choice == 5:
            self.replicationFilter_wildIgnoreTableReplication(parent=current)
        elif choice == 6:
            self.replicationFilter_rewriteDbReplication(parent=current)
        self.exit_rule(current)
        return current
    replicationFilter.min_depth = 4

    @depthcontrol
    def tablePair(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='tablePair', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.tableName(parent=current)
        local_ctx['firstTable'] = current.last_child
        UnlexerRule(src=',', parent=current)
        self.tableName(parent=current)
        local_ctx['secondTable'] = current.last_child
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    tablePair.min_depth = 4

    @depthcontrol
    def threadType(self, parent=None):
        current = UnparserRule(name='threadType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.IO_THREAD(parent=current)
        elif choice == 1:
            self.SQL_THREAD(parent=current)
        self.exit_rule(current)
        return current
    threadType.min_depth = 1

    @depthcontrol
    def untilOption(self, parent=None):
        current = UnparserRule(name='untilOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 3, 3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.untilOption_gtidsUntilOption(parent=current)
        elif choice == 1:
            self.untilOption_masterLogUntilOption(parent=current)
        elif choice == 2:
            self.untilOption_relayLogUntilOption(parent=current)
        elif choice == 3:
            self.untilOption_sqlGapsUntilOption(parent=current)
        self.exit_rule(current)
        return current
    untilOption.min_depth = 2

    @depthcontrol
    def connectionOption(self, parent=None):
        current = UnparserRule(name='connectionOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3, 3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.connectionOption_userConnectionOption(parent=current)
        elif choice == 1:
            self.connectionOption_passwordConnectionOption(parent=current)
        elif choice == 2:
            self.connectionOption_defaultAuthConnectionOption(parent=current)
        elif choice == 3:
            self.connectionOption_pluginDirConnectionOption(parent=current)
        self.exit_rule(current)
        return current
    connectionOption.min_depth = 3

    @depthcontrol
    def gtuidSet(self, parent=None):
        current = UnparserRule(name='gtuidSet', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.uuidSet(parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.uuidSet(parent=current)
        elif choice == 1:
            self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    gtuidSet.min_depth = 2

    @depthcontrol
    def xaStartTransaction(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='xaStartTransaction', parent=parent)
        self.enter_rule(current)
        self.XA(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.START(parent=current)
        elif choice == 1:
            self.BEGIN(parent=current)
        local_ctx['xaStart'] = current.last_child
        self.xid(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.JOIN(parent=current)
                elif choice == 1:
                    self.RESUME(parent=current)
                local_ctx['xaAction'] = current.last_child
        self.exit_rule(current)
        return current
    xaStartTransaction.min_depth = 4

    @depthcontrol
    def xaEndTransaction(self, parent=None):
        current = UnparserRule(name='xaEndTransaction', parent=parent)
        self.enter_rule(current)
        self.XA(parent=current)
        self.END(parent=current)
        self.xid(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.SUSPEND(parent=current)
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.FOR(parent=current)
                        self.MIGRATE(parent=current)
        self.exit_rule(current)
        return current
    xaEndTransaction.min_depth = 4

    @depthcontrol
    def xaPrepareStatement(self, parent=None):
        current = UnparserRule(name='xaPrepareStatement', parent=parent)
        self.enter_rule(current)
        self.XA(parent=current)
        self.PREPARE(parent=current)
        self.xid(parent=current)
        self.exit_rule(current)
        return current
    xaPrepareStatement.min_depth = 4

    @depthcontrol
    def xaCommitWork(self, parent=None):
        current = UnparserRule(name='xaCommitWork', parent=parent)
        self.enter_rule(current)
        self.XA(parent=current)
        self.COMMIT(parent=current)
        self.xid(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ONE(parent=current)
                self.PHASE(parent=current)
        self.exit_rule(current)
        return current
    xaCommitWork.min_depth = 4

    @depthcontrol
    def xaRollbackWork(self, parent=None):
        current = UnparserRule(name='xaRollbackWork', parent=parent)
        self.enter_rule(current)
        self.XA(parent=current)
        self.ROLLBACK(parent=current)
        self.xid(parent=current)
        self.exit_rule(current)
        return current
    xaRollbackWork.min_depth = 4

    @depthcontrol
    def xaRecoverWork(self, parent=None):
        current = UnparserRule(name='xaRecoverWork', parent=parent)
        self.enter_rule(current)
        self.XA(parent=current)
        self.RECOVER(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.CONVERT(parent=current)
                self.xid(parent=current)
        self.exit_rule(current)
        return current
    xaRecoverWork.min_depth = 1

    @depthcontrol
    def prepareStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='prepareStatement', parent=parent)
        self.enter_rule(current)
        self.PREPARE(parent=current)
        self.uid(parent=current)
        self.FROM(parent=current)
        choice = self.model.choice(current, 0, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.STRING_LITERAL(parent=current)
            local_ctx['query'] = current.last_child
        elif choice == 1:
            self.LOCAL_ID(parent=current)
            local_ctx['variable'] = current.last_child
        self.exit_rule(current)
        return current
    prepareStatement.min_depth = 2

    @depthcontrol
    def executeStatement(self, parent=None):
        current = UnparserRule(name='executeStatement', parent=parent)
        self.enter_rule(current)
        self.EXECUTE(parent=current)
        self.uid(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.USING(parent=current)
                self.userVariables(parent=current)
        self.exit_rule(current)
        return current
    executeStatement.min_depth = 2

    @depthcontrol
    def deallocatePrepare(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='deallocatePrepare', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.DEALLOCATE(parent=current)
        elif choice == 1:
            self.DROP(parent=current)
        local_ctx['dropFormat'] = current.last_child
        self.PREPARE(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    deallocatePrepare.min_depth = 2

    @depthcontrol
    def routineBody(self, parent=None):
        current = UnparserRule(name='routineBody', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.blockStatement(parent=current)
        elif choice == 1:
            self.sqlStatement(parent=current)
        self.exit_rule(current)
        return current
    routineBody.min_depth = 2

    @depthcontrol
    def blockStatement(self, parent=None):
        current = UnparserRule(name='blockStatement', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.uid(parent=current)
                UnlexerRule(src=':', parent=current)
        self.BEGIN(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                if self.max_depth >= 4:
                    for _ in self.model.quantify(current, 2, min=0, max=inf):
                        self.declareVariable(parent=current)
                        self.SEMI(parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 3, min=0, max=inf):
                        self.declareCondition(parent=current)
                        self.SEMI(parent=current)
                if self.max_depth >= 5:
                    for _ in self.model.quantify(current, 4, min=0, max=inf):
                        self.declareCursor(parent=current)
                        self.SEMI(parent=current)
                if self.max_depth >= 4:
                    for _ in self.model.quantify(current, 5, min=0, max=inf):
                        self.declareHandler(parent=current)
                        self.SEMI(parent=current)
                if self.max_depth >= 4:
                    for _ in self.model.quantify(current, 6, min=0, max=inf):
                        self.procedureSqlStatement(parent=current)
        self.END(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 7, min=0, max=1):
                self.uid(parent=current)
        self.exit_rule(current)
        return current
    blockStatement.min_depth = 1

    @depthcontrol
    def caseStatement(self, parent=None):
        current = UnparserRule(name='caseStatement', parent=parent)
        self.enter_rule(current)
        self.CASE(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [2, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.uid(parent=current)
                elif choice == 1:
                    self.expression(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=1, max=inf):
                self.caseAlternative(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.ELSE(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 3, min=1, max=inf):
                        self.procedureSqlStatement(parent=current)
        self.END(parent=current)
        self.CASE(parent=current)
        self.exit_rule(current)
        return current
    caseStatement.min_depth = 5

    @depthcontrol
    def ifStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='ifStatement', parent=parent)
        self.enter_rule(current)
        self.IF(parent=current)
        self.expression(parent=current)
        self.THEN(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.procedureSqlStatement(parent=current)
                local_ctx['thenStatements'] = current.last_child
        if self.max_depth >= 9:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                self.elifAlternative(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.ELSE(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 3, min=1, max=inf):
                        self.procedureSqlStatement(parent=current)
                        local_ctx['elseStatements'] = current.last_child
        self.END(parent=current)
        self.IF(parent=current)
        self.exit_rule(current)
        return current
    ifStatement.min_depth = 8

    @depthcontrol
    def iterateStatement(self, parent=None):
        current = UnparserRule(name='iterateStatement', parent=parent)
        self.enter_rule(current)
        self.ITERATE(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    iterateStatement.min_depth = 2

    @depthcontrol
    def leaveStatement(self, parent=None):
        current = UnparserRule(name='leaveStatement', parent=parent)
        self.enter_rule(current)
        self.LEAVE(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    leaveStatement.min_depth = 2

    @depthcontrol
    def loopStatement(self, parent=None):
        current = UnparserRule(name='loopStatement', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.uid(parent=current)
                UnlexerRule(src=':', parent=current)
        self.LOOP(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=1, max=inf):
                self.procedureSqlStatement(parent=current)
        self.END(parent=current)
        self.LOOP(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.uid(parent=current)
        self.exit_rule(current)
        return current
    loopStatement.min_depth = 4

    @depthcontrol
    def repeatStatement(self, parent=None):
        current = UnparserRule(name='repeatStatement', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.uid(parent=current)
                UnlexerRule(src=':', parent=current)
        self.REPEAT(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=1, max=inf):
                self.procedureSqlStatement(parent=current)
        self.UNTIL(parent=current)
        self.expression(parent=current)
        self.END(parent=current)
        self.REPEAT(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.uid(parent=current)
        self.exit_rule(current)
        return current
    repeatStatement.min_depth = 8

    @depthcontrol
    def returnStatement(self, parent=None):
        current = UnparserRule(name='returnStatement', parent=parent)
        self.enter_rule(current)
        self.RETURN(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    returnStatement.min_depth = 8

    @depthcontrol
    def whileStatement(self, parent=None):
        current = UnparserRule(name='whileStatement', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.uid(parent=current)
                UnlexerRule(src=':', parent=current)
        self.WHILE(parent=current)
        self.expression(parent=current)
        self.DO(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=1, max=inf):
                self.procedureSqlStatement(parent=current)
        self.END(parent=current)
        self.WHILE(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.uid(parent=current)
        self.exit_rule(current)
        return current
    whileStatement.min_depth = 8

    @depthcontrol
    def cursorStatement(self, parent=None):
        current = UnparserRule(name='cursorStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 4, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.cursorStatement_CloseCursor(parent=current)
        elif choice == 1:
            self.cursorStatement_FetchCursor(parent=current)
        elif choice == 2:
            self.cursorStatement_OpenCursor(parent=current)
        self.exit_rule(current)
        return current
    cursorStatement.min_depth = 3

    @depthcontrol
    def declareVariable(self, parent=None):
        current = UnparserRule(name='declareVariable', parent=parent)
        self.enter_rule(current)
        self.DECLARE(parent=current)
        self.uidList(parent=current)
        self.dataType(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.DEFAULT(parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    declareVariable.min_depth = 3

    @depthcontrol
    def declareCondition(self, parent=None):
        current = UnparserRule(name='declareCondition', parent=parent)
        self.enter_rule(current)
        self.DECLARE(parent=current)
        self.uid(parent=current)
        self.CONDITION(parent=current)
        self.FOR(parent=current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.decimalLiteral(parent=current)
        elif choice == 1:
            self.SQLSTATE(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.VALUE(parent=current)
            self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    declareCondition.min_depth = 2

    @depthcontrol
    def declareCursor(self, parent=None):
        current = UnparserRule(name='declareCursor', parent=parent)
        self.enter_rule(current)
        self.DECLARE(parent=current)
        self.uid(parent=current)
        self.CURSOR(parent=current)
        self.FOR(parent=current)
        self.selectStatement(parent=current)
        self.exit_rule(current)
        return current
    declareCursor.min_depth = 4

    @depthcontrol
    def declareHandler(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='declareHandler', parent=parent)
        self.enter_rule(current)
        self.DECLARE(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.CONTINUE(parent=current)
        elif choice == 1:
            self.EXIT(parent=current)
        elif choice == 2:
            self.UNDO(parent=current)
        local_ctx['handlerAction'] = current.last_child
        self.HANDLER(parent=current)
        self.FOR(parent=current)
        self.handlerConditionValue(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.handlerConditionValue(parent=current)
        self.routineBody(parent=current)
        self.exit_rule(current)
        return current
    declareHandler.min_depth = 3

    @depthcontrol
    def handlerConditionValue(self, parent=None):
        current = UnparserRule(name='handlerConditionValue', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3, 3, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.handlerConditionValue_handlerConditionCode(parent=current)
        elif choice == 1:
            self.handlerConditionValue_handlerConditionState(parent=current)
        elif choice == 2:
            self.handlerConditionValue_handlerConditionName(parent=current)
        elif choice == 3:
            self.handlerConditionValue_handlerConditionWarning(parent=current)
        elif choice == 4:
            self.handlerConditionValue_handlerConditionNotfound(parent=current)
        elif choice == 5:
            self.handlerConditionValue_handlerConditionException(parent=current)
        self.exit_rule(current)
        return current
    handlerConditionValue.min_depth = 2

    @depthcontrol
    def procedureSqlStatement(self, parent=None):
        current = UnparserRule(name='procedureSqlStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.compoundStatement(parent=current)
        elif choice == 1:
            self.sqlStatement(parent=current)
        self.SEMI(parent=current)
        self.exit_rule(current)
        return current
    procedureSqlStatement.min_depth = 3

    @depthcontrol
    def caseAlternative(self, parent=None):
        current = UnparserRule(name='caseAlternative', parent=parent)
        self.enter_rule(current)
        self.WHEN(parent=current)
        choice = self.model.choice(current, 0, [0 if [2, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.constant(parent=current)
        elif choice == 1:
            self.expression(parent=current)
        self.THEN(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.procedureSqlStatement(parent=current)
        self.exit_rule(current)
        return current
    caseAlternative.min_depth = 4

    @depthcontrol
    def elifAlternative(self, parent=None):
        current = UnparserRule(name='elifAlternative', parent=parent)
        self.enter_rule(current)
        self.ELSEIF(parent=current)
        self.expression(parent=current)
        self.THEN(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.procedureSqlStatement(parent=current)
        self.exit_rule(current)
        return current
    elifAlternative.min_depth = 8

    @depthcontrol
    def alterUser(self, parent=None):
        current = UnparserRule(name='alterUser', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 6][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.alterUser_alterUserMysqlV56(parent=current)
        elif choice == 1:
            self.alterUser_alterUserMysqlV57(parent=current)
        self.exit_rule(current)
        return current
    alterUser.min_depth = 5

    @depthcontrol
    def createUser(self, parent=None):
        current = UnparserRule(name='createUser', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [6, 6][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.createUser_createUserMysqlV56(parent=current)
        elif choice == 1:
            self.createUser_createUserMysqlV57(parent=current)
        self.exit_rule(current)
        return current
    createUser.min_depth = 6

    @depthcontrol
    def dropUser(self, parent=None):
        current = UnparserRule(name='dropUser', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        self.USER(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ifExists(parent=current)
        self.userName(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.userName(parent=current)
        self.exit_rule(current)
        return current
    dropUser.min_depth = 3

    @depthcontrol
    def grantStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='grantStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.GRANT(parent=current)
            self.privelegeClause(parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.privelegeClause(parent=current)
            self.ON(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    choice = self.model.choice(current, 1, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                    if choice == 0:
                        self.TABLE(parent=current)
                    elif choice == 1:
                        self.FUNCTION(parent=current)
                    elif choice == 2:
                        self.PROCEDURE(parent=current)
                    local_ctx['privilegeObject'] = current.last_child
            self.privilegeLevel(parent=current)
            self.TO(parent=current)
            self.userAuthOption(parent=current)
            if self.max_depth >= 5:
                for _ in self.model.quantify(current, 2, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.userAuthOption(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 3, min=0, max=1):
                    self.REQUIRE(parent=current)
                    choice = self.model.choice(current, 2, [0 if [1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                    if choice == 0:
                        self.NONE(parent=current)
                        local_ctx['tlsNone'] = current.last_child
                    elif choice == 1:
                        self.tlsOption(parent=current)
                        if self.max_depth >= 2:
                            for _ in self.model.quantify(current, 4, min=0, max=inf):
                                if self.max_depth >= 1:
                                    for _ in self.model.quantify(current, 5, min=0, max=1):
                                        self.AND(parent=current)
                                self.tlsOption(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 6, min=0, max=1):
                    self.WITH(parent=current)
                    if self.max_depth >= 1:
                        for _ in self.model.quantify(current, 7, min=0, max=inf):
                            choice = self.model.choice(current, 3, [0 if [1, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                            if choice == 0:
                                self.GRANT(parent=current)
                                self.OPTION(parent=current)
                            elif choice == 1:
                                self.userResourceOption(parent=current)
        elif choice == 1:
            self.GRANT(parent=current)
            self.uid(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 8, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.uid(parent=current)
            self.TO(parent=current)
            choice = self.model.choice(current, 4, [0 if [3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.userName(parent=current)
            elif choice == 1:
                self.uid(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 9, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    choice = self.model.choice(current, 5, [0 if [3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                    if choice == 0:
                        self.userName(parent=current)
                    elif choice == 1:
                        self.uid(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 10, min=0, max=1):
                    self.WITH(parent=current)
                    self.ADMIN(parent=current)
                    self.OPTION(parent=current)
        self.exit_rule(current)
        return current
    grantStatement.min_depth = 2

    @depthcontrol
    def grantProxy(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='grantProxy', parent=parent)
        self.enter_rule(current)
        self.GRANT(parent=current)
        self.PROXY(parent=current)
        self.ON(parent=current)
        self.userName(parent=current)
        local_ctx['fromFirst'] = current.last_child
        self.TO(parent=current)
        self.userName(parent=current)
        local_ctx['toFirst'] = current.last_child
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.userName(parent=current)
                local_ctx['toOther'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.WITH(parent=current)
                self.GRANT(parent=current)
                self.OPTION(parent=current)
        self.exit_rule(current)
        return current
    grantProxy.min_depth = 3

    @depthcontrol
    def renameUser(self, parent=None):
        current = UnparserRule(name='renameUser', parent=parent)
        self.enter_rule(current)
        self.RENAME(parent=current)
        self.USER(parent=current)
        self.renameUserClause(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.renameUserClause(parent=current)
        self.exit_rule(current)
        return current
    renameUser.min_depth = 4

    @depthcontrol
    def revokeStatement(self, parent=None):
        current = UnparserRule(name='revokeStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 4, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.revokeStatement_detailRevoke(parent=current)
        elif choice == 1:
            self.revokeStatement_shortRevoke(parent=current)
        elif choice == 2:
            self.revokeStatement_roleRevoke(parent=current)
        self.exit_rule(current)
        return current
    revokeStatement.min_depth = 3

    @depthcontrol
    def revokeProxy(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='revokeProxy', parent=parent)
        self.enter_rule(current)
        self.REVOKE(parent=current)
        self.PROXY(parent=current)
        self.ON(parent=current)
        self.userName(parent=current)
        local_ctx['onUser'] = current.last_child
        self.FROM(parent=current)
        self.userName(parent=current)
        local_ctx['fromFirst'] = current.last_child
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.userName(parent=current)
                local_ctx['fromOther'] = current.last_child
        self.exit_rule(current)
        return current
    revokeProxy.min_depth = 3

    @depthcontrol
    def setPasswordStatement(self, parent=None):
        current = UnparserRule(name='setPasswordStatement', parent=parent)
        self.enter_rule(current)
        self.SET(parent=current)
        self.PASSWORD(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.FOR(parent=current)
                self.userName(parent=current)
        UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 0, [0 if [4, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.passwordFunctionClause(parent=current)
        elif choice == 1:
            self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    setPasswordStatement.min_depth = 2

    @depthcontrol
    def userSpecification(self, parent=None):
        current = UnparserRule(name='userSpecification', parent=parent)
        self.enter_rule(current)
        self.userName(parent=current)
        self.userPasswordOption(parent=current)
        self.exit_rule(current)
        return current
    userSpecification.min_depth = 3

    @depthcontrol
    def userAuthOption(self, parent=None):
        current = UnparserRule(name='userAuthOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 4, 4, 4][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.userAuthOption_passwordAuthOption(parent=current)
        elif choice == 1:
            self.userAuthOption_stringAuthOption(parent=current)
        elif choice == 2:
            self.userAuthOption_hashAuthOption(parent=current)
        elif choice == 3:
            self.userAuthOption_simpleAuthOption(parent=current)
        self.exit_rule(current)
        return current
    userAuthOption.min_depth = 4

    @depthcontrol
    def tlsOption(self, parent=None):
        current = UnparserRule(name='tlsOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            self.SSL(parent=current)
        elif choice == 1:
            self.X509(parent=current)
        elif choice == 2:
            self.CIPHER(parent=current)
            self.STRING_LITERAL(parent=current)
        elif choice == 3:
            self.ISSUER(parent=current)
            self.STRING_LITERAL(parent=current)
        elif choice == 4:
            self.SUBJECT(parent=current)
            self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    tlsOption.min_depth = 1

    @depthcontrol
    def userResourceOption(self, parent=None):
        current = UnparserRule(name='userResourceOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.MAX_QUERIES_PER_HOUR(parent=current)
            self.decimalLiteral(parent=current)
        elif choice == 1:
            self.MAX_UPDATES_PER_HOUR(parent=current)
            self.decimalLiteral(parent=current)
        elif choice == 2:
            self.MAX_CONNECTIONS_PER_HOUR(parent=current)
            self.decimalLiteral(parent=current)
        elif choice == 3:
            self.MAX_USER_CONNECTIONS(parent=current)
            self.decimalLiteral(parent=current)
        self.exit_rule(current)
        return current
    userResourceOption.min_depth = 2

    @depthcontrol
    def userPasswordOption(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='userPasswordOption', parent=parent)
        self.enter_rule(current)
        self.PASSWORD(parent=current)
        self.EXPIRE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    self.DEFAULT(parent=current)
                    local_ctx['expireType'] = current.last_child
                elif choice == 1:
                    self.NEVER(parent=current)
                    local_ctx['expireType'] = current.last_child
                elif choice == 2:
                    self.INTERVAL(parent=current)
                    local_ctx['expireType'] = current.last_child
                    self.decimalLiteral(parent=current)
                    self.DAY(parent=current)
        self.exit_rule(current)
        return current
    userPasswordOption.min_depth = 1

    @depthcontrol
    def userLockOption(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='userLockOption', parent=parent)
        self.enter_rule(current)
        self.ACCOUNT(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.LOCK(parent=current)
        elif choice == 1:
            self.UNLOCK(parent=current)
        local_ctx['lockType'] = current.last_child
        self.exit_rule(current)
        return current
    userLockOption.min_depth = 1

    @depthcontrol
    def privelegeClause(self, parent=None):
        current = UnparserRule(name='privelegeClause', parent=parent)
        self.enter_rule(current)
        self.privilege(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='(', parent=current)
                self.uidList(parent=current)
                UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    privelegeClause.min_depth = 2

    @depthcontrol
    def privilege(self, parent=None):
        current = UnparserRule(name='privilege', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.ALL(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.PRIVILEGES(parent=current)
        elif choice == 1:
            self.ALTER(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    self.ROUTINE(parent=current)
        elif choice == 2:
            self.CREATE(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    choice = self.model.choice(current, 1, [0 if [1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
                    if choice == 0:
                        self.TEMPORARY(parent=current)
                        self.TABLES(parent=current)
                    elif choice == 1:
                        self.ROUTINE(parent=current)
                    elif choice == 2:
                        self.VIEW(parent=current)
                    elif choice == 3:
                        self.USER(parent=current)
                    elif choice == 4:
                        self.TABLESPACE(parent=current)
                    elif choice == 5:
                        self.ROLE(parent=current)
        elif choice == 3:
            self.DELETE(parent=current)
        elif choice == 4:
            self.DROP(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 3, min=0, max=1):
                    self.ROLE(parent=current)
        elif choice == 5:
            self.EVENT(parent=current)
        elif choice == 6:
            self.EXECUTE(parent=current)
        elif choice == 7:
            self.FILE(parent=current)
        elif choice == 8:
            self.GRANT(parent=current)
            self.OPTION(parent=current)
        elif choice == 9:
            self.INDEX(parent=current)
        elif choice == 10:
            self.INSERT(parent=current)
        elif choice == 11:
            self.LOCK(parent=current)
            self.TABLES(parent=current)
        elif choice == 12:
            self.PROCESS(parent=current)
        elif choice == 13:
            self.PROXY(parent=current)
        elif choice == 14:
            self.REFERENCES(parent=current)
        elif choice == 15:
            self.RELOAD(parent=current)
        elif choice == 16:
            self.REPLICATION(parent=current)
            choice = self.model.choice(current, 2, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.CLIENT(parent=current)
            elif choice == 1:
                self.SLAVE(parent=current)
        elif choice == 17:
            self.SELECT(parent=current)
        elif choice == 18:
            self.SHOW(parent=current)
            choice = self.model.choice(current, 3, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.VIEW(parent=current)
            elif choice == 1:
                self.DATABASES(parent=current)
        elif choice == 19:
            self.SHUTDOWN(parent=current)
        elif choice == 20:
            self.SUPER(parent=current)
        elif choice == 21:
            self.TRIGGER(parent=current)
        elif choice == 22:
            self.UPDATE(parent=current)
        elif choice == 23:
            self.USAGE(parent=current)
        elif choice == 24:
            self.APPLICATION_PASSWORD_ADMIN(parent=current)
        elif choice == 25:
            self.AUDIT_ADMIN(parent=current)
        elif choice == 26:
            self.BACKUP_ADMIN(parent=current)
        elif choice == 27:
            self.BINLOG_ADMIN(parent=current)
        elif choice == 28:
            self.BINLOG_ENCRYPTION_ADMIN(parent=current)
        elif choice == 29:
            self.CLONE_ADMIN(parent=current)
        elif choice == 30:
            self.CONNECTION_ADMIN(parent=current)
        elif choice == 31:
            self.ENCRYPTION_KEY_ADMIN(parent=current)
        elif choice == 32:
            self.FIREWALL_ADMIN(parent=current)
        elif choice == 33:
            self.FIREWALL_USER(parent=current)
        elif choice == 34:
            self.FLUSH_OPTIMIZER_COSTS(parent=current)
        elif choice == 35:
            self.FLUSH_STATUS(parent=current)
        elif choice == 36:
            self.FLUSH_TABLES(parent=current)
        elif choice == 37:
            self.FLUSH_USER_RESOURCES(parent=current)
        elif choice == 38:
            self.GROUP_REPLICATION_ADMIN(parent=current)
        elif choice == 39:
            self.INNODB_REDO_LOG_ARCHIVE(parent=current)
        elif choice == 40:
            self.INNODB_REDO_LOG_ENABLE(parent=current)
        elif choice == 41:
            self.NDB_STORED_USER(parent=current)
        elif choice == 42:
            self.PERSIST_RO_VARIABLES_ADMIN(parent=current)
        elif choice == 43:
            self.REPLICATION_APPLIER(parent=current)
        elif choice == 44:
            self.REPLICATION_SLAVE_ADMIN(parent=current)
        elif choice == 45:
            self.RESOURCE_GROUP_ADMIN(parent=current)
        elif choice == 46:
            self.RESOURCE_GROUP_USER(parent=current)
        elif choice == 47:
            self.ROLE_ADMIN(parent=current)
        elif choice == 48:
            self.SERVICE_CONNECTION_ADMIN(parent=current)
        elif choice == 49:
            self.SESSION_VARIABLES_ADMIN(parent=current)
        elif choice == 50:
            self.SET_USER_ID(parent=current)
        elif choice == 51:
            self.SHOW_ROUTINE(parent=current)
        elif choice == 52:
            self.SYSTEM_USER(parent=current)
        elif choice == 53:
            self.SYSTEM_VARIABLES_ADMIN(parent=current)
        elif choice == 54:
            self.TABLE_ENCRYPTION_ADMIN(parent=current)
        elif choice == 55:
            self.VERSION_TOKEN_ADMIN(parent=current)
        elif choice == 56:
            self.XA_RECOVER_ADMIN(parent=current)
        self.exit_rule(current)
        return current
    privilege.min_depth = 1

    @depthcontrol
    def privilegeLevel(self, parent=None):
        current = UnparserRule(name='privilegeLevel', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 3, 3, 4, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.privilegeLevel_currentSchemaPriviLevel(parent=current)
        elif choice == 1:
            self.privilegeLevel_globalPrivLevel(parent=current)
        elif choice == 2:
            self.privilegeLevel_definiteSchemaPrivLevel(parent=current)
        elif choice == 3:
            self.privilegeLevel_definiteFullTablePrivLevel(parent=current)
        elif choice == 4:
            self.privilegeLevel_definiteFullTablePrivLevel2(parent=current)
        elif choice == 5:
            self.privilegeLevel_definiteTablePrivLevel(parent=current)
        self.exit_rule(current)
        return current
    privilegeLevel.min_depth = 1

    @depthcontrol
    def renameUserClause(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='renameUserClause', parent=parent)
        self.enter_rule(current)
        self.userName(parent=current)
        local_ctx['fromFirst'] = current.last_child
        self.TO(parent=current)
        self.userName(parent=current)
        local_ctx['toFirst'] = current.last_child
        self.exit_rule(current)
        return current
    renameUserClause.min_depth = 3

    @depthcontrol
    def analyzeTable(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='analyzeTable', parent=parent)
        self.enter_rule(current)
        self.ANALYZE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.NO_WRITE_TO_BINLOG(parent=current)
                elif choice == 1:
                    self.LOCAL(parent=current)
                local_ctx['actionOption'] = current.last_child
        self.TABLE(parent=current)
        self.tables(parent=current)
        self.exit_rule(current)
        return current
    analyzeTable.min_depth = 5

    @depthcontrol
    def checkTable(self, parent=None):
        current = UnparserRule(name='checkTable', parent=parent)
        self.enter_rule(current)
        self.CHECK(parent=current)
        self.TABLE(parent=current)
        self.tables(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.checkTableOption(parent=current)
        self.exit_rule(current)
        return current
    checkTable.min_depth = 5

    @depthcontrol
    def checksumTable(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='checksumTable', parent=parent)
        self.enter_rule(current)
        self.CHECKSUM(parent=current)
        self.TABLE(parent=current)
        self.tables(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.QUICK(parent=current)
                elif choice == 1:
                    self.EXTENDED(parent=current)
                local_ctx['actionOption'] = current.last_child
        self.exit_rule(current)
        return current
    checksumTable.min_depth = 5

    @depthcontrol
    def optimizeTable(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='optimizeTable', parent=parent)
        self.enter_rule(current)
        self.OPTIMIZE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.NO_WRITE_TO_BINLOG(parent=current)
                elif choice == 1:
                    self.LOCAL(parent=current)
                local_ctx['actionOption'] = current.last_child
        choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.TABLE(parent=current)
        elif choice == 1:
            self.TABLES(parent=current)
        self.tables(parent=current)
        self.exit_rule(current)
        return current
    optimizeTable.min_depth = 5

    @depthcontrol
    def repairTable(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='repairTable', parent=parent)
        self.enter_rule(current)
        self.REPAIR(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.NO_WRITE_TO_BINLOG(parent=current)
                elif choice == 1:
                    self.LOCAL(parent=current)
                local_ctx['actionOption'] = current.last_child
        self.TABLE(parent=current)
        self.tables(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.QUICK(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.EXTENDED(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.USE_FRM(parent=current)
        self.exit_rule(current)
        return current
    repairTable.min_depth = 5

    @depthcontrol
    def checkTableOption(self, parent=None):
        current = UnparserRule(name='checkTableOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.FOR(parent=current)
            self.UPGRADE(parent=current)
        elif choice == 1:
            self.QUICK(parent=current)
        elif choice == 2:
            self.FAST(parent=current)
        elif choice == 3:
            self.MEDIUM(parent=current)
        elif choice == 4:
            self.EXTENDED(parent=current)
        elif choice == 5:
            self.CHANGED(parent=current)
        self.exit_rule(current)
        return current
    checkTableOption.min_depth = 1

    @depthcontrol
    def createUdfunction(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='createUdfunction', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.AGGREGATE(parent=current)
        self.FUNCTION(parent=current)
        self.uid(parent=current)
        self.RETURNS(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.STRING(parent=current)
        elif choice == 1:
            self.INTEGER(parent=current)
        elif choice == 2:
            self.REAL(parent=current)
        elif choice == 3:
            self.DECIMAL(parent=current)
        local_ctx['returnType'] = current.last_child
        self.SONAME(parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    createUdfunction.min_depth = 2

    @depthcontrol
    def installPlugin(self, parent=None):
        current = UnparserRule(name='installPlugin', parent=parent)
        self.enter_rule(current)
        self.INSTALL(parent=current)
        self.PLUGIN(parent=current)
        self.uid(parent=current)
        self.SONAME(parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    installPlugin.min_depth = 2

    @depthcontrol
    def uninstallPlugin(self, parent=None):
        current = UnparserRule(name='uninstallPlugin', parent=parent)
        self.enter_rule(current)
        self.UNINSTALL(parent=current)
        self.PLUGIN(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    uninstallPlugin.min_depth = 2

    @depthcontrol
    def setStatement(self, parent=None):
        current = UnparserRule(name='setStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [9, 2, 2, 4, 4, 3, 9][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.setStatement_setVariable(parent=current)
        elif choice == 1:
            self.setStatement_setCharset(parent=current)
        elif choice == 2:
            self.setStatement_setNames(parent=current)
        elif choice == 3:
            self.setStatement_setPassword(parent=current)
        elif choice == 4:
            self.setStatement_setTransaction(parent=current)
        elif choice == 5:
            self.setStatement_setAutocommit(parent=current)
        elif choice == 6:
            self.setStatement_setNewValueInsideTrigger(parent=current)
        self.exit_rule(current)
        return current
    setStatement.min_depth = 2

    @depthcontrol
    def showStatement(self, parent=None):
        current = UnparserRule(name='showStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2, 3, 5, 3, 4, 4, 3, 3, 3, 2, 3, 4, 2, 5, 2, 3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.showStatement_showMasterLogs(parent=current)
        elif choice == 1:
            self.showStatement_showLogEvents(parent=current)
        elif choice == 2:
            self.showStatement_showObjectFilter(parent=current)
        elif choice == 3:
            self.showStatement_showColumns(parent=current)
        elif choice == 4:
            self.showStatement_showCreateDb(parent=current)
        elif choice == 5:
            self.showStatement_showCreateFullIdObject(parent=current)
        elif choice == 6:
            self.showStatement_showCreateUser(parent=current)
        elif choice == 7:
            self.showStatement_showEngine(parent=current)
        elif choice == 8:
            self.showStatement_showGlobalInfo(parent=current)
        elif choice == 9:
            self.showStatement_showErrors(parent=current)
        elif choice == 10:
            self.showStatement_showCountErrors(parent=current)
        elif choice == 11:
            self.showStatement_showSchemaFilter(parent=current)
        elif choice == 12:
            self.showStatement_showRoutine(parent=current)
        elif choice == 13:
            self.showStatement_showGrants(parent=current)
        elif choice == 14:
            self.showStatement_showIndexes(parent=current)
        elif choice == 15:
            self.showStatement_showOpenTables(parent=current)
        elif choice == 16:
            self.showStatement_showProfile(parent=current)
        elif choice == 17:
            self.showStatement_showSlaveStatus(parent=current)
        self.exit_rule(current)
        return current
    showStatement.min_depth = 2

    @depthcontrol
    def variableClause(self, parent=None):
        current = UnparserRule(name='variableClause', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.LOCAL_ID(parent=current)
        elif choice == 1:
            self.GLOBAL_ID(parent=current)
        elif choice == 2:
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    if self.max_depth >= 0:
                        for _ in self.model.quantify(current, 1, min=0, max=1):
                            UnlexerRule(src='@', parent=current)
                            UnlexerRule(src='@', parent=current)
                    choice = self.model.choice(current, 1, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                    if choice == 0:
                        self.GLOBAL(parent=current)
                    elif choice == 1:
                        self.SESSION(parent=current)
                    elif choice == 2:
                        self.LOCAL(parent=current)
            self.uid(parent=current)
        self.exit_rule(current)
        return current
    variableClause.min_depth = 1

    @depthcontrol
    def showCommonEntity(self, parent=None):
        current = UnparserRule(name='showCommonEntity', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.CHARACTER(parent=current)
            self.SET(parent=current)
        elif choice == 1:
            self.COLLATION(parent=current)
        elif choice == 2:
            self.DATABASES(parent=current)
        elif choice == 3:
            self.SCHEMAS(parent=current)
        elif choice == 4:
            self.FUNCTION(parent=current)
            self.STATUS(parent=current)
        elif choice == 5:
            self.PROCEDURE(parent=current)
            self.STATUS(parent=current)
        elif choice == 6:
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                    if choice == 0:
                        self.GLOBAL(parent=current)
                    elif choice == 1:
                        self.SESSION(parent=current)
            choice = self.model.choice(current, 2, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.STATUS(parent=current)
            elif choice == 1:
                self.VARIABLES(parent=current)
        self.exit_rule(current)
        return current
    showCommonEntity.min_depth = 1

    @depthcontrol
    def showFilter(self, parent=None):
        current = UnparserRule(name='showFilter', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.LIKE(parent=current)
            self.STRING_LITERAL(parent=current)
        elif choice == 1:
            self.WHERE(parent=current)
            self.expression(parent=current)
        self.exit_rule(current)
        return current
    showFilter.min_depth = 2

    @depthcontrol
    def showGlobalInfoClause(self, parent=None):
        current = UnparserRule(name='showGlobalInfoClause', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.STORAGE(parent=current)
            self.ENGINES(parent=current)
        elif choice == 1:
            self.MASTER(parent=current)
            self.STATUS(parent=current)
        elif choice == 2:
            self.PLUGINS(parent=current)
        elif choice == 3:
            self.PRIVILEGES(parent=current)
        elif choice == 4:
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    self.FULL(parent=current)
            self.PROCESSLIST(parent=current)
        elif choice == 5:
            self.PROFILES(parent=current)
        elif choice == 6:
            self.SLAVE(parent=current)
            self.HOSTS(parent=current)
        elif choice == 7:
            self.AUTHORS(parent=current)
        elif choice == 8:
            self.CONTRIBUTORS(parent=current)
        self.exit_rule(current)
        return current
    showGlobalInfoClause.min_depth = 1

    @depthcontrol
    def showSchemaEntity(self, parent=None):
        current = UnparserRule(name='showSchemaEntity', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.EVENTS(parent=current)
        elif choice == 1:
            self.TABLE(parent=current)
            self.STATUS(parent=current)
        elif choice == 2:
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.FULL(parent=current)
            self.TABLES(parent=current)
        elif choice == 3:
            self.TRIGGERS(parent=current)
        self.exit_rule(current)
        return current
    showSchemaEntity.min_depth = 1

    @depthcontrol
    def showProfileType(self, parent=None):
        current = UnparserRule(name='showProfileType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.ALL(parent=current)
        elif choice == 1:
            self.BLOCK(parent=current)
            self.IO(parent=current)
        elif choice == 2:
            self.CONTEXT(parent=current)
            self.SWITCHES(parent=current)
        elif choice == 3:
            self.CPU(parent=current)
        elif choice == 4:
            self.IPC(parent=current)
        elif choice == 5:
            self.MEMORY(parent=current)
        elif choice == 6:
            self.PAGE(parent=current)
            self.FAULTS(parent=current)
        elif choice == 7:
            self.SOURCE(parent=current)
        elif choice == 8:
            self.SWAPS(parent=current)
        self.exit_rule(current)
        return current
    showProfileType.min_depth = 1

    @depthcontrol
    def binlogStatement(self, parent=None):
        current = UnparserRule(name='binlogStatement', parent=parent)
        self.enter_rule(current)
        self.BINLOG(parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    binlogStatement.min_depth = 2

    @depthcontrol
    def cacheIndexStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='cacheIndexStatement', parent=parent)
        self.enter_rule(current)
        self.CACHE(parent=current)
        self.INDEX(parent=current)
        self.tableIndexes(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.tableIndexes(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.PARTITION(parent=current)
                UnlexerRule(src='(', parent=current)
                choice = self.model.choice(current, 0, [0 if [3, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.uidList(parent=current)
                elif choice == 1:
                    self.ALL(parent=current)
                UnlexerRule(src=')', parent=current)
        self.IN(parent=current)
        self.uid(parent=current)
        local_ctx['schema'] = current.last_child
        self.exit_rule(current)
        return current
    cacheIndexStatement.min_depth = 5

    @depthcontrol
    def flushStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='flushStatement', parent=parent)
        self.enter_rule(current)
        self.FLUSH(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.NO_WRITE_TO_BINLOG(parent=current)
                elif choice == 1:
                    self.LOCAL(parent=current)
                local_ctx['flushFormat'] = current.last_child
        self.flushOption(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.flushOption(parent=current)
        self.exit_rule(current)
        return current
    flushStatement.min_depth = 3

    @depthcontrol
    def killStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='killStatement', parent=parent)
        self.enter_rule(current)
        self.KILL(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.CONNECTION(parent=current)
                elif choice == 1:
                    self.QUERY(parent=current)
                local_ctx['connectionFormat'] = current.last_child
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=1, max=inf):
                self.decimalLiteral(parent=current)
        self.exit_rule(current)
        return current
    killStatement.min_depth = 2

    @depthcontrol
    def loadIndexIntoCache(self, parent=None):
        current = UnparserRule(name='loadIndexIntoCache', parent=parent)
        self.enter_rule(current)
        self.LOAD(parent=current)
        self.INDEX(parent=current)
        self.INTO(parent=current)
        self.CACHE(parent=current)
        self.loadedTableIndexes(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.loadedTableIndexes(parent=current)
        self.exit_rule(current)
        return current
    loadIndexIntoCache.min_depth = 5

    @depthcontrol
    def resetStatement(self, parent=None):
        current = UnparserRule(name='resetStatement', parent=parent)
        self.enter_rule(current)
        self.RESET(parent=current)
        self.QUERY(parent=current)
        self.CACHE(parent=current)
        self.exit_rule(current)
        return current
    resetStatement.min_depth = 1

    @depthcontrol
    def shutdownStatement(self, parent=None):
        current = UnparserRule(name='shutdownStatement', parent=parent)
        self.enter_rule(current)
        self.SHUTDOWN(parent=current)
        self.exit_rule(current)
        return current
    shutdownStatement.min_depth = 1

    @depthcontrol
    def tableIndexes(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='tableIndexes', parent=parent)
        self.enter_rule(current)
        self.tableName(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                        if choice == 0:
                            self.INDEX(parent=current)
                        elif choice == 1:
                            self.KEY(parent=current)
                        local_ctx['indexFormat'] = current.last_child
                UnlexerRule(src='(', parent=current)
                self.uidList(parent=current)
                UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    tableIndexes.min_depth = 4

    @depthcontrol
    def flushOption(self, parent=None):
        current = UnparserRule(name='flushOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2, 6][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.flushOption_simpleFlushOption(parent=current)
        elif choice == 1:
            self.flushOption_channelFlushOption(parent=current)
        elif choice == 2:
            self.flushOption_tableFlushOption(parent=current)
        self.exit_rule(current)
        return current
    flushOption.min_depth = 2

    @depthcontrol
    def flushTableOption(self, parent=None):
        current = UnparserRule(name='flushTableOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.WITH(parent=current)
            self.READ(parent=current)
            self.LOCK(parent=current)
        elif choice == 1:
            self.FOR(parent=current)
            self.EXPORT(parent=current)
        self.exit_rule(current)
        return current
    flushTableOption.min_depth = 1

    @depthcontrol
    def loadedTableIndexes(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='loadedTableIndexes', parent=parent)
        self.enter_rule(current)
        self.tableName(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.PARTITION(parent=current)
                UnlexerRule(src='(', parent=current)
                choice = self.model.choice(current, 0, [0 if [3, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.uidList(parent=current)
                    local_ctx['partitionList'] = current.last_child
                elif choice == 1:
                    self.ALL(parent=current)
                UnlexerRule(src=')', parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                        if choice == 0:
                            self.INDEX(parent=current)
                        elif choice == 1:
                            self.KEY(parent=current)
                        local_ctx['indexFormat'] = current.last_child
                UnlexerRule(src='(', parent=current)
                self.uidList(parent=current)
                local_ctx['indexList'] = current.last_child
                UnlexerRule(src=')', parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.IGNORE(parent=current)
                self.LEAVES(parent=current)
        self.exit_rule(current)
        return current
    loadedTableIndexes.min_depth = 4

    @depthcontrol
    def simpleDescribeStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='simpleDescribeStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.EXPLAIN(parent=current)
        elif choice == 1:
            self.DESCRIBE(parent=current)
        elif choice == 2:
            self.DESC(parent=current)
        local_ctx['command'] = current.last_child
        self.tableName(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 1, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.uid(parent=current)
                    local_ctx['column'] = current.last_child
                elif choice == 1:
                    self.STRING_LITERAL(parent=current)
                    local_ctx['pattern'] = current.last_child
        self.exit_rule(current)
        return current
    simpleDescribeStatement.min_depth = 4

    @depthcontrol
    def fullDescribeStatement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='fullDescribeStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.EXPLAIN(parent=current)
        elif choice == 1:
            self.DESCRIBE(parent=current)
        elif choice == 2:
            self.DESC(parent=current)
        local_ctx['command'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 1, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    self.EXTENDED(parent=current)
                elif choice == 1:
                    self.PARTITIONS(parent=current)
                elif choice == 2:
                    self.FORMAT(parent=current)
                local_ctx['formatType'] = current.last_child
                UnlexerRule(src='=', parent=current)
                choice = self.model.choice(current, 2, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.TRADITIONAL(parent=current)
                elif choice == 1:
                    self.JSON(parent=current)
                local_ctx['formatValue'] = current.last_child
        self.describeObjectClause(parent=current)
        self.exit_rule(current)
        return current
    fullDescribeStatement.min_depth = 4

    @depthcontrol
    def helpStatement(self, parent=None):
        current = UnparserRule(name='helpStatement', parent=parent)
        self.enter_rule(current)
        self.HELP(parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    helpStatement.min_depth = 2

    @depthcontrol
    def useStatement(self, parent=None):
        current = UnparserRule(name='useStatement', parent=parent)
        self.enter_rule(current)
        self.USE(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    useStatement.min_depth = 2

    @depthcontrol
    def signalStatement(self, parent=None):
        current = UnparserRule(name='signalStatement', parent=parent)
        self.enter_rule(current)
        self.SIGNAL(parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.SQLSTATE(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.VALUE(parent=current)
            self.stringLiteral(parent=current)
        elif choice == 1:
            self.ID(parent=current)
        elif choice == 2:
            self.REVERSE_QUOTE_ID(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.SET(parent=current)
                self.signalConditionInformation(parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 2, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.signalConditionInformation(parent=current)
        self.exit_rule(current)
        return current
    signalStatement.min_depth = 1

    @depthcontrol
    def resignalStatement(self, parent=None):
        current = UnparserRule(name='resignalStatement', parent=parent)
        self.enter_rule(current)
        self.RESIGNAL(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [3, 2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    self.SQLSTATE(parent=current)
                    if self.max_depth >= 1:
                        for _ in self.model.quantify(current, 1, min=0, max=1):
                            self.VALUE(parent=current)
                    self.stringLiteral(parent=current)
                elif choice == 1:
                    self.ID(parent=current)
                elif choice == 2:
                    self.REVERSE_QUOTE_ID(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.SET(parent=current)
                self.signalConditionInformation(parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 3, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.signalConditionInformation(parent=current)
        self.exit_rule(current)
        return current
    resignalStatement.min_depth = 1

    @depthcontrol
    def signalConditionInformation(self, parent=None):
        current = UnparserRule(name='signalConditionInformation', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.CLASS_ORIGIN(parent=current)
        elif choice == 1:
            self.SUBCLASS_ORIGIN(parent=current)
        elif choice == 2:
            self.MESSAGE_TEXT(parent=current)
        elif choice == 3:
            self.MYSQL_ERRNO(parent=current)
        elif choice == 4:
            self.CONSTRAINT_CATALOG(parent=current)
        elif choice == 5:
            self.CONSTRAINT_SCHEMA(parent=current)
        elif choice == 6:
            self.CONSTRAINT_NAME(parent=current)
        elif choice == 7:
            self.CATALOG_NAME(parent=current)
        elif choice == 8:
            self.SCHEMA_NAME(parent=current)
        elif choice == 9:
            self.TABLE_NAME(parent=current)
        elif choice == 10:
            self.COLUMN_NAME(parent=current)
        elif choice == 11:
            self.CURSOR_NAME(parent=current)
        UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 1, [0 if [3, 2, 2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.stringLiteral(parent=current)
        elif choice == 1:
            self.DECIMAL_LITERAL(parent=current)
        elif choice == 2:
            self.mysqlVariable(parent=current)
        elif choice == 3:
            self.simpleId(parent=current)
        self.exit_rule(current)
        return current
    signalConditionInformation.min_depth = 2

    @depthcontrol
    def diagnosticsStatement(self, parent=None):
        current = UnparserRule(name='diagnosticsStatement', parent=parent)
        self.enter_rule(current)
        self.GET(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.CURRENT(parent=current)
                elif choice == 1:
                    self.STACKED(parent=current)
        self.DIAGNOSTICS(parent=current)
        choice = self.model.choice(current, 1, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.variableClause(parent=current)
            UnlexerRule(src='=', parent=current)
            choice = self.model.choice(current, 2, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.NUMBER(parent=current)
            elif choice == 1:
                self.ROW_COUNT(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 1, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.variableClause(parent=current)
                    UnlexerRule(src='=', parent=current)
                    choice = self.model.choice(current, 3, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                    if choice == 0:
                        self.NUMBER(parent=current)
                    elif choice == 1:
                        self.ROW_COUNT(parent=current)
        elif choice == 1:
            self.CONDITION(parent=current)
            choice = self.model.choice(current, 4, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.decimalLiteral(parent=current)
            elif choice == 1:
                self.variableClause(parent=current)
            self.variableClause(parent=current)
            UnlexerRule(src='=', parent=current)
            self.diagnosticsConditionInformationName(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 2, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.variableClause(parent=current)
                    UnlexerRule(src='=', parent=current)
                    self.diagnosticsConditionInformationName(parent=current)
        self.exit_rule(current)
        return current
    diagnosticsStatement.min_depth = 2

    @depthcontrol
    def diagnosticsConditionInformationName(self, parent=None):
        current = UnparserRule(name='diagnosticsConditionInformationName', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.CLASS_ORIGIN(parent=current)
        elif choice == 1:
            self.SUBCLASS_ORIGIN(parent=current)
        elif choice == 2:
            self.RETURNED_SQLSTATE(parent=current)
        elif choice == 3:
            self.MESSAGE_TEXT(parent=current)
        elif choice == 4:
            self.MYSQL_ERRNO(parent=current)
        elif choice == 5:
            self.CONSTRAINT_CATALOG(parent=current)
        elif choice == 6:
            self.CONSTRAINT_SCHEMA(parent=current)
        elif choice == 7:
            self.CONSTRAINT_NAME(parent=current)
        elif choice == 8:
            self.CATALOG_NAME(parent=current)
        elif choice == 9:
            self.SCHEMA_NAME(parent=current)
        elif choice == 10:
            self.TABLE_NAME(parent=current)
        elif choice == 11:
            self.COLUMN_NAME(parent=current)
        elif choice == 12:
            self.CURSOR_NAME(parent=current)
        self.exit_rule(current)
        return current
    diagnosticsConditionInformationName.min_depth = 1

    @depthcontrol
    def describeObjectClause(self, parent=None):
        current = UnparserRule(name='describeObjectClause', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.describeObjectClause_describeStatements(parent=current)
        elif choice == 1:
            self.describeObjectClause_describeConnection(parent=current)
        self.exit_rule(current)
        return current
    describeObjectClause.min_depth = 3

    @depthcontrol
    def fullId(self, parent=None):
        current = UnparserRule(name='fullId', parent=parent)
        self.enter_rule(current)
        self.uid(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.DOT_ID(parent=current)
                elif choice == 1:
                    UnlexerRule(src='.', parent=current)
                    self.uid(parent=current)
        self.exit_rule(current)
        return current
    fullId.min_depth = 2

    @depthcontrol
    def tableName(self, parent=None):
        current = UnparserRule(name='tableName', parent=parent)
        self.enter_rule(current)
        self.fullId(parent=current)
        self.exit_rule(current)
        return current
    tableName.min_depth = 3

    @depthcontrol
    def fullColumnName(self, parent=None):
        current = UnparserRule(name='fullColumnName', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.uid(parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.dottedId(parent=current)
                    if self.max_depth >= 3:
                        for _ in self.model.quantify(current, 1, min=0, max=1):
                            self.dottedId(parent=current)
        elif choice == 1:
            UnlexerRule(src=self.model.charset(current, 0, self._charsets[0]), parent=current)
            self.dottedId(parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    self.dottedId(parent=current)
        self.exit_rule(current)
        return current
    fullColumnName.min_depth = 2

    @depthcontrol
    def indexColumnName(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='indexColumnName', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.uid(parent=current)
        elif choice == 1:
            self.STRING_LITERAL(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='(', parent=current)
                self.decimalLiteral(parent=current)
                UnlexerRule(src=')', parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.ASC(parent=current)
                elif choice == 1:
                    self.DESC(parent=current)
                local_ctx['sortType'] = current.last_child
        self.exit_rule(current)
        return current
    indexColumnName.min_depth = 2

    @depthcontrol
    def userName(self, parent=None):
        current = UnparserRule(name='userName', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.STRING_USER_NAME(parent=current)
        elif choice == 1:
            self.ID(parent=current)
        elif choice == 2:
            self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    userName.min_depth = 2

    @depthcontrol
    def mysqlVariable(self, parent=None):
        current = UnparserRule(name='mysqlVariable', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.LOCAL_ID(parent=current)
        elif choice == 1:
            self.GLOBAL_ID(parent=current)
        self.exit_rule(current)
        return current
    mysqlVariable.min_depth = 1

    @depthcontrol
    def charsetName(self, parent=None):
        current = UnparserRule(name='charsetName', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 2, 2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.BINARY(parent=current)
        elif choice == 1:
            self.charsetNameBase(parent=current)
        elif choice == 2:
            self.STRING_LITERAL(parent=current)
        elif choice == 3:
            self.CHARSET_REVERSE_QOUTE_STRING(parent=current)
        self.exit_rule(current)
        return current
    charsetName.min_depth = 1

    @depthcontrol
    def collationName(self, parent=None):
        current = UnparserRule(name='collationName', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.uid(parent=current)
        elif choice == 1:
            self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    collationName.min_depth = 2

    @depthcontrol
    def engineName(self, parent=None):
        current = UnparserRule(name='engineName', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.ARCHIVE(parent=current)
        elif choice == 1:
            self.BLACKHOLE(parent=current)
        elif choice == 2:
            self.CSV(parent=current)
        elif choice == 3:
            self.FEDERATED(parent=current)
        elif choice == 4:
            self.INNODB(parent=current)
        elif choice == 5:
            self.MEMORY(parent=current)
        elif choice == 6:
            self.MRG_MYISAM(parent=current)
        elif choice == 7:
            self.MYISAM(parent=current)
        elif choice == 8:
            self.NDB(parent=current)
        elif choice == 9:
            self.NDBCLUSTER(parent=current)
        elif choice == 10:
            self.PERFORMANCE_SCHEMA(parent=current)
        elif choice == 11:
            self.TOKUDB(parent=current)
        elif choice == 12:
            self.ID(parent=current)
        elif choice == 13:
            self.STRING_LITERAL(parent=current)
        elif choice == 14:
            self.REVERSE_QUOTE_ID(parent=current)
        self.exit_rule(current)
        return current
    engineName.min_depth = 1

    @depthcontrol
    def uuidSet(self, parent=None):
        current = UnparserRule(name='uuidSet', parent=parent)
        self.enter_rule(current)
        self.decimalLiteral(parent=current)
        UnlexerRule(src='-', parent=current)
        self.decimalLiteral(parent=current)
        UnlexerRule(src='-', parent=current)
        self.decimalLiteral(parent=current)
        UnlexerRule(src='-', parent=current)
        self.decimalLiteral(parent=current)
        UnlexerRule(src='-', parent=current)
        self.decimalLiteral(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=':', parent=current)
                self.decimalLiteral(parent=current)
                UnlexerRule(src='-', parent=current)
                self.decimalLiteral(parent=current)
        self.exit_rule(current)
        return current
    uuidSet.min_depth = 2

    @depthcontrol
    def xid(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='xid', parent=parent)
        self.enter_rule(current)
        self.xuidStringId(parent=current)
        local_ctx['globalTableUid'] = current.last_child
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src=',', parent=current)
                self.xuidStringId(parent=current)
                local_ctx['qualifier'] = current.last_child
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        UnlexerRule(src=',', parent=current)
                        self.decimalLiteral(parent=current)
                        local_ctx['idFormat'] = current.last_child
        self.exit_rule(current)
        return current
    xid.min_depth = 3

    @depthcontrol
    def xuidStringId(self, parent=None):
        current = UnparserRule(name='xuidStringId', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.STRING_LITERAL(parent=current)
        elif choice == 1:
            self.BIT_STRING(parent=current)
        elif choice == 2:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=1, max=inf):
                    self.HEXADECIMAL_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    xuidStringId.min_depth = 2

    @depthcontrol
    def authPlugin(self, parent=None):
        current = UnparserRule(name='authPlugin', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.uid(parent=current)
        elif choice == 1:
            self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    authPlugin.min_depth = 2

    @depthcontrol
    def uid(self, parent=None):
        current = UnparserRule(name='uid', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 1, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.simpleId(parent=current)
        elif choice == 1:
            self.REVERSE_QUOTE_ID(parent=current)
        elif choice == 2:
            self.CHARSET_REVERSE_QOUTE_STRING(parent=current)
        self.exit_rule(current)
        return current
    uid.min_depth = 1

    @depthcontrol
    def simpleId(self, parent=None):
        current = UnparserRule(name='simpleId', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2, 2, 2, 2, 2, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.ID(parent=current)
        elif choice == 1:
            self.charsetNameBase(parent=current)
        elif choice == 2:
            self.transactionLevelBase(parent=current)
        elif choice == 3:
            self.engineName(parent=current)
        elif choice == 4:
            self.privilegesBase(parent=current)
        elif choice == 5:
            self.intervalTypeBase(parent=current)
        elif choice == 6:
            self.dataTypeBase(parent=current)
        elif choice == 7:
            self.keywordsCanBeId(parent=current)
        elif choice == 8:
            self.functionNameBase(parent=current)
        self.exit_rule(current)
        return current
    simpleId.min_depth = 2

    @depthcontrol
    def dottedId(self, parent=None):
        current = UnparserRule(name='dottedId', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.DOT_ID(parent=current)
        elif choice == 1:
            UnlexerRule(src='.', parent=current)
            self.uid(parent=current)
        self.exit_rule(current)
        return current
    dottedId.min_depth = 2

    @depthcontrol
    def decimalLiteral(self, parent=None):
        current = UnparserRule(name='decimalLiteral', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.DECIMAL_LITERAL(parent=current)
        elif choice == 1:
            self.ZERO_DECIMAL(parent=current)
        elif choice == 2:
            self.ONE_DECIMAL(parent=current)
        elif choice == 3:
            self.TWO_DECIMAL(parent=current)
        self.exit_rule(current)
        return current
    decimalLiteral.min_depth = 1

    @depthcontrol
    def fileSizeLiteral(self, parent=None):
        current = UnparserRule(name='fileSizeLiteral', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.FILESIZE_LITERAL(parent=current)
        elif choice == 1:
            self.decimalLiteral(parent=current)
        self.exit_rule(current)
        return current
    fileSizeLiteral.min_depth = 2

    @depthcontrol
    def stringLiteral(self, parent=None):
        current = UnparserRule(name='stringLiteral', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            choice = self.model.choice(current, 1, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 0, min=0, max=1):
                        self.STRING_CHARSET_NAME(parent=current)
                self.STRING_LITERAL(parent=current)
            elif choice == 1:
                self.START_NATIONAL_STRING_LITERAL(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 1, min=1, max=inf):
                    self.STRING_LITERAL(parent=current)
        elif choice == 1:
            choice = self.model.choice(current, 2, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        self.STRING_CHARSET_NAME(parent=current)
                self.STRING_LITERAL(parent=current)
            elif choice == 1:
                self.START_NATIONAL_STRING_LITERAL(parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 3, min=0, max=1):
                    self.COLLATE(parent=current)
                    self.collationName(parent=current)
        self.exit_rule(current)
        return current
    stringLiteral.min_depth = 2

    @depthcontrol
    def booleanLiteral(self, parent=None):
        current = UnparserRule(name='booleanLiteral', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.TRUE(parent=current)
        elif choice == 1:
            self.FALSE(parent=current)
        self.exit_rule(current)
        return current
    booleanLiteral.min_depth = 1

    @depthcontrol
    def hexadecimalLiteral(self, parent=None):
        current = UnparserRule(name='hexadecimalLiteral', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.STRING_CHARSET_NAME(parent=current)
        self.HEXADECIMAL_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    hexadecimalLiteral.min_depth = 2

    @depthcontrol
    def nullNotnull(self, parent=None):
        current = UnparserRule(name='nullNotnull', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.NOT(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.NULL_LITERAL(parent=current)
        elif choice == 1:
            self.NULL_SPEC_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    nullNotnull.min_depth = 1

    @depthcontrol
    def constant(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='constant', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 2, 2, 3, 2, 2, 2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.stringLiteral(parent=current)
        elif choice == 1:
            self.decimalLiteral(parent=current)
        elif choice == 2:
            UnlexerRule(src='-', parent=current)
            self.decimalLiteral(parent=current)
        elif choice == 3:
            self.hexadecimalLiteral(parent=current)
        elif choice == 4:
            self.booleanLiteral(parent=current)
        elif choice == 5:
            self.REAL_LITERAL(parent=current)
        elif choice == 6:
            self.BIT_STRING(parent=current)
        elif choice == 7:
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.NOT(parent=current)
            choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.NULL_LITERAL(parent=current)
            elif choice == 1:
                self.NULL_SPEC_LITERAL(parent=current)
            local_ctx['nullLiteral'] = current.last_child
        self.exit_rule(current)
        return current
    constant.min_depth = 1

    @depthcontrol
    def dataType(self, parent=None):
        current = UnparserRule(name='dataType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.dataType_stringDataType(parent=current)
        elif choice == 1:
            self.dataType_nationalStringDataType(parent=current)
        elif choice == 2:
            self.dataType_nationalStringDataType(parent=current)
        elif choice == 3:
            self.dataType_nationalVaryingStringDataType(parent=current)
        elif choice == 4:
            self.dataType_dimensionDataType(parent=current)
        elif choice == 5:
            self.dataType_dimensionDataType(parent=current)
        elif choice == 6:
            self.dataType_dimensionDataType(parent=current)
        elif choice == 7:
            self.dataType_dimensionDataType(parent=current)
        elif choice == 8:
            self.dataType_simpleDataType(parent=current)
        elif choice == 9:
            self.dataType_dimensionDataType(parent=current)
        elif choice == 10:
            self.dataType_collectionDataType(parent=current)
        elif choice == 11:
            self.dataType_spatialDataType(parent=current)
        elif choice == 12:
            self.dataType_longVarcharDataType(parent=current)
        elif choice == 13:
            self.dataType_longVarbinaryDataType(parent=current)
        self.exit_rule(current)
        return current
    dataType.min_depth = 2

    @depthcontrol
    def collectionOptions(self, parent=None):
        current = UnparserRule(name='collectionOptions', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.STRING_LITERAL(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.STRING_LITERAL(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    collectionOptions.min_depth = 2

    @depthcontrol
    def convertedDataType(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='convertedDataType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.BINARY(parent=current)
            elif choice == 1:
                self.NCHAR(parent=current)
            local_ctx['typeName'] = current.last_child
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.lengthOneDimension(parent=current)
        elif choice == 1:
            self.CHAR(parent=current)
            local_ctx['typeName'] = current.last_child
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    self.lengthOneDimension(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    choice = self.model.choice(current, 2, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                    if choice == 0:
                        self.CHARACTER(parent=current)
                        self.SET(parent=current)
                    elif choice == 1:
                        self.CHARSET(parent=current)
                    self.charsetName(parent=current)
        elif choice == 2:
            choice = self.model.choice(current, 3, [0 if [1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
            if choice == 0:
                self.DATE(parent=current)
            elif choice == 1:
                self.DATETIME(parent=current)
            elif choice == 2:
                self.TIME(parent=current)
            elif choice == 3:
                self.JSON(parent=current)
            local_ctx['typeName'] = current.last_child
        elif choice == 3:
            self.DECIMAL(parent=current)
            local_ctx['typeName'] = current.last_child
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 3, min=0, max=1):
                    self.lengthTwoDimension(parent=current)
        elif choice == 4:
            choice = self.model.choice(current, 4, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.SIGNED(parent=current)
            elif choice == 1:
                self.UNSIGNED(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 4, min=0, max=1):
                    self.INTEGER(parent=current)
        self.exit_rule(current)
        return current
    convertedDataType.min_depth = 1

    @depthcontrol
    def lengthOneDimension(self, parent=None):
        current = UnparserRule(name='lengthOneDimension', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.decimalLiteral(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    lengthOneDimension.min_depth = 2

    @depthcontrol
    def lengthTwoDimension(self, parent=None):
        current = UnparserRule(name='lengthTwoDimension', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.decimalLiteral(parent=current)
        UnlexerRule(src=',', parent=current)
        self.decimalLiteral(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    lengthTwoDimension.min_depth = 2

    @depthcontrol
    def lengthTwoOptionalDimension(self, parent=None):
        current = UnparserRule(name='lengthTwoOptionalDimension', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.decimalLiteral(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src=',', parent=current)
                self.decimalLiteral(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    lengthTwoOptionalDimension.min_depth = 2

    @depthcontrol
    def uidList(self, parent=None):
        current = UnparserRule(name='uidList', parent=parent)
        self.enter_rule(current)
        self.uid(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.uid(parent=current)
        self.exit_rule(current)
        return current
    uidList.min_depth = 2

    @depthcontrol
    def tables(self, parent=None):
        current = UnparserRule(name='tables', parent=parent)
        self.enter_rule(current)
        self.tableName(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.tableName(parent=current)
        self.exit_rule(current)
        return current
    tables.min_depth = 4

    @depthcontrol
    def indexColumnNames(self, parent=None):
        current = UnparserRule(name='indexColumnNames', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.indexColumnName(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.indexColumnName(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    indexColumnNames.min_depth = 3

    @depthcontrol
    def expressions(self, parent=None):
        current = UnparserRule(name='expressions', parent=parent)
        self.enter_rule(current)
        self.expression(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    expressions.min_depth = 8

    @depthcontrol
    def expressionsWithDefaults(self, parent=None):
        current = UnparserRule(name='expressionsWithDefaults', parent=parent)
        self.enter_rule(current)
        self.expressionOrDefault(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.expressionOrDefault(parent=current)
        self.exit_rule(current)
        return current
    expressionsWithDefaults.min_depth = 2

    @depthcontrol
    def constants(self, parent=None):
        current = UnparserRule(name='constants', parent=parent)
        self.enter_rule(current)
        self.constant(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.constant(parent=current)
        self.exit_rule(current)
        return current
    constants.min_depth = 2

    @depthcontrol
    def simpleStrings(self, parent=None):
        current = UnparserRule(name='simpleStrings', parent=parent)
        self.enter_rule(current)
        self.STRING_LITERAL(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    simpleStrings.min_depth = 2

    @depthcontrol
    def userVariables(self, parent=None):
        current = UnparserRule(name='userVariables', parent=parent)
        self.enter_rule(current)
        self.LOCAL_ID(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.LOCAL_ID(parent=current)
        self.exit_rule(current)
        return current
    userVariables.min_depth = 1

    @depthcontrol
    def defaultValue(self, parent=None):
        current = UnparserRule(name='defaultValue', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 2, 2, 8][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.NULL_LITERAL(parent=current)
        elif choice == 1:
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.unaryOperator(parent=current)
            self.constant(parent=current)
        elif choice == 2:
            self.currentTimestamp(parent=current)
        elif choice == 3:
            UnlexerRule(src='(', parent=current)
            self.expression(parent=current)
            UnlexerRule(src=')', parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.ON(parent=current)
                self.UPDATE(parent=current)
                self.currentTimestamp(parent=current)
        self.exit_rule(current)
        return current
    defaultValue.min_depth = 1

    @depthcontrol
    def currentTimestamp(self, parent=None):
        current = UnparserRule(name='currentTimestamp', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            choice = self.model.choice(current, 1, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
            if choice == 0:
                self.CURRENT_TIMESTAMP(parent=current)
            elif choice == 1:
                self.LOCALTIME(parent=current)
            elif choice == 2:
                self.LOCALTIMESTAMP(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src='(', parent=current)
                    if self.max_depth >= 2:
                        for _ in self.model.quantify(current, 1, min=0, max=1):
                            self.decimalLiteral(parent=current)
                    UnlexerRule(src=')', parent=current)
        elif choice == 1:
            self.NOW(parent=current)
            UnlexerRule(src='(', parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    self.decimalLiteral(parent=current)
            UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    currentTimestamp.min_depth = 1

    @depthcontrol
    def expressionOrDefault(self, parent=None):
        current = UnparserRule(name='expressionOrDefault', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [8, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.expression(parent=current)
        elif choice == 1:
            self.DEFAULT(parent=current)
        self.exit_rule(current)
        return current
    expressionOrDefault.min_depth = 1

    @depthcontrol
    def ifExists(self, parent=None):
        current = UnparserRule(name='ifExists', parent=parent)
        self.enter_rule(current)
        self.IF(parent=current)
        self.EXISTS(parent=current)
        self.exit_rule(current)
        return current
    ifExists.min_depth = 1

    @depthcontrol
    def ifNotExists(self, parent=None):
        current = UnparserRule(name='ifNotExists', parent=parent)
        self.enter_rule(current)
        self.IF(parent=current)
        self.NOT(parent=current)
        self.EXISTS(parent=current)
        self.exit_rule(current)
        return current
    ifNotExists.min_depth = 1

    @depthcontrol
    def functionCall(self, parent=None):
        current = UnparserRule(name='functionCall', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 3, 3, 4, 5][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            self.functionCall_specificFunctionCall(parent=current)
        elif choice == 1:
            self.functionCall_aggregateFunctionCall(parent=current)
        elif choice == 2:
            self.functionCall_scalarFunctionCall(parent=current)
        elif choice == 3:
            self.functionCall_udfFunctionCall(parent=current)
        elif choice == 4:
            self.functionCall_passwordFunctionCall(parent=current)
        self.exit_rule(current)
        return current
    functionCall.min_depth = 3

    @depthcontrol
    def specificFunction(self, parent=None):
        current = UnparserRule(name='specificFunction', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 9, 9, 9, 4, 9, 5, 4, 4, 4, 4, 4, 4, 4, 4, 9][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.specificFunction_simpleFunctionCall(parent=current)
        elif choice == 1:
            self.specificFunction_dataTypeFunctionCall(parent=current)
        elif choice == 2:
            self.specificFunction_dataTypeFunctionCall(parent=current)
        elif choice == 3:
            self.specificFunction_dataTypeFunctionCall(parent=current)
        elif choice == 4:
            self.specificFunction_valuesFunctionCall(parent=current)
        elif choice == 5:
            self.specificFunction_caseExpressionFunctionCall(parent=current)
        elif choice == 6:
            self.specificFunction_caseFunctionCall(parent=current)
        elif choice == 7:
            self.specificFunction_charFunctionCall(parent=current)
        elif choice == 8:
            self.specificFunction_positionFunctionCall(parent=current)
        elif choice == 9:
            self.specificFunction_substrFunctionCall(parent=current)
        elif choice == 10:
            self.specificFunction_trimFunctionCall(parent=current)
        elif choice == 11:
            self.specificFunction_trimFunctionCall(parent=current)
        elif choice == 12:
            self.specificFunction_weightFunctionCall(parent=current)
        elif choice == 13:
            self.specificFunction_extractFunctionCall(parent=current)
        elif choice == 14:
            self.specificFunction_getFormatFunctionCall(parent=current)
        elif choice == 15:
            self.specificFunction_jsonValueFunctionCall(parent=current)
        self.exit_rule(current)
        return current
    specificFunction.min_depth = 2

    @depthcontrol
    def caseFuncAlternative(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='caseFuncAlternative', parent=parent)
        self.enter_rule(current)
        self.WHEN(parent=current)
        self.functionArg(parent=current)
        local_ctx['condition'] = current.last_child
        self.THEN(parent=current)
        self.functionArg(parent=current)
        local_ctx['consequent'] = current.last_child
        self.exit_rule(current)
        return current
    caseFuncAlternative.min_depth = 3

    @depthcontrol
    def levelsInWeightString(self, parent=None):
        current = UnparserRule(name='levelsInWeightString', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.levelsInWeightString_levelWeightList(parent=current)
        elif choice == 1:
            self.levelsInWeightString_levelWeightRange(parent=current)
        self.exit_rule(current)
        return current
    levelsInWeightString.min_depth = 3

    @depthcontrol
    def levelInWeightListElement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='levelInWeightListElement', parent=parent)
        self.enter_rule(current)
        self.decimalLiteral(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    self.ASC(parent=current)
                elif choice == 1:
                    self.DESC(parent=current)
                elif choice == 2:
                    self.REVERSE(parent=current)
                local_ctx['orderType'] = current.last_child
        self.exit_rule(current)
        return current
    levelInWeightListElement.min_depth = 2

    @depthcontrol
    def aggregateWindowedFunction(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='aggregateWindowedFunction', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 1, 3, 3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            choice = self.model.choice(current, 1, [0 if [1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
            if choice == 0:
                self.AVG(parent=current)
            elif choice == 1:
                self.MAX(parent=current)
            elif choice == 2:
                self.MIN(parent=current)
            elif choice == 3:
                self.SUM(parent=current)
            UnlexerRule(src='(', parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    choice = self.model.choice(current, 2, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                    if choice == 0:
                        self.ALL(parent=current)
                    elif choice == 1:
                        self.DISTINCT(parent=current)
                    local_ctx['aggregator'] = current.last_child
            self.functionArg(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 1:
            self.COUNT(parent=current)
            UnlexerRule(src='(', parent=current)
            choice = self.model.choice(current, 3, [0 if [0, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                UnlexerRule(src='*', parent=current)
                local_ctx['starArg'] = current.last_child
            elif choice == 1:
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.ALL(parent=current)
                        local_ctx['aggregator'] = current.last_child
                self.functionArg(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 2:
            self.COUNT(parent=current)
            UnlexerRule(src='(', parent=current)
            self.DISTINCT(parent=current)
            local_ctx['aggregator'] = current.last_child
            self.functionArgs(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 3:
            choice = self.model.choice(current, 4, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
            if choice == 0:
                self.BIT_AND(parent=current)
            elif choice == 1:
                self.BIT_OR(parent=current)
            elif choice == 2:
                self.BIT_XOR(parent=current)
            elif choice == 3:
                self.STD(parent=current)
            elif choice == 4:
                self.STDDEV(parent=current)
            elif choice == 5:
                self.STDDEV_POP(parent=current)
            elif choice == 6:
                self.STDDEV_SAMP(parent=current)
            elif choice == 7:
                self.VAR_POP(parent=current)
            elif choice == 8:
                self.VAR_SAMP(parent=current)
            elif choice == 9:
                self.VARIANCE(parent=current)
            UnlexerRule(src='(', parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    self.ALL(parent=current)
                    local_ctx['aggregator'] = current.last_child
            self.functionArg(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 4:
            self.GROUP_CONCAT(parent=current)
            UnlexerRule(src='(', parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 3, min=0, max=1):
                    self.DISTINCT(parent=current)
                    local_ctx['aggregator'] = current.last_child
            self.functionArgs(parent=current)
            if self.max_depth >= 9:
                for _ in self.model.quantify(current, 4, min=0, max=1):
                    self.ORDER(parent=current)
                    self.BY(parent=current)
                    self.orderByExpression(parent=current)
                    if self.max_depth >= 9:
                        for _ in self.model.quantify(current, 5, min=0, max=inf):
                            UnlexerRule(src=',', parent=current)
                            self.orderByExpression(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 6, min=0, max=1):
                    self.SEPARATOR(parent=current)
                    self.STRING_LITERAL(parent=current)
                    local_ctx['separator'] = current.last_child
            UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    aggregateWindowedFunction.min_depth = 1

    @depthcontrol
    def scalarFunctionName(self, parent=None):
        current = UnparserRule(name='scalarFunctionName', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.functionNameBase(parent=current)
        elif choice == 1:
            self.ASCII(parent=current)
        elif choice == 2:
            self.CURDATE(parent=current)
        elif choice == 3:
            self.CURRENT_DATE(parent=current)
        elif choice == 4:
            self.CURRENT_TIME(parent=current)
        elif choice == 5:
            self.CURRENT_TIMESTAMP(parent=current)
        elif choice == 6:
            self.CURTIME(parent=current)
        elif choice == 7:
            self.DATE_ADD(parent=current)
        elif choice == 8:
            self.DATE_SUB(parent=current)
        elif choice == 9:
            self.IF(parent=current)
        elif choice == 10:
            self.INSERT(parent=current)
        elif choice == 11:
            self.LOCALTIME(parent=current)
        elif choice == 12:
            self.LOCALTIMESTAMP(parent=current)
        elif choice == 13:
            self.MID(parent=current)
        elif choice == 14:
            self.NOW(parent=current)
        elif choice == 15:
            self.REPLACE(parent=current)
        elif choice == 16:
            self.SUBSTR(parent=current)
        elif choice == 17:
            self.SUBSTRING(parent=current)
        elif choice == 18:
            self.SYSDATE(parent=current)
        elif choice == 19:
            self.TRIM(parent=current)
        elif choice == 20:
            self.UTC_DATE(parent=current)
        elif choice == 21:
            self.UTC_TIME(parent=current)
        elif choice == 22:
            self.UTC_TIMESTAMP(parent=current)
        self.exit_rule(current)
        return current
    scalarFunctionName.min_depth = 1

    @depthcontrol
    def passwordFunctionClause(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='passwordFunctionClause', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.PASSWORD(parent=current)
        elif choice == 1:
            self.OLD_PASSWORD(parent=current)
        local_ctx['functionName'] = current.last_child
        UnlexerRule(src='(', parent=current)
        self.functionArg(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    passwordFunctionClause.min_depth = 3

    @depthcontrol
    def functionArgs(self, parent=None):
        current = UnparserRule(name='functionArgs', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 3, 4, 8][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.constant(parent=current)
        elif choice == 1:
            self.fullColumnName(parent=current)
        elif choice == 2:
            self.functionCall(parent=current)
        elif choice == 3:
            self.expression(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                choice = self.model.choice(current, 1, [0 if [2, 3, 4, 8][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
                if choice == 0:
                    self.constant(parent=current)
                elif choice == 1:
                    self.fullColumnName(parent=current)
                elif choice == 2:
                    self.functionCall(parent=current)
                elif choice == 3:
                    self.expression(parent=current)
        self.exit_rule(current)
        return current
    functionArgs.min_depth = 2

    @depthcontrol
    def functionArg(self, parent=None):
        current = UnparserRule(name='functionArg', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 3, 4, 8][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.constant(parent=current)
        elif choice == 1:
            self.fullColumnName(parent=current)
        elif choice == 2:
            self.functionCall(parent=current)
        elif choice == 3:
            self.expression(parent=current)
        self.exit_rule(current)
        return current
    functionArg.min_depth = 2

    @depthcontrol
    def expression(self, parent=None):
        current = UnparserRule(name='expression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [9, 9, 7, 7][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.expression_notExpression(parent=current)
        elif choice == 1:
            self.expression_logicalExpression(parent=current)
        elif choice == 2:
            self.expression_isExpression(parent=current)
        elif choice == 3:
            self.expression_predicateExpression(parent=current)
        self.exit_rule(current)
        return current
    expression.min_depth = 7

    @depthcontrol
    def predicate(self, parent=None):
        current = UnparserRule(name='predicate', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [7, 7, 7, 7, 7, 7, 7, 7, 5, 7][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.predicate_inPredicate(parent=current)
        elif choice == 1:
            self.predicate_isNullPredicate(parent=current)
        elif choice == 2:
            self.predicate_binaryComparisonPredicate(parent=current)
        elif choice == 3:
            self.predicate_subqueryComparisonPredicate(parent=current)
        elif choice == 4:
            self.predicate_betweenPredicate(parent=current)
        elif choice == 5:
            self.predicate_soundsLikePredicate(parent=current)
        elif choice == 6:
            self.predicate_likePredicate(parent=current)
        elif choice == 7:
            self.predicate_regexpPredicate(parent=current)
        elif choice == 8:
            self.predicate_expressionAtomPredicate(parent=current)
        elif choice == 9:
            self.predicate_jsonMemberOfPredicate(parent=current)
        self.exit_rule(current)
        return current
    predicate.min_depth = 5

    @depthcontrol
    def expressionAtom(self, parent=None):
        current = UnparserRule(name='expressionAtom', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 4, 5, 5, 3, 5, 5, 9, 9, 5, 5, 9, 5, 5, 5][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.expressionAtom_constantExpressionAtom(parent=current)
        elif choice == 1:
            self.expressionAtom_fullColumnNameExpressionAtom(parent=current)
        elif choice == 2:
            self.expressionAtom_functionCallExpressionAtom(parent=current)
        elif choice == 3:
            self.expressionAtom_collateExpressionAtom(parent=current)
        elif choice == 4:
            self.expressionAtom_mysqlVariableExpressionAtom(parent=current)
        elif choice == 5:
            self.expressionAtom_unaryExpressionAtom(parent=current)
        elif choice == 6:
            self.expressionAtom_binaryExpressionAtom(parent=current)
        elif choice == 7:
            self.expressionAtom_nestedExpressionAtom(parent=current)
        elif choice == 8:
            self.expressionAtom_nestedRowExpressionAtom(parent=current)
        elif choice == 9:
            self.expressionAtom_existsExpressionAtom(parent=current)
        elif choice == 10:
            self.expressionAtom_subqueryExpressionAtom(parent=current)
        elif choice == 11:
            self.expressionAtom_intervalExpressionAtom(parent=current)
        elif choice == 12:
            self.expressionAtom_bitExpressionAtom(parent=current)
        elif choice == 13:
            self.expressionAtom_mathExpressionAtom(parent=current)
        elif choice == 14:
            self.expressionAtom_jsonExpressionAtom(parent=current)
        self.exit_rule(current)
        return current
    expressionAtom.min_depth = 3

    @depthcontrol
    def unaryOperator(self, parent=None):
        current = UnparserRule(name='unaryOperator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='!', parent=current)
        elif choice == 1:
            UnlexerRule(src='~', parent=current)
        elif choice == 2:
            UnlexerRule(src='+', parent=current)
        elif choice == 3:
            UnlexerRule(src='-', parent=current)
        elif choice == 4:
            self.NOT(parent=current)
        self.exit_rule(current)
        return current
    unaryOperator.min_depth = 0

    @depthcontrol
    def comparisonOperator(self, parent=None):
        current = UnparserRule(name='comparisonOperator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0, 0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='=', parent=current)
        elif choice == 1:
            UnlexerRule(src='>', parent=current)
        elif choice == 2:
            UnlexerRule(src='<', parent=current)
        elif choice == 3:
            UnlexerRule(src='<', parent=current)
            UnlexerRule(src='=', parent=current)
        elif choice == 4:
            UnlexerRule(src='>', parent=current)
            UnlexerRule(src='=', parent=current)
        elif choice == 5:
            UnlexerRule(src='<', parent=current)
            UnlexerRule(src='>', parent=current)
        elif choice == 6:
            UnlexerRule(src='!', parent=current)
            UnlexerRule(src='=', parent=current)
        elif choice == 7:
            UnlexerRule(src='<', parent=current)
            UnlexerRule(src='=', parent=current)
            UnlexerRule(src='>', parent=current)
        self.exit_rule(current)
        return current
    comparisonOperator.min_depth = 0

    @depthcontrol
    def logicalOperator(self, parent=None):
        current = UnparserRule(name='logicalOperator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 0, 1, 1, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            self.AND(parent=current)
        elif choice == 1:
            UnlexerRule(src='&', parent=current)
            UnlexerRule(src='&', parent=current)
        elif choice == 2:
            self.XOR(parent=current)
        elif choice == 3:
            self.OR(parent=current)
        elif choice == 4:
            UnlexerRule(src='|', parent=current)
            UnlexerRule(src='|', parent=current)
        self.exit_rule(current)
        return current
    logicalOperator.min_depth = 0

    @depthcontrol
    def bitOperator(self, parent=None):
        current = UnparserRule(name='bitOperator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='<', parent=current)
            UnlexerRule(src='<', parent=current)
        elif choice == 1:
            UnlexerRule(src='>', parent=current)
            UnlexerRule(src='>', parent=current)
        elif choice == 2:
            UnlexerRule(src='&', parent=current)
        elif choice == 3:
            UnlexerRule(src='^', parent=current)
        elif choice == 4:
            UnlexerRule(src='|', parent=current)
        self.exit_rule(current)
        return current
    bitOperator.min_depth = 0

    @depthcontrol
    def mathOperator(self, parent=None):
        current = UnparserRule(name='mathOperator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 1, 1, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='*', parent=current)
        elif choice == 1:
            UnlexerRule(src='/', parent=current)
        elif choice == 2:
            UnlexerRule(src='%', parent=current)
        elif choice == 3:
            self.DIV(parent=current)
        elif choice == 4:
            self.MOD(parent=current)
        elif choice == 5:
            UnlexerRule(src='+', parent=current)
        elif choice == 6:
            UnlexerRule(src='-', parent=current)
        elif choice == 7:
            UnlexerRule(src='--', parent=current)
        self.exit_rule(current)
        return current
    mathOperator.min_depth = 0

    @depthcontrol
    def jsonOperator(self, parent=None):
        current = UnparserRule(name='jsonOperator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='-', parent=current)
            UnlexerRule(src='>', parent=current)
        elif choice == 1:
            UnlexerRule(src='-', parent=current)
            UnlexerRule(src='>', parent=current)
            UnlexerRule(src='>', parent=current)
        self.exit_rule(current)
        return current
    jsonOperator.min_depth = 0

    @depthcontrol
    def charsetNameBase(self, parent=None):
        current = UnparserRule(name='charsetNameBase', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.ARMSCII8(parent=current)
        elif choice == 1:
            self.ASCII(parent=current)
        elif choice == 2:
            self.BIG5(parent=current)
        elif choice == 3:
            self.CP1250(parent=current)
        elif choice == 4:
            self.CP1251(parent=current)
        elif choice == 5:
            self.CP1256(parent=current)
        elif choice == 6:
            self.CP1257(parent=current)
        elif choice == 7:
            self.CP850(parent=current)
        elif choice == 8:
            self.CP852(parent=current)
        elif choice == 9:
            self.CP866(parent=current)
        elif choice == 10:
            self.CP932(parent=current)
        elif choice == 11:
            self.DEC8(parent=current)
        elif choice == 12:
            self.EUCJPMS(parent=current)
        elif choice == 13:
            self.EUCKR(parent=current)
        elif choice == 14:
            self.GB2312(parent=current)
        elif choice == 15:
            self.GBK(parent=current)
        elif choice == 16:
            self.GEOSTD8(parent=current)
        elif choice == 17:
            self.GREEK(parent=current)
        elif choice == 18:
            self.HEBREW(parent=current)
        elif choice == 19:
            self.HP8(parent=current)
        elif choice == 20:
            self.KEYBCS2(parent=current)
        elif choice == 21:
            self.KOI8R(parent=current)
        elif choice == 22:
            self.KOI8U(parent=current)
        elif choice == 23:
            self.LATIN1(parent=current)
        elif choice == 24:
            self.LATIN2(parent=current)
        elif choice == 25:
            self.LATIN5(parent=current)
        elif choice == 26:
            self.LATIN7(parent=current)
        elif choice == 27:
            self.MACCE(parent=current)
        elif choice == 28:
            self.MACROMAN(parent=current)
        elif choice == 29:
            self.SJIS(parent=current)
        elif choice == 30:
            self.SWE7(parent=current)
        elif choice == 31:
            self.TIS620(parent=current)
        elif choice == 32:
            self.UCS2(parent=current)
        elif choice == 33:
            self.UJIS(parent=current)
        elif choice == 34:
            self.UTF16(parent=current)
        elif choice == 35:
            self.UTF16LE(parent=current)
        elif choice == 36:
            self.UTF32(parent=current)
        elif choice == 37:
            self.UTF8(parent=current)
        elif choice == 38:
            self.UTF8MB3(parent=current)
        elif choice == 39:
            self.UTF8MB4(parent=current)
        self.exit_rule(current)
        return current
    charsetNameBase.min_depth = 1

    @depthcontrol
    def transactionLevelBase(self, parent=None):
        current = UnparserRule(name='transactionLevelBase', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.REPEATABLE(parent=current)
        elif choice == 1:
            self.COMMITTED(parent=current)
        elif choice == 2:
            self.UNCOMMITTED(parent=current)
        elif choice == 3:
            self.SERIALIZABLE(parent=current)
        self.exit_rule(current)
        return current
    transactionLevelBase.min_depth = 1

    @depthcontrol
    def privilegesBase(self, parent=None):
        current = UnparserRule(name='privilegesBase', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.TABLES(parent=current)
        elif choice == 1:
            self.ROUTINE(parent=current)
        elif choice == 2:
            self.EXECUTE(parent=current)
        elif choice == 3:
            self.FILE(parent=current)
        elif choice == 4:
            self.PROCESS(parent=current)
        elif choice == 5:
            self.RELOAD(parent=current)
        elif choice == 6:
            self.SHUTDOWN(parent=current)
        elif choice == 7:
            self.SUPER(parent=current)
        elif choice == 8:
            self.PRIVILEGES(parent=current)
        self.exit_rule(current)
        return current
    privilegesBase.min_depth = 1

    @depthcontrol
    def intervalTypeBase(self, parent=None):
        current = UnparserRule(name='intervalTypeBase', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.QUARTER(parent=current)
        elif choice == 1:
            self.MONTH(parent=current)
        elif choice == 2:
            self.DAY(parent=current)
        elif choice == 3:
            self.HOUR(parent=current)
        elif choice == 4:
            self.MINUTE(parent=current)
        elif choice == 5:
            self.WEEK(parent=current)
        elif choice == 6:
            self.SECOND(parent=current)
        elif choice == 7:
            self.MICROSECOND(parent=current)
        self.exit_rule(current)
        return current
    intervalTypeBase.min_depth = 1

    @depthcontrol
    def dataTypeBase(self, parent=None):
        current = UnparserRule(name='dataTypeBase', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.DATE(parent=current)
        elif choice == 1:
            self.TIME(parent=current)
        elif choice == 2:
            self.TIMESTAMP(parent=current)
        elif choice == 3:
            self.DATETIME(parent=current)
        elif choice == 4:
            self.YEAR(parent=current)
        elif choice == 5:
            self.ENUM(parent=current)
        elif choice == 6:
            self.TEXT(parent=current)
        self.exit_rule(current)
        return current
    dataTypeBase.min_depth = 1

    @depthcontrol
    def keywordsCanBeId(self, parent=None):
        current = UnparserRule(name='keywordsCanBeId', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.ACCOUNT(parent=current)
        elif choice == 1:
            self.ACTION(parent=current)
        elif choice == 2:
            self.AFTER(parent=current)
        elif choice == 3:
            self.AGGREGATE(parent=current)
        elif choice == 4:
            self.ALGORITHM(parent=current)
        elif choice == 5:
            self.ANY(parent=current)
        elif choice == 6:
            self.AT(parent=current)
        elif choice == 7:
            self.AUDIT_ADMIN(parent=current)
        elif choice == 8:
            self.AUTHORS(parent=current)
        elif choice == 9:
            self.AUTOCOMMIT(parent=current)
        elif choice == 10:
            self.AUTOEXTEND_SIZE(parent=current)
        elif choice == 11:
            self.AUTO_INCREMENT(parent=current)
        elif choice == 12:
            self.AVG(parent=current)
        elif choice == 13:
            self.AVG_ROW_LENGTH(parent=current)
        elif choice == 14:
            self.BACKUP_ADMIN(parent=current)
        elif choice == 15:
            self.BEGIN(parent=current)
        elif choice == 16:
            self.BINLOG(parent=current)
        elif choice == 17:
            self.BINLOG_ADMIN(parent=current)
        elif choice == 18:
            self.BINLOG_ENCRYPTION_ADMIN(parent=current)
        elif choice == 19:
            self.BIT(parent=current)
        elif choice == 20:
            self.BIT_AND(parent=current)
        elif choice == 21:
            self.BIT_OR(parent=current)
        elif choice == 22:
            self.BIT_XOR(parent=current)
        elif choice == 23:
            self.BLOCK(parent=current)
        elif choice == 24:
            self.BOOL(parent=current)
        elif choice == 25:
            self.BOOLEAN(parent=current)
        elif choice == 26:
            self.BTREE(parent=current)
        elif choice == 27:
            self.CACHE(parent=current)
        elif choice == 28:
            self.CASCADED(parent=current)
        elif choice == 29:
            self.CHAIN(parent=current)
        elif choice == 30:
            self.CHANGED(parent=current)
        elif choice == 31:
            self.CHANNEL(parent=current)
        elif choice == 32:
            self.CHECKSUM(parent=current)
        elif choice == 33:
            self.PAGE_CHECKSUM(parent=current)
        elif choice == 34:
            self.CATALOG_NAME(parent=current)
        elif choice == 35:
            self.CIPHER(parent=current)
        elif choice == 36:
            self.CLASS_ORIGIN(parent=current)
        elif choice == 37:
            self.CLIENT(parent=current)
        elif choice == 38:
            self.CLONE_ADMIN(parent=current)
        elif choice == 39:
            self.CLOSE(parent=current)
        elif choice == 40:
            self.COALESCE(parent=current)
        elif choice == 41:
            self.CODE(parent=current)
        elif choice == 42:
            self.COLUMNS(parent=current)
        elif choice == 43:
            self.COLUMN_FORMAT(parent=current)
        elif choice == 44:
            self.COLUMN_NAME(parent=current)
        elif choice == 45:
            self.COMMENT(parent=current)
        elif choice == 46:
            self.COMMIT(parent=current)
        elif choice == 47:
            self.COMPACT(parent=current)
        elif choice == 48:
            self.COMPLETION(parent=current)
        elif choice == 49:
            self.COMPRESSED(parent=current)
        elif choice == 50:
            self.COMPRESSION(parent=current)
        elif choice == 51:
            self.CONCURRENT(parent=current)
        elif choice == 52:
            self.CONNECTION(parent=current)
        elif choice == 53:
            self.CONNECTION_ADMIN(parent=current)
        elif choice == 54:
            self.CONSISTENT(parent=current)
        elif choice == 55:
            self.CONSTRAINT_CATALOG(parent=current)
        elif choice == 56:
            self.CONSTRAINT_NAME(parent=current)
        elif choice == 57:
            self.CONSTRAINT_SCHEMA(parent=current)
        elif choice == 58:
            self.CONTAINS(parent=current)
        elif choice == 59:
            self.CONTEXT(parent=current)
        elif choice == 60:
            self.CONTRIBUTORS(parent=current)
        elif choice == 61:
            self.COPY(parent=current)
        elif choice == 62:
            self.COUNT(parent=current)
        elif choice == 63:
            self.CPU(parent=current)
        elif choice == 64:
            self.CURRENT(parent=current)
        elif choice == 65:
            self.CURSOR_NAME(parent=current)
        elif choice == 66:
            self.DATA(parent=current)
        elif choice == 67:
            self.DATAFILE(parent=current)
        elif choice == 68:
            self.DEALLOCATE(parent=current)
        elif choice == 69:
            self.DEFAULT_AUTH(parent=current)
        elif choice == 70:
            self.DEFINER(parent=current)
        elif choice == 71:
            self.DELAY_KEY_WRITE(parent=current)
        elif choice == 72:
            self.DES_KEY_FILE(parent=current)
        elif choice == 73:
            self.DIAGNOSTICS(parent=current)
        elif choice == 74:
            self.DIRECTORY(parent=current)
        elif choice == 75:
            self.DISABLE(parent=current)
        elif choice == 76:
            self.DISCARD(parent=current)
        elif choice == 77:
            self.DISK(parent=current)
        elif choice == 78:
            self.DO(parent=current)
        elif choice == 79:
            self.DUMPFILE(parent=current)
        elif choice == 80:
            self.DUPLICATE(parent=current)
        elif choice == 81:
            self.DYNAMIC(parent=current)
        elif choice == 82:
            self.ENABLE(parent=current)
        elif choice == 83:
            self.ENCRYPTION(parent=current)
        elif choice == 84:
            self.ENCRYPTION_KEY_ADMIN(parent=current)
        elif choice == 85:
            self.END(parent=current)
        elif choice == 86:
            self.ENDS(parent=current)
        elif choice == 87:
            self.ENGINE(parent=current)
        elif choice == 88:
            self.ENGINES(parent=current)
        elif choice == 89:
            self.ERROR(parent=current)
        elif choice == 90:
            self.ERRORS(parent=current)
        elif choice == 91:
            self.ESCAPE(parent=current)
        elif choice == 92:
            self.EVEN(parent=current)
        elif choice == 93:
            self.EVENT(parent=current)
        elif choice == 94:
            self.EVENTS(parent=current)
        elif choice == 95:
            self.EVERY(parent=current)
        elif choice == 96:
            self.EXCHANGE(parent=current)
        elif choice == 97:
            self.EXCLUSIVE(parent=current)
        elif choice == 98:
            self.EXPIRE(parent=current)
        elif choice == 99:
            self.EXPORT(parent=current)
        elif choice == 100:
            self.EXTENDED(parent=current)
        elif choice == 101:
            self.EXTENT_SIZE(parent=current)
        elif choice == 102:
            self.FAST(parent=current)
        elif choice == 103:
            self.FAULTS(parent=current)
        elif choice == 104:
            self.FIELDS(parent=current)
        elif choice == 105:
            self.FILE_BLOCK_SIZE(parent=current)
        elif choice == 106:
            self.FILTER(parent=current)
        elif choice == 107:
            self.FIREWALL_ADMIN(parent=current)
        elif choice == 108:
            self.FIREWALL_USER(parent=current)
        elif choice == 109:
            self.FIRST(parent=current)
        elif choice == 110:
            self.FIXED(parent=current)
        elif choice == 111:
            self.FLUSH(parent=current)
        elif choice == 112:
            self.FOLLOWS(parent=current)
        elif choice == 113:
            self.FOUND(parent=current)
        elif choice == 114:
            self.FULL(parent=current)
        elif choice == 115:
            self.FUNCTION(parent=current)
        elif choice == 116:
            self.GENERAL(parent=current)
        elif choice == 117:
            self.GLOBAL(parent=current)
        elif choice == 118:
            self.GRANTS(parent=current)
        elif choice == 119:
            self.GROUP(parent=current)
        elif choice == 120:
            self.GROUP_CONCAT(parent=current)
        elif choice == 121:
            self.GROUP_REPLICATION(parent=current)
        elif choice == 122:
            self.GROUP_REPLICATION_ADMIN(parent=current)
        elif choice == 123:
            self.HANDLER(parent=current)
        elif choice == 124:
            self.HASH(parent=current)
        elif choice == 125:
            self.HELP(parent=current)
        elif choice == 126:
            self.HOST(parent=current)
        elif choice == 127:
            self.HOSTS(parent=current)
        elif choice == 128:
            self.IDENTIFIED(parent=current)
        elif choice == 129:
            self.IGNORE_SERVER_IDS(parent=current)
        elif choice == 130:
            self.IMPORT(parent=current)
        elif choice == 131:
            self.INDEXES(parent=current)
        elif choice == 132:
            self.INITIAL_SIZE(parent=current)
        elif choice == 133:
            self.INNODB_REDO_LOG_ARCHIVE(parent=current)
        elif choice == 134:
            self.INPLACE(parent=current)
        elif choice == 135:
            self.INSERT_METHOD(parent=current)
        elif choice == 136:
            self.INSTALL(parent=current)
        elif choice == 137:
            self.INSTANCE(parent=current)
        elif choice == 138:
            self.INTERNAL(parent=current)
        elif choice == 139:
            self.INVOKER(parent=current)
        elif choice == 140:
            self.IO(parent=current)
        elif choice == 141:
            self.IO_THREAD(parent=current)
        elif choice == 142:
            self.IPC(parent=current)
        elif choice == 143:
            self.ISOLATION(parent=current)
        elif choice == 144:
            self.ISSUER(parent=current)
        elif choice == 145:
            self.JSON(parent=current)
        elif choice == 146:
            self.KEY_BLOCK_SIZE(parent=current)
        elif choice == 147:
            self.LANGUAGE(parent=current)
        elif choice == 148:
            self.LAST(parent=current)
        elif choice == 149:
            self.LEAVES(parent=current)
        elif choice == 150:
            self.LESS(parent=current)
        elif choice == 151:
            self.LEVEL(parent=current)
        elif choice == 152:
            self.LIST(parent=current)
        elif choice == 153:
            self.LOCAL(parent=current)
        elif choice == 154:
            self.LOGFILE(parent=current)
        elif choice == 155:
            self.LOGS(parent=current)
        elif choice == 156:
            self.MASTER(parent=current)
        elif choice == 157:
            self.MASTER_AUTO_POSITION(parent=current)
        elif choice == 158:
            self.MASTER_CONNECT_RETRY(parent=current)
        elif choice == 159:
            self.MASTER_DELAY(parent=current)
        elif choice == 160:
            self.MASTER_HEARTBEAT_PERIOD(parent=current)
        elif choice == 161:
            self.MASTER_HOST(parent=current)
        elif choice == 162:
            self.MASTER_LOG_FILE(parent=current)
        elif choice == 163:
            self.MASTER_LOG_POS(parent=current)
        elif choice == 164:
            self.MASTER_PASSWORD(parent=current)
        elif choice == 165:
            self.MASTER_PORT(parent=current)
        elif choice == 166:
            self.MASTER_RETRY_COUNT(parent=current)
        elif choice == 167:
            self.MASTER_SSL(parent=current)
        elif choice == 168:
            self.MASTER_SSL_CA(parent=current)
        elif choice == 169:
            self.MASTER_SSL_CAPATH(parent=current)
        elif choice == 170:
            self.MASTER_SSL_CERT(parent=current)
        elif choice == 171:
            self.MASTER_SSL_CIPHER(parent=current)
        elif choice == 172:
            self.MASTER_SSL_CRL(parent=current)
        elif choice == 173:
            self.MASTER_SSL_CRLPATH(parent=current)
        elif choice == 174:
            self.MASTER_SSL_KEY(parent=current)
        elif choice == 175:
            self.MASTER_TLS_VERSION(parent=current)
        elif choice == 176:
            self.MASTER_USER(parent=current)
        elif choice == 177:
            self.MAX_CONNECTIONS_PER_HOUR(parent=current)
        elif choice == 178:
            self.MAX_QUERIES_PER_HOUR(parent=current)
        elif choice == 179:
            self.MAX(parent=current)
        elif choice == 180:
            self.MAX_ROWS(parent=current)
        elif choice == 181:
            self.MAX_SIZE(parent=current)
        elif choice == 182:
            self.MAX_UPDATES_PER_HOUR(parent=current)
        elif choice == 183:
            self.MAX_USER_CONNECTIONS(parent=current)
        elif choice == 184:
            self.MEDIUM(parent=current)
        elif choice == 185:
            self.MEMBER(parent=current)
        elif choice == 186:
            self.MEMORY(parent=current)
        elif choice == 187:
            self.MERGE(parent=current)
        elif choice == 188:
            self.MESSAGE_TEXT(parent=current)
        elif choice == 189:
            self.MID(parent=current)
        elif choice == 190:
            self.MIGRATE(parent=current)
        elif choice == 191:
            self.MIN(parent=current)
        elif choice == 192:
            self.MIN_ROWS(parent=current)
        elif choice == 193:
            self.MODE(parent=current)
        elif choice == 194:
            self.MODIFY(parent=current)
        elif choice == 195:
            self.MUTEX(parent=current)
        elif choice == 196:
            self.MYSQL(parent=current)
        elif choice == 197:
            self.MYSQL_ERRNO(parent=current)
        elif choice == 198:
            self.NAME(parent=current)
        elif choice == 199:
            self.NAMES(parent=current)
        elif choice == 200:
            self.NCHAR(parent=current)
        elif choice == 201:
            self.NDB_STORED_USER(parent=current)
        elif choice == 202:
            self.NEVER(parent=current)
        elif choice == 203:
            self.NEXT(parent=current)
        elif choice == 204:
            self.NO(parent=current)
        elif choice == 205:
            self.NODEGROUP(parent=current)
        elif choice == 206:
            self.NONE(parent=current)
        elif choice == 207:
            self.NUMBER(parent=current)
        elif choice == 208:
            self.OFFLINE(parent=current)
        elif choice == 209:
            self.OFFSET(parent=current)
        elif choice == 210:
            self.OF(parent=current)
        elif choice == 211:
            self.OJ(parent=current)
        elif choice == 212:
            self.OLD_PASSWORD(parent=current)
        elif choice == 213:
            self.ONE(parent=current)
        elif choice == 214:
            self.ONLINE(parent=current)
        elif choice == 215:
            self.ONLY(parent=current)
        elif choice == 216:
            self.OPEN(parent=current)
        elif choice == 217:
            self.OPTIMIZER_COSTS(parent=current)
        elif choice == 218:
            self.OPTIONAL(parent=current)
        elif choice == 219:
            self.OPTIONS(parent=current)
        elif choice == 220:
            self.ORDER(parent=current)
        elif choice == 221:
            self.OWNER(parent=current)
        elif choice == 222:
            self.PACK_KEYS(parent=current)
        elif choice == 223:
            self.PAGE(parent=current)
        elif choice == 224:
            self.PARSER(parent=current)
        elif choice == 225:
            self.PARTIAL(parent=current)
        elif choice == 226:
            self.PARTITIONING(parent=current)
        elif choice == 227:
            self.PARTITIONS(parent=current)
        elif choice == 228:
            self.PASSWORD(parent=current)
        elif choice == 229:
            self.PERSIST_RO_VARIABLES_ADMIN(parent=current)
        elif choice == 230:
            self.PHASE(parent=current)
        elif choice == 231:
            self.PLUGINS(parent=current)
        elif choice == 232:
            self.PLUGIN_DIR(parent=current)
        elif choice == 233:
            self.PLUGIN(parent=current)
        elif choice == 234:
            self.PORT(parent=current)
        elif choice == 235:
            self.PRECEDES(parent=current)
        elif choice == 236:
            self.PREPARE(parent=current)
        elif choice == 237:
            self.PRESERVE(parent=current)
        elif choice == 238:
            self.PREV(parent=current)
        elif choice == 239:
            self.PROCESSLIST(parent=current)
        elif choice == 240:
            self.PROFILE(parent=current)
        elif choice == 241:
            self.PROFILES(parent=current)
        elif choice == 242:
            self.PROXY(parent=current)
        elif choice == 243:
            self.QUERY(parent=current)
        elif choice == 244:
            self.QUICK(parent=current)
        elif choice == 245:
            self.REBUILD(parent=current)
        elif choice == 246:
            self.RECOVER(parent=current)
        elif choice == 247:
            self.REDO_BUFFER_SIZE(parent=current)
        elif choice == 248:
            self.REDUNDANT(parent=current)
        elif choice == 249:
            self.RELAY(parent=current)
        elif choice == 250:
            self.RELAYLOG(parent=current)
        elif choice == 251:
            self.RELAY_LOG_FILE(parent=current)
        elif choice == 252:
            self.RELAY_LOG_POS(parent=current)
        elif choice == 253:
            self.REMOVE(parent=current)
        elif choice == 254:
            self.REORGANIZE(parent=current)
        elif choice == 255:
            self.REPAIR(parent=current)
        elif choice == 256:
            self.REPLICATE_DO_DB(parent=current)
        elif choice == 257:
            self.REPLICATE_DO_TABLE(parent=current)
        elif choice == 258:
            self.REPLICATE_IGNORE_DB(parent=current)
        elif choice == 259:
            self.REPLICATE_IGNORE_TABLE(parent=current)
        elif choice == 260:
            self.REPLICATE_REWRITE_DB(parent=current)
        elif choice == 261:
            self.REPLICATE_WILD_DO_TABLE(parent=current)
        elif choice == 262:
            self.REPLICATE_WILD_IGNORE_TABLE(parent=current)
        elif choice == 263:
            self.REPLICATION(parent=current)
        elif choice == 264:
            self.REPLICATION_APPLIER(parent=current)
        elif choice == 265:
            self.REPLICATION_SLAVE_ADMIN(parent=current)
        elif choice == 266:
            self.RESET(parent=current)
        elif choice == 267:
            self.RESOURCE_GROUP_ADMIN(parent=current)
        elif choice == 268:
            self.RESOURCE_GROUP_USER(parent=current)
        elif choice == 269:
            self.RESUME(parent=current)
        elif choice == 270:
            self.RETURNED_SQLSTATE(parent=current)
        elif choice == 271:
            self.RETURNS(parent=current)
        elif choice == 272:
            self.ROLE(parent=current)
        elif choice == 273:
            self.ROLE_ADMIN(parent=current)
        elif choice == 274:
            self.ROLLBACK(parent=current)
        elif choice == 275:
            self.ROLLUP(parent=current)
        elif choice == 276:
            self.ROTATE(parent=current)
        elif choice == 277:
            self.ROW(parent=current)
        elif choice == 278:
            self.ROWS(parent=current)
        elif choice == 279:
            self.ROW_FORMAT(parent=current)
        elif choice == 280:
            self.SAVEPOINT(parent=current)
        elif choice == 281:
            self.SCHEDULE(parent=current)
        elif choice == 282:
            self.SCHEMA_NAME(parent=current)
        elif choice == 283:
            self.SECURITY(parent=current)
        elif choice == 284:
            self.SERIAL(parent=current)
        elif choice == 285:
            self.SERVER(parent=current)
        elif choice == 286:
            self.SESSION(parent=current)
        elif choice == 287:
            self.SESSION_VARIABLES_ADMIN(parent=current)
        elif choice == 288:
            self.SET_USER_ID(parent=current)
        elif choice == 289:
            self.SHARE(parent=current)
        elif choice == 290:
            self.SHARED(parent=current)
        elif choice == 291:
            self.SHOW_ROUTINE(parent=current)
        elif choice == 292:
            self.SIGNED(parent=current)
        elif choice == 293:
            self.SIMPLE(parent=current)
        elif choice == 294:
            self.SLAVE(parent=current)
        elif choice == 295:
            self.SLOW(parent=current)
        elif choice == 296:
            self.SNAPSHOT(parent=current)
        elif choice == 297:
            self.SOCKET(parent=current)
        elif choice == 298:
            self.SOME(parent=current)
        elif choice == 299:
            self.SONAME(parent=current)
        elif choice == 300:
            self.SOUNDS(parent=current)
        elif choice == 301:
            self.SOURCE(parent=current)
        elif choice == 302:
            self.SQL_AFTER_GTIDS(parent=current)
        elif choice == 303:
            self.SQL_AFTER_MTS_GAPS(parent=current)
        elif choice == 304:
            self.SQL_BEFORE_GTIDS(parent=current)
        elif choice == 305:
            self.SQL_BUFFER_RESULT(parent=current)
        elif choice == 306:
            self.SQL_CACHE(parent=current)
        elif choice == 307:
            self.SQL_NO_CACHE(parent=current)
        elif choice == 308:
            self.SQL_THREAD(parent=current)
        elif choice == 309:
            self.STACKED(parent=current)
        elif choice == 310:
            self.START(parent=current)
        elif choice == 311:
            self.STARTS(parent=current)
        elif choice == 312:
            self.STATS_AUTO_RECALC(parent=current)
        elif choice == 313:
            self.STATS_PERSISTENT(parent=current)
        elif choice == 314:
            self.STATS_SAMPLE_PAGES(parent=current)
        elif choice == 315:
            self.STATUS(parent=current)
        elif choice == 316:
            self.STD(parent=current)
        elif choice == 317:
            self.STDDEV(parent=current)
        elif choice == 318:
            self.STDDEV_POP(parent=current)
        elif choice == 319:
            self.STDDEV_SAMP(parent=current)
        elif choice == 320:
            self.STOP(parent=current)
        elif choice == 321:
            self.STORAGE(parent=current)
        elif choice == 322:
            self.STRING(parent=current)
        elif choice == 323:
            self.SUBCLASS_ORIGIN(parent=current)
        elif choice == 324:
            self.SUBJECT(parent=current)
        elif choice == 325:
            self.SUBPARTITION(parent=current)
        elif choice == 326:
            self.SUBPARTITIONS(parent=current)
        elif choice == 327:
            self.SUM(parent=current)
        elif choice == 328:
            self.SUSPEND(parent=current)
        elif choice == 329:
            self.SWAPS(parent=current)
        elif choice == 330:
            self.SWITCHES(parent=current)
        elif choice == 331:
            self.SYSTEM_VARIABLES_ADMIN(parent=current)
        elif choice == 332:
            self.TABLE_NAME(parent=current)
        elif choice == 333:
            self.TABLESPACE(parent=current)
        elif choice == 334:
            self.TABLE_ENCRYPTION_ADMIN(parent=current)
        elif choice == 335:
            self.TEMPORARY(parent=current)
        elif choice == 336:
            self.TEMPTABLE(parent=current)
        elif choice == 337:
            self.THAN(parent=current)
        elif choice == 338:
            self.TRADITIONAL(parent=current)
        elif choice == 339:
            self.TRANSACTION(parent=current)
        elif choice == 340:
            self.TRANSACTIONAL(parent=current)
        elif choice == 341:
            self.TRIGGERS(parent=current)
        elif choice == 342:
            self.TRUNCATE(parent=current)
        elif choice == 343:
            self.UNDEFINED(parent=current)
        elif choice == 344:
            self.UNDOFILE(parent=current)
        elif choice == 345:
            self.UNDO_BUFFER_SIZE(parent=current)
        elif choice == 346:
            self.UNINSTALL(parent=current)
        elif choice == 347:
            self.UNKNOWN(parent=current)
        elif choice == 348:
            self.UNTIL(parent=current)
        elif choice == 349:
            self.UPGRADE(parent=current)
        elif choice == 350:
            self.USER(parent=current)
        elif choice == 351:
            self.USE_FRM(parent=current)
        elif choice == 352:
            self.USER_RESOURCES(parent=current)
        elif choice == 353:
            self.VALIDATION(parent=current)
        elif choice == 354:
            self.VALUE(parent=current)
        elif choice == 355:
            self.VAR_POP(parent=current)
        elif choice == 356:
            self.VAR_SAMP(parent=current)
        elif choice == 357:
            self.VARIABLES(parent=current)
        elif choice == 358:
            self.VARIANCE(parent=current)
        elif choice == 359:
            self.VERSION_TOKEN_ADMIN(parent=current)
        elif choice == 360:
            self.VIEW(parent=current)
        elif choice == 361:
            self.WAIT(parent=current)
        elif choice == 362:
            self.WARNINGS(parent=current)
        elif choice == 363:
            self.WITHOUT(parent=current)
        elif choice == 364:
            self.WORK(parent=current)
        elif choice == 365:
            self.WRAPPER(parent=current)
        elif choice == 366:
            self.X509(parent=current)
        elif choice == 367:
            self.XA(parent=current)
        elif choice == 368:
            self.XA_RECOVER_ADMIN(parent=current)
        elif choice == 369:
            self.XML(parent=current)
        self.exit_rule(current)
        return current
    keywordsCanBeId.min_depth = 1

    @depthcontrol
    def functionNameBase(self, parent=None):
        current = UnparserRule(name='functionNameBase', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.ABS(parent=current)
        elif choice == 1:
            self.ACOS(parent=current)
        elif choice == 2:
            self.ADDDATE(parent=current)
        elif choice == 3:
            self.ADDTIME(parent=current)
        elif choice == 4:
            self.AES_DECRYPT(parent=current)
        elif choice == 5:
            self.AES_ENCRYPT(parent=current)
        elif choice == 6:
            self.AREA(parent=current)
        elif choice == 7:
            self.ASBINARY(parent=current)
        elif choice == 8:
            self.ASIN(parent=current)
        elif choice == 9:
            self.ASTEXT(parent=current)
        elif choice == 10:
            self.ASWKB(parent=current)
        elif choice == 11:
            self.ASWKT(parent=current)
        elif choice == 12:
            self.ASYMMETRIC_DECRYPT(parent=current)
        elif choice == 13:
            self.ASYMMETRIC_DERIVE(parent=current)
        elif choice == 14:
            self.ASYMMETRIC_ENCRYPT(parent=current)
        elif choice == 15:
            self.ASYMMETRIC_SIGN(parent=current)
        elif choice == 16:
            self.ASYMMETRIC_VERIFY(parent=current)
        elif choice == 17:
            self.ATAN(parent=current)
        elif choice == 18:
            self.ATAN2(parent=current)
        elif choice == 19:
            self.BENCHMARK(parent=current)
        elif choice == 20:
            self.BIN(parent=current)
        elif choice == 21:
            self.BIT_COUNT(parent=current)
        elif choice == 22:
            self.BIT_LENGTH(parent=current)
        elif choice == 23:
            self.BUFFER(parent=current)
        elif choice == 24:
            self.CEIL(parent=current)
        elif choice == 25:
            self.CEILING(parent=current)
        elif choice == 26:
            self.CENTROID(parent=current)
        elif choice == 27:
            self.CHARACTER_LENGTH(parent=current)
        elif choice == 28:
            self.CHARSET(parent=current)
        elif choice == 29:
            self.CHAR_LENGTH(parent=current)
        elif choice == 30:
            self.COERCIBILITY(parent=current)
        elif choice == 31:
            self.COLLATION(parent=current)
        elif choice == 32:
            self.COMPRESS(parent=current)
        elif choice == 33:
            self.CONCAT(parent=current)
        elif choice == 34:
            self.CONCAT_WS(parent=current)
        elif choice == 35:
            self.CONNECTION_ID(parent=current)
        elif choice == 36:
            self.CONV(parent=current)
        elif choice == 37:
            self.CONVERT_TZ(parent=current)
        elif choice == 38:
            self.COS(parent=current)
        elif choice == 39:
            self.COT(parent=current)
        elif choice == 40:
            self.COUNT(parent=current)
        elif choice == 41:
            self.CRC32(parent=current)
        elif choice == 42:
            self.CREATE_ASYMMETRIC_PRIV_KEY(parent=current)
        elif choice == 43:
            self.CREATE_ASYMMETRIC_PUB_KEY(parent=current)
        elif choice == 44:
            self.CREATE_DH_PARAMETERS(parent=current)
        elif choice == 45:
            self.CREATE_DIGEST(parent=current)
        elif choice == 46:
            self.CROSSES(parent=current)
        elif choice == 47:
            self.DATABASE(parent=current)
        elif choice == 48:
            self.DATE(parent=current)
        elif choice == 49:
            self.DATEDIFF(parent=current)
        elif choice == 50:
            self.DATE_FORMAT(parent=current)
        elif choice == 51:
            self.DAY(parent=current)
        elif choice == 52:
            self.DAYNAME(parent=current)
        elif choice == 53:
            self.DAYOFMONTH(parent=current)
        elif choice == 54:
            self.DAYOFWEEK(parent=current)
        elif choice == 55:
            self.DAYOFYEAR(parent=current)
        elif choice == 56:
            self.DECODE(parent=current)
        elif choice == 57:
            self.DEGREES(parent=current)
        elif choice == 58:
            self.DES_DECRYPT(parent=current)
        elif choice == 59:
            self.DES_ENCRYPT(parent=current)
        elif choice == 60:
            self.DIMENSION(parent=current)
        elif choice == 61:
            self.DISJOINT(parent=current)
        elif choice == 62:
            self.ELT(parent=current)
        elif choice == 63:
            self.ENCODE(parent=current)
        elif choice == 64:
            self.ENCRYPT(parent=current)
        elif choice == 65:
            self.ENDPOINT(parent=current)
        elif choice == 66:
            self.ENVELOPE(parent=current)
        elif choice == 67:
            self.EQUALS(parent=current)
        elif choice == 68:
            self.EXP(parent=current)
        elif choice == 69:
            self.EXPORT_SET(parent=current)
        elif choice == 70:
            self.EXTERIORRING(parent=current)
        elif choice == 71:
            self.EXTRACTVALUE(parent=current)
        elif choice == 72:
            self.FIELD(parent=current)
        elif choice == 73:
            self.FIND_IN_SET(parent=current)
        elif choice == 74:
            self.FLOOR(parent=current)
        elif choice == 75:
            self.FORMAT(parent=current)
        elif choice == 76:
            self.FOUND_ROWS(parent=current)
        elif choice == 77:
            self.FROM_BASE64(parent=current)
        elif choice == 78:
            self.FROM_DAYS(parent=current)
        elif choice == 79:
            self.FROM_UNIXTIME(parent=current)
        elif choice == 80:
            self.GEOMCOLLFROMTEXT(parent=current)
        elif choice == 81:
            self.GEOMCOLLFROMWKB(parent=current)
        elif choice == 82:
            self.GEOMETRYCOLLECTION(parent=current)
        elif choice == 83:
            self.GEOMETRYCOLLECTIONFROMTEXT(parent=current)
        elif choice == 84:
            self.GEOMETRYCOLLECTIONFROMWKB(parent=current)
        elif choice == 85:
            self.GEOMETRYFROMTEXT(parent=current)
        elif choice == 86:
            self.GEOMETRYFROMWKB(parent=current)
        elif choice == 87:
            self.GEOMETRYN(parent=current)
        elif choice == 88:
            self.GEOMETRYTYPE(parent=current)
        elif choice == 89:
            self.GEOMFROMTEXT(parent=current)
        elif choice == 90:
            self.GEOMFROMWKB(parent=current)
        elif choice == 91:
            self.GET_FORMAT(parent=current)
        elif choice == 92:
            self.GET_LOCK(parent=current)
        elif choice == 93:
            self.GLENGTH(parent=current)
        elif choice == 94:
            self.GREATEST(parent=current)
        elif choice == 95:
            self.GTID_SUBSET(parent=current)
        elif choice == 96:
            self.GTID_SUBTRACT(parent=current)
        elif choice == 97:
            self.HEX(parent=current)
        elif choice == 98:
            self.HOUR(parent=current)
        elif choice == 99:
            self.IFNULL(parent=current)
        elif choice == 100:
            self.INET6_ATON(parent=current)
        elif choice == 101:
            self.INET6_NTOA(parent=current)
        elif choice == 102:
            self.INET_ATON(parent=current)
        elif choice == 103:
            self.INET_NTOA(parent=current)
        elif choice == 104:
            self.INSTR(parent=current)
        elif choice == 105:
            self.INTERIORRINGN(parent=current)
        elif choice == 106:
            self.INTERSECTS(parent=current)
        elif choice == 107:
            self.INVISIBLE(parent=current)
        elif choice == 108:
            self.ISCLOSED(parent=current)
        elif choice == 109:
            self.ISEMPTY(parent=current)
        elif choice == 110:
            self.ISNULL(parent=current)
        elif choice == 111:
            self.ISSIMPLE(parent=current)
        elif choice == 112:
            self.IS_FREE_LOCK(parent=current)
        elif choice == 113:
            self.IS_IPV4(parent=current)
        elif choice == 114:
            self.IS_IPV4_COMPAT(parent=current)
        elif choice == 115:
            self.IS_IPV4_MAPPED(parent=current)
        elif choice == 116:
            self.IS_IPV6(parent=current)
        elif choice == 117:
            self.IS_USED_LOCK(parent=current)
        elif choice == 118:
            self.LAST_INSERT_ID(parent=current)
        elif choice == 119:
            self.LCASE(parent=current)
        elif choice == 120:
            self.LEAST(parent=current)
        elif choice == 121:
            self.LEFT(parent=current)
        elif choice == 122:
            self.LENGTH(parent=current)
        elif choice == 123:
            self.LINEFROMTEXT(parent=current)
        elif choice == 124:
            self.LINEFROMWKB(parent=current)
        elif choice == 125:
            self.LINESTRING(parent=current)
        elif choice == 126:
            self.LINESTRINGFROMTEXT(parent=current)
        elif choice == 127:
            self.LINESTRINGFROMWKB(parent=current)
        elif choice == 128:
            self.LN(parent=current)
        elif choice == 129:
            self.LOAD_FILE(parent=current)
        elif choice == 130:
            self.LOCATE(parent=current)
        elif choice == 131:
            self.LOG(parent=current)
        elif choice == 132:
            self.LOG10(parent=current)
        elif choice == 133:
            self.LOG2(parent=current)
        elif choice == 134:
            self.LOWER(parent=current)
        elif choice == 135:
            self.LPAD(parent=current)
        elif choice == 136:
            self.LTRIM(parent=current)
        elif choice == 137:
            self.MAKEDATE(parent=current)
        elif choice == 138:
            self.MAKETIME(parent=current)
        elif choice == 139:
            self.MAKE_SET(parent=current)
        elif choice == 140:
            self.MASTER_POS_WAIT(parent=current)
        elif choice == 141:
            self.MBRCONTAINS(parent=current)
        elif choice == 142:
            self.MBRDISJOINT(parent=current)
        elif choice == 143:
            self.MBREQUAL(parent=current)
        elif choice == 144:
            self.MBRINTERSECTS(parent=current)
        elif choice == 145:
            self.MBROVERLAPS(parent=current)
        elif choice == 146:
            self.MBRTOUCHES(parent=current)
        elif choice == 147:
            self.MBRWITHIN(parent=current)
        elif choice == 148:
            self.MD5(parent=current)
        elif choice == 149:
            self.MICROSECOND(parent=current)
        elif choice == 150:
            self.MINUTE(parent=current)
        elif choice == 151:
            self.MLINEFROMTEXT(parent=current)
        elif choice == 152:
            self.MLINEFROMWKB(parent=current)
        elif choice == 153:
            self.MOD(parent=current)
        elif choice == 154:
            self.MONTH(parent=current)
        elif choice == 155:
            self.MONTHNAME(parent=current)
        elif choice == 156:
            self.MPOINTFROMTEXT(parent=current)
        elif choice == 157:
            self.MPOINTFROMWKB(parent=current)
        elif choice == 158:
            self.MPOLYFROMTEXT(parent=current)
        elif choice == 159:
            self.MPOLYFROMWKB(parent=current)
        elif choice == 160:
            self.MULTILINESTRING(parent=current)
        elif choice == 161:
            self.MULTILINESTRINGFROMTEXT(parent=current)
        elif choice == 162:
            self.MULTILINESTRINGFROMWKB(parent=current)
        elif choice == 163:
            self.MULTIPOINT(parent=current)
        elif choice == 164:
            self.MULTIPOINTFROMTEXT(parent=current)
        elif choice == 165:
            self.MULTIPOINTFROMWKB(parent=current)
        elif choice == 166:
            self.MULTIPOLYGON(parent=current)
        elif choice == 167:
            self.MULTIPOLYGONFROMTEXT(parent=current)
        elif choice == 168:
            self.MULTIPOLYGONFROMWKB(parent=current)
        elif choice == 169:
            self.NAME_CONST(parent=current)
        elif choice == 170:
            self.NULLIF(parent=current)
        elif choice == 171:
            self.NUMGEOMETRIES(parent=current)
        elif choice == 172:
            self.NUMINTERIORRINGS(parent=current)
        elif choice == 173:
            self.NUMPOINTS(parent=current)
        elif choice == 174:
            self.OCT(parent=current)
        elif choice == 175:
            self.OCTET_LENGTH(parent=current)
        elif choice == 176:
            self.ORD(parent=current)
        elif choice == 177:
            self.OVERLAPS(parent=current)
        elif choice == 178:
            self.PERIOD_ADD(parent=current)
        elif choice == 179:
            self.PERIOD_DIFF(parent=current)
        elif choice == 180:
            self.PI(parent=current)
        elif choice == 181:
            self.POINT(parent=current)
        elif choice == 182:
            self.POINTFROMTEXT(parent=current)
        elif choice == 183:
            self.POINTFROMWKB(parent=current)
        elif choice == 184:
            self.POINTN(parent=current)
        elif choice == 185:
            self.POLYFROMTEXT(parent=current)
        elif choice == 186:
            self.POLYFROMWKB(parent=current)
        elif choice == 187:
            self.POLYGON(parent=current)
        elif choice == 188:
            self.POLYGONFROMTEXT(parent=current)
        elif choice == 189:
            self.POLYGONFROMWKB(parent=current)
        elif choice == 190:
            self.POSITION(parent=current)
        elif choice == 191:
            self.POW(parent=current)
        elif choice == 192:
            self.POWER(parent=current)
        elif choice == 193:
            self.QUARTER(parent=current)
        elif choice == 194:
            self.QUOTE(parent=current)
        elif choice == 195:
            self.RADIANS(parent=current)
        elif choice == 196:
            self.RAND(parent=current)
        elif choice == 197:
            self.RANDOM_BYTES(parent=current)
        elif choice == 198:
            self.RELEASE_LOCK(parent=current)
        elif choice == 199:
            self.REVERSE(parent=current)
        elif choice == 200:
            self.RIGHT(parent=current)
        elif choice == 201:
            self.ROUND(parent=current)
        elif choice == 202:
            self.ROW_COUNT(parent=current)
        elif choice == 203:
            self.RPAD(parent=current)
        elif choice == 204:
            self.RTRIM(parent=current)
        elif choice == 205:
            self.SECOND(parent=current)
        elif choice == 206:
            self.SEC_TO_TIME(parent=current)
        elif choice == 207:
            self.SCHEMA(parent=current)
        elif choice == 208:
            self.SESSION_USER(parent=current)
        elif choice == 209:
            self.SESSION_VARIABLES_ADMIN(parent=current)
        elif choice == 210:
            self.SHA(parent=current)
        elif choice == 211:
            self.SHA1(parent=current)
        elif choice == 212:
            self.SHA2(parent=current)
        elif choice == 213:
            self.SIGN(parent=current)
        elif choice == 214:
            self.SIN(parent=current)
        elif choice == 215:
            self.SLEEP(parent=current)
        elif choice == 216:
            self.SOUNDEX(parent=current)
        elif choice == 217:
            self.SQL_THREAD_WAIT_AFTER_GTIDS(parent=current)
        elif choice == 218:
            self.SQRT(parent=current)
        elif choice == 219:
            self.SRID(parent=current)
        elif choice == 220:
            self.STARTPOINT(parent=current)
        elif choice == 221:
            self.STRCMP(parent=current)
        elif choice == 222:
            self.STR_TO_DATE(parent=current)
        elif choice == 223:
            self.ST_AREA(parent=current)
        elif choice == 224:
            self.ST_ASBINARY(parent=current)
        elif choice == 225:
            self.ST_ASTEXT(parent=current)
        elif choice == 226:
            self.ST_ASWKB(parent=current)
        elif choice == 227:
            self.ST_ASWKT(parent=current)
        elif choice == 228:
            self.ST_BUFFER(parent=current)
        elif choice == 229:
            self.ST_CENTROID(parent=current)
        elif choice == 230:
            self.ST_CONTAINS(parent=current)
        elif choice == 231:
            self.ST_CROSSES(parent=current)
        elif choice == 232:
            self.ST_DIFFERENCE(parent=current)
        elif choice == 233:
            self.ST_DIMENSION(parent=current)
        elif choice == 234:
            self.ST_DISJOINT(parent=current)
        elif choice == 235:
            self.ST_DISTANCE(parent=current)
        elif choice == 236:
            self.ST_ENDPOINT(parent=current)
        elif choice == 237:
            self.ST_ENVELOPE(parent=current)
        elif choice == 238:
            self.ST_EQUALS(parent=current)
        elif choice == 239:
            self.ST_EXTERIORRING(parent=current)
        elif choice == 240:
            self.ST_GEOMCOLLFROMTEXT(parent=current)
        elif choice == 241:
            self.ST_GEOMCOLLFROMTXT(parent=current)
        elif choice == 242:
            self.ST_GEOMCOLLFROMWKB(parent=current)
        elif choice == 243:
            self.ST_GEOMETRYCOLLECTIONFROMTEXT(parent=current)
        elif choice == 244:
            self.ST_GEOMETRYCOLLECTIONFROMWKB(parent=current)
        elif choice == 245:
            self.ST_GEOMETRYFROMTEXT(parent=current)
        elif choice == 246:
            self.ST_GEOMETRYFROMWKB(parent=current)
        elif choice == 247:
            self.ST_GEOMETRYN(parent=current)
        elif choice == 248:
            self.ST_GEOMETRYTYPE(parent=current)
        elif choice == 249:
            self.ST_GEOMFROMTEXT(parent=current)
        elif choice == 250:
            self.ST_GEOMFROMWKB(parent=current)
        elif choice == 251:
            self.ST_INTERIORRINGN(parent=current)
        elif choice == 252:
            self.ST_INTERSECTION(parent=current)
        elif choice == 253:
            self.ST_INTERSECTS(parent=current)
        elif choice == 254:
            self.ST_ISCLOSED(parent=current)
        elif choice == 255:
            self.ST_ISEMPTY(parent=current)
        elif choice == 256:
            self.ST_ISSIMPLE(parent=current)
        elif choice == 257:
            self.ST_LINEFROMTEXT(parent=current)
        elif choice == 258:
            self.ST_LINEFROMWKB(parent=current)
        elif choice == 259:
            self.ST_LINESTRINGFROMTEXT(parent=current)
        elif choice == 260:
            self.ST_LINESTRINGFROMWKB(parent=current)
        elif choice == 261:
            self.ST_NUMGEOMETRIES(parent=current)
        elif choice == 262:
            self.ST_NUMINTERIORRING(parent=current)
        elif choice == 263:
            self.ST_NUMINTERIORRINGS(parent=current)
        elif choice == 264:
            self.ST_NUMPOINTS(parent=current)
        elif choice == 265:
            self.ST_OVERLAPS(parent=current)
        elif choice == 266:
            self.ST_POINTFROMTEXT(parent=current)
        elif choice == 267:
            self.ST_POINTFROMWKB(parent=current)
        elif choice == 268:
            self.ST_POINTN(parent=current)
        elif choice == 269:
            self.ST_POLYFROMTEXT(parent=current)
        elif choice == 270:
            self.ST_POLYFROMWKB(parent=current)
        elif choice == 271:
            self.ST_POLYGONFROMTEXT(parent=current)
        elif choice == 272:
            self.ST_POLYGONFROMWKB(parent=current)
        elif choice == 273:
            self.ST_SRID(parent=current)
        elif choice == 274:
            self.ST_STARTPOINT(parent=current)
        elif choice == 275:
            self.ST_SYMDIFFERENCE(parent=current)
        elif choice == 276:
            self.ST_TOUCHES(parent=current)
        elif choice == 277:
            self.ST_UNION(parent=current)
        elif choice == 278:
            self.ST_WITHIN(parent=current)
        elif choice == 279:
            self.ST_X(parent=current)
        elif choice == 280:
            self.ST_Y(parent=current)
        elif choice == 281:
            self.SUBDATE(parent=current)
        elif choice == 282:
            self.SUBSTRING_INDEX(parent=current)
        elif choice == 283:
            self.SUBTIME(parent=current)
        elif choice == 284:
            self.SYSTEM_USER(parent=current)
        elif choice == 285:
            self.TAN(parent=current)
        elif choice == 286:
            self.TIME(parent=current)
        elif choice == 287:
            self.TIMEDIFF(parent=current)
        elif choice == 288:
            self.TIMESTAMP(parent=current)
        elif choice == 289:
            self.TIMESTAMPADD(parent=current)
        elif choice == 290:
            self.TIMESTAMPDIFF(parent=current)
        elif choice == 291:
            self.TIME_FORMAT(parent=current)
        elif choice == 292:
            self.TIME_TO_SEC(parent=current)
        elif choice == 293:
            self.TOUCHES(parent=current)
        elif choice == 294:
            self.TO_BASE64(parent=current)
        elif choice == 295:
            self.TO_DAYS(parent=current)
        elif choice == 296:
            self.TO_SECONDS(parent=current)
        elif choice == 297:
            self.UCASE(parent=current)
        elif choice == 298:
            self.UNCOMPRESS(parent=current)
        elif choice == 299:
            self.UNCOMPRESSED_LENGTH(parent=current)
        elif choice == 300:
            self.UNHEX(parent=current)
        elif choice == 301:
            self.UNIX_TIMESTAMP(parent=current)
        elif choice == 302:
            self.UPDATEXML(parent=current)
        elif choice == 303:
            self.UPPER(parent=current)
        elif choice == 304:
            self.UUID(parent=current)
        elif choice == 305:
            self.UUID_SHORT(parent=current)
        elif choice == 306:
            self.VALIDATE_PASSWORD_STRENGTH(parent=current)
        elif choice == 307:
            self.VERSION(parent=current)
        elif choice == 308:
            self.VISIBLE(parent=current)
        elif choice == 309:
            self.WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS(parent=current)
        elif choice == 310:
            self.WEEK(parent=current)
        elif choice == 311:
            self.WEEKDAY(parent=current)
        elif choice == 312:
            self.WEEKOFYEAR(parent=current)
        elif choice == 313:
            self.WEIGHT_STRING(parent=current)
        elif choice == 314:
            self.WITHIN(parent=current)
        elif choice == 315:
            self.YEAR(parent=current)
        elif choice == 316:
            self.YEARWEEK(parent=current)
        elif choice == 317:
            self.Y_FUNCTION(parent=current)
        elif choice == 318:
            self.X_FUNCTION(parent=current)
        elif choice == 319:
            self.JSON_ARRAY(parent=current)
        elif choice == 320:
            self.JSON_OBJECT(parent=current)
        elif choice == 321:
            self.JSON_QUOTE(parent=current)
        elif choice == 322:
            self.JSON_CONTAINS(parent=current)
        elif choice == 323:
            self.JSON_CONTAINS_PATH(parent=current)
        elif choice == 324:
            self.JSON_EXTRACT(parent=current)
        elif choice == 325:
            self.JSON_KEYS(parent=current)
        elif choice == 326:
            self.JSON_OVERLAPS(parent=current)
        elif choice == 327:
            self.JSON_SEARCH(parent=current)
        elif choice == 328:
            self.JSON_VALUE(parent=current)
        elif choice == 329:
            self.JSON_ARRAY_APPEND(parent=current)
        elif choice == 330:
            self.JSON_ARRAY_INSERT(parent=current)
        elif choice == 331:
            self.JSON_INSERT(parent=current)
        elif choice == 332:
            self.JSON_MERGE(parent=current)
        elif choice == 333:
            self.JSON_MERGE_PATCH(parent=current)
        elif choice == 334:
            self.JSON_MERGE_PRESERVE(parent=current)
        elif choice == 335:
            self.JSON_REMOVE(parent=current)
        elif choice == 336:
            self.JSON_REPLACE(parent=current)
        elif choice == 337:
            self.JSON_SET(parent=current)
        elif choice == 338:
            self.JSON_UNQUOTE(parent=current)
        elif choice == 339:
            self.JSON_DEPTH(parent=current)
        elif choice == 340:
            self.JSON_LENGTH(parent=current)
        elif choice == 341:
            self.JSON_TYPE(parent=current)
        elif choice == 342:
            self.JSON_VALID(parent=current)
        elif choice == 343:
            self.JSON_TABLE(parent=current)
        elif choice == 344:
            self.JSON_SCHEMA_VALID(parent=current)
        elif choice == 345:
            self.JSON_SCHEMA_VALIDATION_REPORT(parent=current)
        elif choice == 346:
            self.JSON_PRETTY(parent=current)
        elif choice == 347:
            self.JSON_STORAGE_FREE(parent=current)
        elif choice == 348:
            self.JSON_STORAGE_SIZE(parent=current)
        elif choice == 349:
            self.JSON_ARRAYAGG(parent=current)
        elif choice == 350:
            self.JSON_OBJECTAGG(parent=current)
        self.exit_rule(current)
        return current
    functionNameBase.min_depth = 1

    @depthcontrol
    def createTable_copyCreateTable(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='createTable_copyCreateTable', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.TEMPORARY(parent=current)
        self.TABLE(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.ifNotExists(parent=current)
        self.tableName(parent=current)
        choice = self.model.choice(current, 0, [0 if [4, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.LIKE(parent=current)
            self.tableName(parent=current)
        elif choice == 1:
            UnlexerRule(src='(', parent=current)
            self.LIKE(parent=current)
            self.tableName(parent=current)
            local_ctx['parenthesisTable'] = current.last_child
            UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    createTable_copyCreateTable.min_depth = 4

    @depthcontrol
    def createTable_queryCreateTable(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='createTable_queryCreateTable', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.TEMPORARY(parent=current)
        self.TABLE(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.ifNotExists(parent=current)
        self.tableName(parent=current)
        if self.max_depth >= 7:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.createDefinitions(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.tableOption(parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 4, min=0, max=inf):
                        if self.max_depth >= 0:
                            for _ in self.model.quantify(current, 5, min=0, max=1):
                                UnlexerRule(src=',', parent=current)
                        self.tableOption(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 6, min=0, max=1):
                self.partitionDefinitions(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 7, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.IGNORE(parent=current)
                elif choice == 1:
                    self.REPLACE(parent=current)
                local_ctx['keyViolate'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 8, min=0, max=1):
                self.AS(parent=current)
        self.selectStatement(parent=current)
        self.exit_rule(current)
        return current
    createTable_queryCreateTable.min_depth = 4

    @depthcontrol
    def createTable_columnCreateTable(self, parent=None):
        current = UnparserRule(name='createTable_columnCreateTable', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.TEMPORARY(parent=current)
        self.TABLE(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.ifNotExists(parent=current)
        self.tableName(parent=current)
        self.createDefinitions(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.tableOption(parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 3, min=0, max=inf):
                        if self.max_depth >= 0:
                            for _ in self.model.quantify(current, 4, min=0, max=1):
                                UnlexerRule(src=',', parent=current)
                        self.tableOption(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 5, min=0, max=1):
                self.partitionDefinitions(parent=current)
        self.exit_rule(current)
        return current
    createTable_columnCreateTable.min_depth = 7

    @depthcontrol
    def scheduleExpression_preciseSchedule(self, parent=None):
        current = UnparserRule(name='scheduleExpression_preciseSchedule', parent=parent)
        self.enter_rule(current)
        self.AT(parent=current)
        self.timestampValue(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.intervalExpr(parent=current)
        self.exit_rule(current)
        return current
    scheduleExpression_preciseSchedule.min_depth = 2

    @depthcontrol
    def scheduleExpression_intervalSchedule(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='scheduleExpression_intervalSchedule', parent=parent)
        self.enter_rule(current)
        self.EVERY(parent=current)
        choice = self.model.choice(current, 0, [0 if [2, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.decimalLiteral(parent=current)
        elif choice == 1:
            self.expression(parent=current)
        self.intervalType(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.STARTS(parent=current)
                self.timestampValue(parent=current)
                local_ctx['startTimestamp'] = current.last_child
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 1, min=0, max=inf):
                        self.intervalExpr(parent=current)
                        local_ctx['startIntervals'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.ENDS(parent=current)
                self.timestampValue(parent=current)
                local_ctx['endTimestamp'] = current.last_child
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 3, min=0, max=inf):
                        self.intervalExpr(parent=current)
                        local_ctx['endIntervals'] = current.last_child
        self.exit_rule(current)
        return current
    scheduleExpression_intervalSchedule.min_depth = 2

    @depthcontrol
    def routineOption_routineComment(self, parent=None):
        current = UnparserRule(name='routineOption_routineComment', parent=parent)
        self.enter_rule(current)
        self.COMMENT(parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    routineOption_routineComment.min_depth = 2

    @depthcontrol
    def routineOption_routineLanguage(self, parent=None):
        current = UnparserRule(name='routineOption_routineLanguage', parent=parent)
        self.enter_rule(current)
        self.LANGUAGE(parent=current)
        self.SQL(parent=current)
        self.exit_rule(current)
        return current
    routineOption_routineLanguage.min_depth = 1

    @depthcontrol
    def routineOption_routineBehavior(self, parent=None):
        current = UnparserRule(name='routineOption_routineBehavior', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.NOT(parent=current)
        self.DETERMINISTIC(parent=current)
        self.exit_rule(current)
        return current
    routineOption_routineBehavior.min_depth = 1

    @depthcontrol
    def routineOption_routineData(self, parent=None):
        current = UnparserRule(name='routineOption_routineData', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.CONTAINS(parent=current)
            self.SQL(parent=current)
        elif choice == 1:
            self.NO(parent=current)
            self.SQL(parent=current)
        elif choice == 2:
            self.READS(parent=current)
            self.SQL(parent=current)
            self.DATA(parent=current)
        elif choice == 3:
            self.MODIFIES(parent=current)
            self.SQL(parent=current)
            self.DATA(parent=current)
        self.exit_rule(current)
        return current
    routineOption_routineData.min_depth = 1

    @depthcontrol
    def routineOption_routineSecurity(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='routineOption_routineSecurity', parent=parent)
        self.enter_rule(current)
        self.SQL(parent=current)
        self.SECURITY(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.DEFINER(parent=current)
        elif choice == 1:
            self.INVOKER(parent=current)
        local_ctx['context'] = current.last_child
        self.exit_rule(current)
        return current
    routineOption_routineSecurity.min_depth = 1

    @depthcontrol
    def createDefinition_columnDeclaration(self, parent=None):
        current = UnparserRule(name='createDefinition_columnDeclaration', parent=parent)
        self.enter_rule(current)
        self.uid(parent=current)
        self.columnDefinition(parent=current)
        self.exit_rule(current)
        return current
    createDefinition_columnDeclaration.min_depth = 4

    @depthcontrol
    def createDefinition_constraintDeclaration(self, parent=None):
        current = UnparserRule(name='createDefinition_constraintDeclaration', parent=parent)
        self.enter_rule(current)
        self.tableConstraint(parent=current)
        self.exit_rule(current)
        return current
    createDefinition_constraintDeclaration.min_depth = 6

    @depthcontrol
    def createDefinition_indexDeclaration(self, parent=None):
        current = UnparserRule(name='createDefinition_indexDeclaration', parent=parent)
        self.enter_rule(current)
        self.indexColumnDefinition(parent=current)
        self.exit_rule(current)
        return current
    createDefinition_indexDeclaration.min_depth = 6

    @depthcontrol
    def columnConstraint_nullColumnConstraint(self, parent=None):
        current = UnparserRule(name='columnConstraint_nullColumnConstraint', parent=parent)
        self.enter_rule(current)
        self.nullNotnull(parent=current)
        self.exit_rule(current)
        return current
    columnConstraint_nullColumnConstraint.min_depth = 2

    @depthcontrol
    def columnConstraint_defaultColumnConstraint(self, parent=None):
        current = UnparserRule(name='columnConstraint_defaultColumnConstraint', parent=parent)
        self.enter_rule(current)
        self.DEFAULT(parent=current)
        self.defaultValue(parent=current)
        self.exit_rule(current)
        return current
    columnConstraint_defaultColumnConstraint.min_depth = 2

    @depthcontrol
    def columnConstraint_autoIncrementColumnConstraint(self, parent=None):
        current = UnparserRule(name='columnConstraint_autoIncrementColumnConstraint', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.AUTO_INCREMENT(parent=current)
        elif choice == 1:
            self.ON(parent=current)
            self.UPDATE(parent=current)
            self.currentTimestamp(parent=current)
        self.exit_rule(current)
        return current
    columnConstraint_autoIncrementColumnConstraint.min_depth = 1

    @depthcontrol
    def columnConstraint_primaryKeyColumnConstraint(self, parent=None):
        current = UnparserRule(name='columnConstraint_primaryKeyColumnConstraint', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.PRIMARY(parent=current)
        self.KEY(parent=current)
        self.exit_rule(current)
        return current
    columnConstraint_primaryKeyColumnConstraint.min_depth = 1

    @depthcontrol
    def columnConstraint_uniqueKeyColumnConstraint(self, parent=None):
        current = UnparserRule(name='columnConstraint_uniqueKeyColumnConstraint', parent=parent)
        self.enter_rule(current)
        self.UNIQUE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.KEY(parent=current)
        self.exit_rule(current)
        return current
    columnConstraint_uniqueKeyColumnConstraint.min_depth = 1

    @depthcontrol
    def columnConstraint_commentColumnConstraint(self, parent=None):
        current = UnparserRule(name='columnConstraint_commentColumnConstraint', parent=parent)
        self.enter_rule(current)
        self.COMMENT(parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    columnConstraint_commentColumnConstraint.min_depth = 2

    @depthcontrol
    def columnConstraint_formatColumnConstraint(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='columnConstraint_formatColumnConstraint', parent=parent)
        self.enter_rule(current)
        self.COLUMN_FORMAT(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.FIXED(parent=current)
        elif choice == 1:
            self.DYNAMIC(parent=current)
        elif choice == 2:
            self.DEFAULT(parent=current)
        local_ctx['colformat'] = current.last_child
        self.exit_rule(current)
        return current
    columnConstraint_formatColumnConstraint.min_depth = 1

    @depthcontrol
    def columnConstraint_storageColumnConstraint(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='columnConstraint_storageColumnConstraint', parent=parent)
        self.enter_rule(current)
        self.STORAGE(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.DISK(parent=current)
        elif choice == 1:
            self.MEMORY(parent=current)
        elif choice == 2:
            self.DEFAULT(parent=current)
        local_ctx['storageval'] = current.last_child
        self.exit_rule(current)
        return current
    columnConstraint_storageColumnConstraint.min_depth = 1

    @depthcontrol
    def columnConstraint_referenceColumnConstraint(self, parent=None):
        current = UnparserRule(name='columnConstraint_referenceColumnConstraint', parent=parent)
        self.enter_rule(current)
        self.referenceDefinition(parent=current)
        self.exit_rule(current)
        return current
    columnConstraint_referenceColumnConstraint.min_depth = 5

    @depthcontrol
    def columnConstraint_collateColumnConstraint(self, parent=None):
        current = UnparserRule(name='columnConstraint_collateColumnConstraint', parent=parent)
        self.enter_rule(current)
        self.COLLATE(parent=current)
        self.collationName(parent=current)
        self.exit_rule(current)
        return current
    columnConstraint_collateColumnConstraint.min_depth = 3

    @depthcontrol
    def columnConstraint_generatedColumnConstraint(self, parent=None):
        current = UnparserRule(name='columnConstraint_generatedColumnConstraint', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.GENERATED(parent=current)
                self.ALWAYS(parent=current)
        self.AS(parent=current)
        UnlexerRule(src='(', parent=current)
        self.expression(parent=current)
        UnlexerRule(src=')', parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.VIRTUAL(parent=current)
                elif choice == 1:
                    self.STORED(parent=current)
        self.exit_rule(current)
        return current
    columnConstraint_generatedColumnConstraint.min_depth = 8

    @depthcontrol
    def columnConstraint_serialDefaultColumnConstraint(self, parent=None):
        current = UnparserRule(name='columnConstraint_serialDefaultColumnConstraint', parent=parent)
        self.enter_rule(current)
        self.SERIAL(parent=current)
        self.DEFAULT(parent=current)
        self.VALUE(parent=current)
        self.exit_rule(current)
        return current
    columnConstraint_serialDefaultColumnConstraint.min_depth = 1

    @depthcontrol
    def columnConstraint_checkColumnConstraint(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='columnConstraint_checkColumnConstraint', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.CONSTRAINT(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.uid(parent=current)
                        local_ctx['name'] = current.last_child
        self.CHECK(parent=current)
        UnlexerRule(src='(', parent=current)
        self.expression(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    columnConstraint_checkColumnConstraint.min_depth = 8

    @depthcontrol
    def tableConstraint_primaryKeyTableConstraint(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='tableConstraint_primaryKeyTableConstraint', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.CONSTRAINT(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.uid(parent=current)
                        local_ctx['name'] = current.last_child
        self.PRIMARY(parent=current)
        self.KEY(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.uid(parent=current)
                local_ctx['index'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.indexType(parent=current)
        self.indexColumnNames(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 4, min=0, max=inf):
                self.indexOption(parent=current)
        self.exit_rule(current)
        return current
    tableConstraint_primaryKeyTableConstraint.min_depth = 4

    @depthcontrol
    def tableConstraint_uniqueKeyTableConstraint(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='tableConstraint_uniqueKeyTableConstraint', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.CONSTRAINT(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.uid(parent=current)
                        local_ctx['name'] = current.last_child
        self.UNIQUE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.INDEX(parent=current)
                elif choice == 1:
                    self.KEY(parent=current)
                local_ctx['indexFormat'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.uid(parent=current)
                local_ctx['index'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.indexType(parent=current)
        self.indexColumnNames(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 5, min=0, max=inf):
                self.indexOption(parent=current)
        self.exit_rule(current)
        return current
    tableConstraint_uniqueKeyTableConstraint.min_depth = 4

    @depthcontrol
    def tableConstraint_foreignKeyTableConstraint(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='tableConstraint_foreignKeyTableConstraint', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.CONSTRAINT(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.uid(parent=current)
                        local_ctx['name'] = current.last_child
        self.FOREIGN(parent=current)
        self.KEY(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.uid(parent=current)
                local_ctx['index'] = current.last_child
        self.indexColumnNames(parent=current)
        self.referenceDefinition(parent=current)
        self.exit_rule(current)
        return current
    tableConstraint_foreignKeyTableConstraint.min_depth = 5

    @depthcontrol
    def tableConstraint_checkTableConstraint(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='tableConstraint_checkTableConstraint', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.CONSTRAINT(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.uid(parent=current)
                        local_ctx['name'] = current.last_child
        self.CHECK(parent=current)
        UnlexerRule(src='(', parent=current)
        self.expression(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    tableConstraint_checkTableConstraint.min_depth = 8

    @depthcontrol
    def indexColumnDefinition_simpleIndexDeclaration(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='indexColumnDefinition_simpleIndexDeclaration', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.INDEX(parent=current)
        elif choice == 1:
            self.KEY(parent=current)
        local_ctx['indexFormat'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.uid(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.indexType(parent=current)
        self.indexColumnNames(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=inf):
                self.indexOption(parent=current)
        self.exit_rule(current)
        return current
    indexColumnDefinition_simpleIndexDeclaration.min_depth = 4

    @depthcontrol
    def indexColumnDefinition_specialIndexDeclaration(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='indexColumnDefinition_specialIndexDeclaration', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.FULLTEXT(parent=current)
        elif choice == 1:
            self.SPATIAL(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.INDEX(parent=current)
                elif choice == 1:
                    self.KEY(parent=current)
                local_ctx['indexFormat'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.uid(parent=current)
        self.indexColumnNames(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=inf):
                self.indexOption(parent=current)
        self.exit_rule(current)
        return current
    indexColumnDefinition_specialIndexDeclaration.min_depth = 4

    @depthcontrol
    def tableOption_tableOptionEngine(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionEngine', parent=parent)
        self.enter_rule(current)
        self.ENGINE(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.engineName(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionEngine.min_depth = 2

    @depthcontrol
    def tableOption_tableOptionAutoIncrement(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionAutoIncrement', parent=parent)
        self.enter_rule(current)
        self.AUTO_INCREMENT(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.decimalLiteral(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionAutoIncrement.min_depth = 2

    @depthcontrol
    def tableOption_tableOptionAverage(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionAverage', parent=parent)
        self.enter_rule(current)
        self.AVG_ROW_LENGTH(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.decimalLiteral(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionAverage.min_depth = 2

    @depthcontrol
    def tableOption_tableOptionCharset(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionCharset', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.DEFAULT(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.CHARACTER(parent=current)
            self.SET(parent=current)
        elif choice == 1:
            self.CHARSET(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 1, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.charsetName(parent=current)
        elif choice == 1:
            self.DEFAULT(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionCharset.min_depth = 1

    @depthcontrol
    def tableOption_tableOptionChecksum(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='tableOption_tableOptionChecksum', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.CHECKSUM(parent=current)
        elif choice == 1:
            self.PAGE_CHECKSUM(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 1, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='0', parent=current)
        elif choice == 1:
            UnlexerRule(src='1', parent=current)
        local_ctx['boolValue'] = current.last_child
        self.exit_rule(current)
        return current
    tableOption_tableOptionChecksum.min_depth = 1

    @depthcontrol
    def tableOption_tableOptionCollate(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionCollate', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.DEFAULT(parent=current)
        self.COLLATE(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.collationName(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionCollate.min_depth = 3

    @depthcontrol
    def tableOption_tableOptionComment(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionComment', parent=parent)
        self.enter_rule(current)
        self.COMMENT(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionComment.min_depth = 2

    @depthcontrol
    def tableOption_tableOptionCompression(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionCompression', parent=parent)
        self.enter_rule(current)
        self.COMPRESSION(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.STRING_LITERAL(parent=current)
        elif choice == 1:
            self.ID(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionCompression.min_depth = 2

    @depthcontrol
    def tableOption_tableOptionConnection(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionConnection', parent=parent)
        self.enter_rule(current)
        self.CONNECTION(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionConnection.min_depth = 2

    @depthcontrol
    def tableOption_tableOptionDataDirectory(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionDataDirectory', parent=parent)
        self.enter_rule(current)
        self.DATA(parent=current)
        self.DIRECTORY(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionDataDirectory.min_depth = 2

    @depthcontrol
    def tableOption_tableOptionDelay(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='tableOption_tableOptionDelay', parent=parent)
        self.enter_rule(current)
        self.DELAY_KEY_WRITE(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='0', parent=current)
        elif choice == 1:
            UnlexerRule(src='1', parent=current)
        local_ctx['boolValue'] = current.last_child
        self.exit_rule(current)
        return current
    tableOption_tableOptionDelay.min_depth = 1

    @depthcontrol
    def tableOption_tableOptionEncryption(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionEncryption', parent=parent)
        self.enter_rule(current)
        self.ENCRYPTION(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionEncryption.min_depth = 2

    @depthcontrol
    def tableOption_tableOptionIndexDirectory(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionIndexDirectory', parent=parent)
        self.enter_rule(current)
        self.INDEX(parent=current)
        self.DIRECTORY(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionIndexDirectory.min_depth = 2

    @depthcontrol
    def tableOption_tableOptionInsertMethod(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='tableOption_tableOptionInsertMethod', parent=parent)
        self.enter_rule(current)
        self.INSERT_METHOD(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.NO(parent=current)
        elif choice == 1:
            self.FIRST(parent=current)
        elif choice == 2:
            self.LAST(parent=current)
        local_ctx['insertMethod'] = current.last_child
        self.exit_rule(current)
        return current
    tableOption_tableOptionInsertMethod.min_depth = 1

    @depthcontrol
    def tableOption_tableOptionKeyBlockSize(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionKeyBlockSize', parent=parent)
        self.enter_rule(current)
        self.KEY_BLOCK_SIZE(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.fileSizeLiteral(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionKeyBlockSize.min_depth = 3

    @depthcontrol
    def tableOption_tableOptionMaxRows(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionMaxRows', parent=parent)
        self.enter_rule(current)
        self.MAX_ROWS(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.decimalLiteral(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionMaxRows.min_depth = 2

    @depthcontrol
    def tableOption_tableOptionMinRows(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionMinRows', parent=parent)
        self.enter_rule(current)
        self.MIN_ROWS(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.decimalLiteral(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionMinRows.min_depth = 2

    @depthcontrol
    def tableOption_tableOptionPackKeys(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='tableOption_tableOptionPackKeys', parent=parent)
        self.enter_rule(current)
        self.PACK_KEYS(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='0', parent=current)
        elif choice == 1:
            UnlexerRule(src='1', parent=current)
        elif choice == 2:
            self.DEFAULT(parent=current)
        local_ctx['extBoolValue'] = current.last_child
        self.exit_rule(current)
        return current
    tableOption_tableOptionPackKeys.min_depth = 1

    @depthcontrol
    def tableOption_tableOptionPassword(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionPassword', parent=parent)
        self.enter_rule(current)
        self.PASSWORD(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionPassword.min_depth = 2

    @depthcontrol
    def tableOption_tableOptionRowFormat(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='tableOption_tableOptionRowFormat', parent=parent)
        self.enter_rule(current)
        self.ROW_FORMAT(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.DEFAULT(parent=current)
        elif choice == 1:
            self.DYNAMIC(parent=current)
        elif choice == 2:
            self.FIXED(parent=current)
        elif choice == 3:
            self.COMPRESSED(parent=current)
        elif choice == 4:
            self.REDUNDANT(parent=current)
        elif choice == 5:
            self.COMPACT(parent=current)
        elif choice == 6:
            self.ID(parent=current)
        local_ctx['rowFormat'] = current.last_child
        self.exit_rule(current)
        return current
    tableOption_tableOptionRowFormat.min_depth = 1

    @depthcontrol
    def tableOption_tableOptionRecalculation(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='tableOption_tableOptionRecalculation', parent=parent)
        self.enter_rule(current)
        self.STATS_AUTO_RECALC(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.DEFAULT(parent=current)
        elif choice == 1:
            UnlexerRule(src='0', parent=current)
        elif choice == 2:
            UnlexerRule(src='1', parent=current)
        local_ctx['extBoolValue'] = current.last_child
        self.exit_rule(current)
        return current
    tableOption_tableOptionRecalculation.min_depth = 1

    @depthcontrol
    def tableOption_tableOptionPersistent(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='tableOption_tableOptionPersistent', parent=parent)
        self.enter_rule(current)
        self.STATS_PERSISTENT(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.DEFAULT(parent=current)
        elif choice == 1:
            UnlexerRule(src='0', parent=current)
        elif choice == 2:
            UnlexerRule(src='1', parent=current)
        local_ctx['extBoolValue'] = current.last_child
        self.exit_rule(current)
        return current
    tableOption_tableOptionPersistent.min_depth = 1

    @depthcontrol
    def tableOption_tableOptionSamplePage(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionSamplePage', parent=parent)
        self.enter_rule(current)
        self.STATS_SAMPLE_PAGES(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.decimalLiteral(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionSamplePage.min_depth = 2

    @depthcontrol
    def tableOption_tableOptionTablespace(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionTablespace', parent=parent)
        self.enter_rule(current)
        self.tablespaceStorage(parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionTablespace.min_depth = 2

    @depthcontrol
    def tableOption_tableOptionUnion(self, parent=None):
        current = UnparserRule(name='tableOption_tableOptionUnion', parent=parent)
        self.enter_rule(current)
        self.UNION(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        UnlexerRule(src='(', parent=current)
        self.tables(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    tableOption_tableOptionUnion.min_depth = 5

    @depthcontrol
    def partitionFunctionDefinition_partitionFunctionHash(self, parent=None):
        current = UnparserRule(name='partitionFunctionDefinition_partitionFunctionHash', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.LINEAR(parent=current)
        self.HASH(parent=current)
        UnlexerRule(src='(', parent=current)
        self.expression(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    partitionFunctionDefinition_partitionFunctionHash.min_depth = 8

    @depthcontrol
    def partitionFunctionDefinition_partitionFunctionKey(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='partitionFunctionDefinition_partitionFunctionKey', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.LINEAR(parent=current)
        self.KEY(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.ALGORITHM(parent=current)
                UnlexerRule(src='=', parent=current)
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='1', parent=current)
                elif choice == 1:
                    UnlexerRule(src='2', parent=current)
                local_ctx['algType'] = current.last_child
        UnlexerRule(src='(', parent=current)
        self.uidList(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    partitionFunctionDefinition_partitionFunctionKey.min_depth = 3

    @depthcontrol
    def partitionFunctionDefinition_partitionFunctionRange(self, parent=None):
        current = UnparserRule(name='partitionFunctionDefinition_partitionFunctionRange', parent=parent)
        self.enter_rule(current)
        self.RANGE(parent=current)
        choice = self.model.choice(current, 0, [0 if [8, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='(', parent=current)
            self.expression(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 1:
            self.COLUMNS(parent=current)
            UnlexerRule(src='(', parent=current)
            self.uidList(parent=current)
            UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    partitionFunctionDefinition_partitionFunctionRange.min_depth = 3

    @depthcontrol
    def partitionFunctionDefinition_partitionFunctionList(self, parent=None):
        current = UnparserRule(name='partitionFunctionDefinition_partitionFunctionList', parent=parent)
        self.enter_rule(current)
        self.LIST(parent=current)
        choice = self.model.choice(current, 0, [0 if [8, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='(', parent=current)
            self.expression(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 1:
            self.COLUMNS(parent=current)
            UnlexerRule(src='(', parent=current)
            self.uidList(parent=current)
            UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    partitionFunctionDefinition_partitionFunctionList.min_depth = 3

    @depthcontrol
    def subpartitionFunctionDefinition_subPartitionFunctionHash(self, parent=None):
        current = UnparserRule(name='subpartitionFunctionDefinition_subPartitionFunctionHash', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.LINEAR(parent=current)
        self.HASH(parent=current)
        UnlexerRule(src='(', parent=current)
        self.expression(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    subpartitionFunctionDefinition_subPartitionFunctionHash.min_depth = 8

    @depthcontrol
    def subpartitionFunctionDefinition_subPartitionFunctionKey(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='subpartitionFunctionDefinition_subPartitionFunctionKey', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.LINEAR(parent=current)
        self.KEY(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.ALGORITHM(parent=current)
                UnlexerRule(src='=', parent=current)
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='1', parent=current)
                elif choice == 1:
                    UnlexerRule(src='2', parent=current)
                local_ctx['algType'] = current.last_child
        UnlexerRule(src='(', parent=current)
        self.uidList(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    subpartitionFunctionDefinition_subPartitionFunctionKey.min_depth = 3

    @depthcontrol
    def partitionDefinition_partitionComparison(self, parent=None):
        current = UnparserRule(name='partitionDefinition_partitionComparison', parent=parent)
        self.enter_rule(current)
        self.PARTITION(parent=current)
        self.uid(parent=current)
        self.VALUES(parent=current)
        self.LESS(parent=current)
        self.THAN(parent=current)
        self.partitionDefinerAtom(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.partitionOption(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                UnlexerRule(src='(', parent=current)
                self.subpartitionDefinition(parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 2, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.subpartitionDefinition(parent=current)
                UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    partitionDefinition_partitionComparison.min_depth = 2

    @depthcontrol
    def partitionDefinition_partitionListAtom(self, parent=None):
        current = UnparserRule(name='partitionDefinition_partitionListAtom', parent=parent)
        self.enter_rule(current)
        self.PARTITION(parent=current)
        self.uid(parent=current)
        self.VALUES(parent=current)
        self.IN(parent=current)
        UnlexerRule(src='(', parent=current)
        self.partitionDefinerAtom(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.partitionDefinerAtom(parent=current)
        UnlexerRule(src=')', parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                self.partitionOption(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                UnlexerRule(src='(', parent=current)
                self.subpartitionDefinition(parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 3, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.subpartitionDefinition(parent=current)
                UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    partitionDefinition_partitionListAtom.min_depth = 2

    @depthcontrol
    def partitionDefinition_partitionListVector(self, parent=None):
        current = UnparserRule(name='partitionDefinition_partitionListVector', parent=parent)
        self.enter_rule(current)
        self.PARTITION(parent=current)
        self.uid(parent=current)
        self.VALUES(parent=current)
        self.IN(parent=current)
        UnlexerRule(src='(', parent=current)
        self.partitionDefinerVector(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.partitionDefinerVector(parent=current)
        UnlexerRule(src=')', parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                self.partitionOption(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                UnlexerRule(src='(', parent=current)
                self.subpartitionDefinition(parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 3, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.subpartitionDefinition(parent=current)
                UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    partitionDefinition_partitionListVector.min_depth = 3

    @depthcontrol
    def partitionDefinition_partitionSimple(self, parent=None):
        current = UnparserRule(name='partitionDefinition_partitionSimple', parent=parent)
        self.enter_rule(current)
        self.PARTITION(parent=current)
        self.uid(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.partitionOption(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                UnlexerRule(src='(', parent=current)
                self.subpartitionDefinition(parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 2, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.subpartitionDefinition(parent=current)
                UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    partitionDefinition_partitionSimple.min_depth = 2

    @depthcontrol
    def partitionOption_partitionOptionEngine(self, parent=None):
        current = UnparserRule(name='partitionOption_partitionOptionEngine', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.STORAGE(parent=current)
        self.ENGINE(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.engineName(parent=current)
        self.exit_rule(current)
        return current
    partitionOption_partitionOptionEngine.min_depth = 2

    @depthcontrol
    def partitionOption_partitionOptionComment(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='partitionOption_partitionOptionComment', parent=parent)
        self.enter_rule(current)
        self.COMMENT(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        local_ctx['comment'] = current.last_child
        self.exit_rule(current)
        return current
    partitionOption_partitionOptionComment.min_depth = 2

    @depthcontrol
    def partitionOption_partitionOptionDataDirectory(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='partitionOption_partitionOptionDataDirectory', parent=parent)
        self.enter_rule(current)
        self.DATA(parent=current)
        self.DIRECTORY(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        local_ctx['dataDirectory'] = current.last_child
        self.exit_rule(current)
        return current
    partitionOption_partitionOptionDataDirectory.min_depth = 2

    @depthcontrol
    def partitionOption_partitionOptionIndexDirectory(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='partitionOption_partitionOptionIndexDirectory', parent=parent)
        self.enter_rule(current)
        self.INDEX(parent=current)
        self.DIRECTORY(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        local_ctx['indexDirectory'] = current.last_child
        self.exit_rule(current)
        return current
    partitionOption_partitionOptionIndexDirectory.min_depth = 2

    @depthcontrol
    def partitionOption_partitionOptionMaxRows(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='partitionOption_partitionOptionMaxRows', parent=parent)
        self.enter_rule(current)
        self.MAX_ROWS(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.decimalLiteral(parent=current)
        local_ctx['maxRows'] = current.last_child
        self.exit_rule(current)
        return current
    partitionOption_partitionOptionMaxRows.min_depth = 2

    @depthcontrol
    def partitionOption_partitionOptionMinRows(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='partitionOption_partitionOptionMinRows', parent=parent)
        self.enter_rule(current)
        self.MIN_ROWS(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.decimalLiteral(parent=current)
        local_ctx['minRows'] = current.last_child
        self.exit_rule(current)
        return current
    partitionOption_partitionOptionMinRows.min_depth = 2

    @depthcontrol
    def partitionOption_partitionOptionTablespace(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='partitionOption_partitionOptionTablespace', parent=parent)
        self.enter_rule(current)
        self.TABLESPACE(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.uid(parent=current)
        local_ctx['tablespace'] = current.last_child
        self.exit_rule(current)
        return current
    partitionOption_partitionOptionTablespace.min_depth = 2

    @depthcontrol
    def partitionOption_partitionOptionNodeGroup(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='partitionOption_partitionOptionNodeGroup', parent=parent)
        self.enter_rule(current)
        self.NODEGROUP(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        self.uid(parent=current)
        local_ctx['nodegroup'] = current.last_child
        self.exit_rule(current)
        return current
    partitionOption_partitionOptionNodeGroup.min_depth = 2

    @depthcontrol
    def alterDatabase_alterSimpleDatabase(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterDatabase_alterSimpleDatabase', parent=parent)
        self.enter_rule(current)
        self.ALTER(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.DATABASE(parent=current)
        elif choice == 1:
            self.SCHEMA(parent=current)
        local_ctx['dbFormat'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.uid(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=1, max=inf):
                self.createDatabaseOption(parent=current)
        self.exit_rule(current)
        return current
    alterDatabase_alterSimpleDatabase.min_depth = 2

    @depthcontrol
    def alterDatabase_alterUpgradeName(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterDatabase_alterUpgradeName', parent=parent)
        self.enter_rule(current)
        self.ALTER(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.DATABASE(parent=current)
        elif choice == 1:
            self.SCHEMA(parent=current)
        local_ctx['dbFormat'] = current.last_child
        self.uid(parent=current)
        self.UPGRADE(parent=current)
        self.DATA(parent=current)
        self.DIRECTORY(parent=current)
        self.NAME(parent=current)
        self.exit_rule(current)
        return current
    alterDatabase_alterUpgradeName.min_depth = 2

    @depthcontrol
    def alterSpecification_alterByTableOption(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByTableOption', parent=parent)
        self.enter_rule(current)
        self.tableOption(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        UnlexerRule(src=',', parent=current)
                self.tableOption(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByTableOption.min_depth = 3

    @depthcontrol
    def alterSpecification_alterByAddColumn(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByAddColumn', parent=parent)
        self.enter_rule(current)
        self.ADD(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.COLUMN(parent=current)
        self.uid(parent=current)
        self.columnDefinition(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.FIRST(parent=current)
                elif choice == 1:
                    self.AFTER(parent=current)
                    self.uid(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByAddColumn.min_depth = 4

    @depthcontrol
    def alterSpecification_alterByAddColumns(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByAddColumns', parent=parent)
        self.enter_rule(current)
        self.ADD(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.COLUMN(parent=current)
        UnlexerRule(src='(', parent=current)
        self.uid(parent=current)
        self.columnDefinition(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.uid(parent=current)
                self.columnDefinition(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByAddColumns.min_depth = 4

    @depthcontrol
    def alterSpecification_alterByAddIndex(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterSpecification_alterByAddIndex', parent=parent)
        self.enter_rule(current)
        self.ADD(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.INDEX(parent=current)
        elif choice == 1:
            self.KEY(parent=current)
        local_ctx['indexFormat'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.uid(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.indexType(parent=current)
        self.indexColumnNames(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=inf):
                self.indexOption(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByAddIndex.min_depth = 4

    @depthcontrol
    def alterSpecification_alterByAddPrimaryKey(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterSpecification_alterByAddPrimaryKey', parent=parent)
        self.enter_rule(current)
        self.ADD(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.CONSTRAINT(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.uid(parent=current)
                        local_ctx['name'] = current.last_child
        self.PRIMARY(parent=current)
        self.KEY(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.uid(parent=current)
                local_ctx['index'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.indexType(parent=current)
        self.indexColumnNames(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 4, min=0, max=inf):
                self.indexOption(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByAddPrimaryKey.min_depth = 4

    @depthcontrol
    def alterSpecification_alterByAddUniqueKey(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterSpecification_alterByAddUniqueKey', parent=parent)
        self.enter_rule(current)
        self.ADD(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.CONSTRAINT(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.uid(parent=current)
                        local_ctx['name'] = current.last_child
        self.UNIQUE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.INDEX(parent=current)
                elif choice == 1:
                    self.KEY(parent=current)
                local_ctx['indexFormat'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.uid(parent=current)
                local_ctx['indexName'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.indexType(parent=current)
        self.indexColumnNames(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 5, min=0, max=inf):
                self.indexOption(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByAddUniqueKey.min_depth = 4

    @depthcontrol
    def alterSpecification_alterByAddSpecialIndex(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterSpecification_alterByAddSpecialIndex', parent=parent)
        self.enter_rule(current)
        self.ADD(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.FULLTEXT(parent=current)
        elif choice == 1:
            self.SPATIAL(parent=current)
        local_ctx['keyType'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.INDEX(parent=current)
                elif choice == 1:
                    self.KEY(parent=current)
                local_ctx['indexFormat'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.uid(parent=current)
        self.indexColumnNames(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=inf):
                self.indexOption(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByAddSpecialIndex.min_depth = 4

    @depthcontrol
    def alterSpecification_alterByAddForeignKey(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterSpecification_alterByAddForeignKey', parent=parent)
        self.enter_rule(current)
        self.ADD(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.CONSTRAINT(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.uid(parent=current)
                        local_ctx['name'] = current.last_child
        self.FOREIGN(parent=current)
        self.KEY(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.uid(parent=current)
                local_ctx['indexName'] = current.last_child
        self.indexColumnNames(parent=current)
        self.referenceDefinition(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByAddForeignKey.min_depth = 5

    @depthcontrol
    def alterSpecification_alterByAddCheckTableConstraint(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterSpecification_alterByAddCheckTableConstraint', parent=parent)
        self.enter_rule(current)
        self.ADD(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.CONSTRAINT(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.uid(parent=current)
                        local_ctx['name'] = current.last_child
        self.CHECK(parent=current)
        UnlexerRule(src='(', parent=current)
        self.expression(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByAddCheckTableConstraint.min_depth = 8

    @depthcontrol
    def alterSpecification_alterBySetAlgorithm(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterSpecification_alterBySetAlgorithm', parent=parent)
        self.enter_rule(current)
        self.ALGORITHM(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.DEFAULT(parent=current)
        elif choice == 1:
            self.INPLACE(parent=current)
        elif choice == 2:
            self.COPY(parent=current)
        local_ctx['algType'] = current.last_child
        self.exit_rule(current)
        return current
    alterSpecification_alterBySetAlgorithm.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByChangeDefault(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByChangeDefault', parent=parent)
        self.enter_rule(current)
        self.ALTER(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.COLUMN(parent=current)
        self.uid(parent=current)
        choice = self.model.choice(current, 0, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.SET(parent=current)
            self.DEFAULT(parent=current)
            self.defaultValue(parent=current)
        elif choice == 1:
            self.DROP(parent=current)
            self.DEFAULT(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByChangeDefault.min_depth = 2

    @depthcontrol
    def alterSpecification_alterByChangeColumn(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterSpecification_alterByChangeColumn', parent=parent)
        self.enter_rule(current)
        self.CHANGE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.COLUMN(parent=current)
        self.uid(parent=current)
        local_ctx['oldColumn'] = current.last_child
        self.uid(parent=current)
        local_ctx['newColumn'] = current.last_child
        self.columnDefinition(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.FIRST(parent=current)
                elif choice == 1:
                    self.AFTER(parent=current)
                    self.uid(parent=current)
                    local_ctx['afterColumn'] = current.last_child
        self.exit_rule(current)
        return current
    alterSpecification_alterByChangeColumn.min_depth = 4

    @depthcontrol
    def alterSpecification_alterByRenameColumn(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterSpecification_alterByRenameColumn', parent=parent)
        self.enter_rule(current)
        self.RENAME(parent=current)
        self.COLUMN(parent=current)
        self.uid(parent=current)
        local_ctx['oldColumn'] = current.last_child
        self.TO(parent=current)
        self.uid(parent=current)
        local_ctx['newColumn'] = current.last_child
        self.exit_rule(current)
        return current
    alterSpecification_alterByRenameColumn.min_depth = 2

    @depthcontrol
    def alterSpecification_alterByLock(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterSpecification_alterByLock', parent=parent)
        self.enter_rule(current)
        self.LOCK(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.DEFAULT(parent=current)
        elif choice == 1:
            self.NONE(parent=current)
        elif choice == 2:
            self.SHARED(parent=current)
        elif choice == 3:
            self.EXCLUSIVE(parent=current)
        local_ctx['lockType'] = current.last_child
        self.exit_rule(current)
        return current
    alterSpecification_alterByLock.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByModifyColumn(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByModifyColumn', parent=parent)
        self.enter_rule(current)
        self.MODIFY(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.COLUMN(parent=current)
        self.uid(parent=current)
        self.columnDefinition(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.FIRST(parent=current)
                elif choice == 1:
                    self.AFTER(parent=current)
                    self.uid(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByModifyColumn.min_depth = 4

    @depthcontrol
    def alterSpecification_alterByDropColumn(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByDropColumn', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.COLUMN(parent=current)
        self.uid(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.RESTRICT(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByDropColumn.min_depth = 2

    @depthcontrol
    def alterSpecification_alterByDropConstraintCheck(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByDropConstraintCheck', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.CONSTRAINT(parent=current)
        elif choice == 1:
            self.CHECK(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByDropConstraintCheck.min_depth = 2

    @depthcontrol
    def alterSpecification_alterByDropPrimaryKey(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByDropPrimaryKey', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        self.PRIMARY(parent=current)
        self.KEY(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByDropPrimaryKey.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByRenameIndex(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterSpecification_alterByRenameIndex', parent=parent)
        self.enter_rule(current)
        self.RENAME(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.INDEX(parent=current)
        elif choice == 1:
            self.KEY(parent=current)
        local_ctx['indexFormat'] = current.last_child
        self.uid(parent=current)
        self.TO(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByRenameIndex.min_depth = 2

    @depthcontrol
    def alterSpecification_alterByAlterIndexVisibility(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByAlterIndexVisibility', parent=parent)
        self.enter_rule(current)
        self.ALTER(parent=current)
        self.INDEX(parent=current)
        self.uid(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.VISIBLE(parent=current)
        elif choice == 1:
            self.INVISIBLE(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByAlterIndexVisibility.min_depth = 2

    @depthcontrol
    def alterSpecification_alterByDropIndex(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterSpecification_alterByDropIndex', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.INDEX(parent=current)
        elif choice == 1:
            self.KEY(parent=current)
        local_ctx['indexFormat'] = current.last_child
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByDropIndex.min_depth = 2

    @depthcontrol
    def alterSpecification_alterByDropForeignKey(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByDropForeignKey', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        self.FOREIGN(parent=current)
        self.KEY(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByDropForeignKey.min_depth = 2

    @depthcontrol
    def alterSpecification_alterByDisableKeys(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByDisableKeys', parent=parent)
        self.enter_rule(current)
        self.DISABLE(parent=current)
        self.KEYS(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByDisableKeys.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByEnableKeys(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByEnableKeys', parent=parent)
        self.enter_rule(current)
        self.ENABLE(parent=current)
        self.KEYS(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByEnableKeys.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByRename(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterSpecification_alterByRename', parent=parent)
        self.enter_rule(current)
        self.RENAME(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.TO(parent=current)
                elif choice == 1:
                    self.AS(parent=current)
                local_ctx['renameFormat'] = current.last_child
        choice = self.model.choice(current, 1, [0 if [2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.uid(parent=current)
        elif choice == 1:
            self.fullId(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByRename.min_depth = 2

    @depthcontrol
    def alterSpecification_alterByOrder(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByOrder', parent=parent)
        self.enter_rule(current)
        self.ORDER(parent=current)
        self.BY(parent=current)
        self.uidList(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByOrder.min_depth = 3

    @depthcontrol
    def alterSpecification_alterByConvertCharset(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByConvertCharset', parent=parent)
        self.enter_rule(current)
        self.CONVERT(parent=current)
        self.TO(parent=current)
        self.CHARACTER(parent=current)
        self.SET(parent=current)
        self.charsetName(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.COLLATE(parent=current)
                self.collationName(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByConvertCharset.min_depth = 2

    @depthcontrol
    def alterSpecification_alterByDefaultCharset(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByDefaultCharset', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.DEFAULT(parent=current)
        self.CHARACTER(parent=current)
        self.SET(parent=current)
        UnlexerRule(src='=', parent=current)
        self.charsetName(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.COLLATE(parent=current)
                UnlexerRule(src='=', parent=current)
                self.collationName(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByDefaultCharset.min_depth = 2

    @depthcontrol
    def alterSpecification_alterByDiscardTablespace(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByDiscardTablespace', parent=parent)
        self.enter_rule(current)
        self.DISCARD(parent=current)
        self.TABLESPACE(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByDiscardTablespace.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByImportTablespace(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByImportTablespace', parent=parent)
        self.enter_rule(current)
        self.IMPORT(parent=current)
        self.TABLESPACE(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByImportTablespace.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByForce(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByForce', parent=parent)
        self.enter_rule(current)
        self.FORCE(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByForce.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByValidate(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterSpecification_alterByValidate', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.WITHOUT(parent=current)
        elif choice == 1:
            self.WITH(parent=current)
        local_ctx['validationFormat'] = current.last_child
        self.VALIDATION(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByValidate.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByAddPartition(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByAddPartition', parent=parent)
        self.enter_rule(current)
        self.ADD(parent=current)
        self.PARTITION(parent=current)
        UnlexerRule(src='(', parent=current)
        self.partitionDefinition(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.partitionDefinition(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByAddPartition.min_depth = 4

    @depthcontrol
    def alterSpecification_alterByDropPartition(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByDropPartition', parent=parent)
        self.enter_rule(current)
        self.DROP(parent=current)
        self.PARTITION(parent=current)
        self.uidList(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByDropPartition.min_depth = 3

    @depthcontrol
    def alterSpecification_alterByDiscardPartition(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByDiscardPartition', parent=parent)
        self.enter_rule(current)
        self.DISCARD(parent=current)
        self.PARTITION(parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.uidList(parent=current)
        elif choice == 1:
            self.ALL(parent=current)
        self.TABLESPACE(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByDiscardPartition.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByImportPartition(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByImportPartition', parent=parent)
        self.enter_rule(current)
        self.IMPORT(parent=current)
        self.PARTITION(parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.uidList(parent=current)
        elif choice == 1:
            self.ALL(parent=current)
        self.TABLESPACE(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByImportPartition.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByTruncatePartition(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByTruncatePartition', parent=parent)
        self.enter_rule(current)
        self.TRUNCATE(parent=current)
        self.PARTITION(parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.uidList(parent=current)
        elif choice == 1:
            self.ALL(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByTruncatePartition.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByCoalescePartition(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByCoalescePartition', parent=parent)
        self.enter_rule(current)
        self.COALESCE(parent=current)
        self.PARTITION(parent=current)
        self.decimalLiteral(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByCoalescePartition.min_depth = 2

    @depthcontrol
    def alterSpecification_alterByReorganizePartition(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByReorganizePartition', parent=parent)
        self.enter_rule(current)
        self.REORGANIZE(parent=current)
        self.PARTITION(parent=current)
        self.uidList(parent=current)
        self.INTO(parent=current)
        UnlexerRule(src='(', parent=current)
        self.partitionDefinition(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.partitionDefinition(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByReorganizePartition.min_depth = 4

    @depthcontrol
    def alterSpecification_alterByExchangePartition(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterSpecification_alterByExchangePartition', parent=parent)
        self.enter_rule(current)
        self.EXCHANGE(parent=current)
        self.PARTITION(parent=current)
        self.uid(parent=current)
        self.WITH(parent=current)
        self.TABLE(parent=current)
        self.tableName(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.WITH(parent=current)
                elif choice == 1:
                    self.WITHOUT(parent=current)
                local_ctx['validationFormat'] = current.last_child
                self.VALIDATION(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByExchangePartition.min_depth = 4

    @depthcontrol
    def alterSpecification_alterByAnalyzePartition(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByAnalyzePartition', parent=parent)
        self.enter_rule(current)
        self.ANALYZE(parent=current)
        self.PARTITION(parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.uidList(parent=current)
        elif choice == 1:
            self.ALL(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByAnalyzePartition.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByCheckPartition(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByCheckPartition', parent=parent)
        self.enter_rule(current)
        self.CHECK(parent=current)
        self.PARTITION(parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.uidList(parent=current)
        elif choice == 1:
            self.ALL(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByCheckPartition.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByOptimizePartition(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByOptimizePartition', parent=parent)
        self.enter_rule(current)
        self.OPTIMIZE(parent=current)
        self.PARTITION(parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.uidList(parent=current)
        elif choice == 1:
            self.ALL(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByOptimizePartition.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByRebuildPartition(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByRebuildPartition', parent=parent)
        self.enter_rule(current)
        self.REBUILD(parent=current)
        self.PARTITION(parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.uidList(parent=current)
        elif choice == 1:
            self.ALL(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByRebuildPartition.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByRepairPartition(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByRepairPartition', parent=parent)
        self.enter_rule(current)
        self.REPAIR(parent=current)
        self.PARTITION(parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.uidList(parent=current)
        elif choice == 1:
            self.ALL(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByRepairPartition.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByRemovePartitioning(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByRemovePartitioning', parent=parent)
        self.enter_rule(current)
        self.REMOVE(parent=current)
        self.PARTITIONING(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByRemovePartitioning.min_depth = 1

    @depthcontrol
    def alterSpecification_alterByUpgradePartitioning(self, parent=None):
        current = UnparserRule(name='alterSpecification_alterByUpgradePartitioning', parent=parent)
        self.enter_rule(current)
        self.UPGRADE(parent=current)
        self.PARTITIONING(parent=current)
        self.exit_rule(current)
        return current
    alterSpecification_alterByUpgradePartitioning.min_depth = 1

    @depthcontrol
    def selectStatement_simpleSelect(self, parent=None):
        current = UnparserRule(name='selectStatement_simpleSelect', parent=parent)
        self.enter_rule(current)
        self.querySpecification(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.lockClause(parent=current)
        self.exit_rule(current)
        return current
    selectStatement_simpleSelect.min_depth = 2

    @depthcontrol
    def selectStatement_parenthesisSelect(self, parent=None):
        current = UnparserRule(name='selectStatement_parenthesisSelect', parent=parent)
        self.enter_rule(current)
        self.queryExpression(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.lockClause(parent=current)
        self.exit_rule(current)
        return current
    selectStatement_parenthesisSelect.min_depth = 3

    @depthcontrol
    def selectStatement_unionSelect(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='selectStatement_unionSelect', parent=parent)
        self.enter_rule(current)
        self.querySpecificationNointo(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.unionStatement(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.UNION(parent=current)
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                        if choice == 0:
                            self.ALL(parent=current)
                        elif choice == 1:
                            self.DISTINCT(parent=current)
                        local_ctx['unionType'] = current.last_child
                choice = self.model.choice(current, 1, [0 if [2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.querySpecification(parent=current)
                elif choice == 1:
                    self.queryExpression(parent=current)
        if self.max_depth >= 10:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.orderByClause(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.limitClause(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 5, min=0, max=1):
                self.lockClause(parent=current)
        self.exit_rule(current)
        return current
    selectStatement_unionSelect.min_depth = 3

    @depthcontrol
    def selectStatement_unionParenthesisSelect(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='selectStatement_unionParenthesisSelect', parent=parent)
        self.enter_rule(current)
        self.queryExpressionNointo(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.unionParenthesis(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.UNION(parent=current)
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                        if choice == 0:
                            self.ALL(parent=current)
                        elif choice == 1:
                            self.DISTINCT(parent=current)
                        local_ctx['unionType'] = current.last_child
                self.queryExpression(parent=current)
        if self.max_depth >= 10:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.orderByClause(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.limitClause(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 5, min=0, max=1):
                self.lockClause(parent=current)
        self.exit_rule(current)
        return current
    selectStatement_unionParenthesisSelect.min_depth = 4

    @depthcontrol
    def tableSource_tableSourceBase(self, parent=None):
        current = UnparserRule(name='tableSource_tableSourceBase', parent=parent)
        self.enter_rule(current)
        self.tableSourceItem(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.joinPart(parent=current)
        self.exit_rule(current)
        return current
    tableSource_tableSourceBase.min_depth = 6

    @depthcontrol
    def tableSource_tableSourceNested(self, parent=None):
        current = UnparserRule(name='tableSource_tableSourceNested', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.tableSourceItem(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.joinPart(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    tableSource_tableSourceNested.min_depth = 6

    @depthcontrol
    def tableSourceItem_atomTableItem(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='tableSourceItem_atomTableItem', parent=parent)
        self.enter_rule(current)
        self.tableName(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.PARTITION(parent=current)
                UnlexerRule(src='(', parent=current)
                self.uidList(parent=current)
                UnlexerRule(src=')', parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        self.AS(parent=current)
                self.uid(parent=current)
                local_ctx['alias'] = current.last_child
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.indexHint(parent=current)
                if self.max_depth >= 4:
                    for _ in self.model.quantify(current, 4, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.indexHint(parent=current)
        self.exit_rule(current)
        return current
    tableSourceItem_atomTableItem.min_depth = 4

    @depthcontrol
    def tableSourceItem_subqueryTableItem(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='tableSourceItem_subqueryTableItem', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.selectStatement(parent=current)
        elif choice == 1:
            UnlexerRule(src='(', parent=current)
            self.selectStatement(parent=current)
            local_ctx['parenthesisSubquery'] = current.last_child
            UnlexerRule(src=')', parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.AS(parent=current)
        self.uid(parent=current)
        local_ctx['alias'] = current.last_child
        self.exit_rule(current)
        return current
    tableSourceItem_subqueryTableItem.min_depth = 4

    @depthcontrol
    def tableSourceItem_tableSourcesItem(self, parent=None):
        current = UnparserRule(name='tableSourceItem_tableSourcesItem', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.tableSources(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    tableSourceItem_tableSourcesItem.min_depth = 9

    @depthcontrol
    def joinPart_innerJoin(self, parent=None):
        current = UnparserRule(name='joinPart_innerJoin', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.INNER(parent=current)
                elif choice == 1:
                    self.CROSS(parent=current)
        self.JOIN(parent=current)
        self.tableSourceItem(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                choice = self.model.choice(current, 1, [0 if [8, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.ON(parent=current)
                    self.expression(parent=current)
                elif choice == 1:
                    self.USING(parent=current)
                    UnlexerRule(src='(', parent=current)
                    self.uidList(parent=current)
                    UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    joinPart_innerJoin.min_depth = 6

    @depthcontrol
    def joinPart_straightJoin(self, parent=None):
        current = UnparserRule(name='joinPart_straightJoin', parent=parent)
        self.enter_rule(current)
        self.STRAIGHT_JOIN(parent=current)
        self.tableSourceItem(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ON(parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    joinPart_straightJoin.min_depth = 6

    @depthcontrol
    def joinPart_outerJoin(self, parent=None):
        current = UnparserRule(name='joinPart_outerJoin', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.LEFT(parent=current)
        elif choice == 1:
            self.RIGHT(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.OUTER(parent=current)
        self.JOIN(parent=current)
        self.tableSourceItem(parent=current)
        choice = self.model.choice(current, 1, [0 if [8, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.ON(parent=current)
            self.expression(parent=current)
        elif choice == 1:
            self.USING(parent=current)
            UnlexerRule(src='(', parent=current)
            self.uidList(parent=current)
            UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    joinPart_outerJoin.min_depth = 6

    @depthcontrol
    def joinPart_naturalJoin(self, parent=None):
        current = UnparserRule(name='joinPart_naturalJoin', parent=parent)
        self.enter_rule(current)
        self.NATURAL(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.LEFT(parent=current)
                elif choice == 1:
                    self.RIGHT(parent=current)
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.OUTER(parent=current)
        self.JOIN(parent=current)
        self.tableSourceItem(parent=current)
        self.exit_rule(current)
        return current
    joinPart_naturalJoin.min_depth = 6

    @depthcontrol
    def selectElement_selectStarElement(self, parent=None):
        current = UnparserRule(name='selectElement_selectStarElement', parent=parent)
        self.enter_rule(current)
        self.fullId(parent=current)
        UnlexerRule(src='.', parent=current)
        UnlexerRule(src='*', parent=current)
        self.exit_rule(current)
        return current
    selectElement_selectStarElement.min_depth = 3

    @depthcontrol
    def selectElement_selectColumnElement(self, parent=None):
        current = UnparserRule(name='selectElement_selectColumnElement', parent=parent)
        self.enter_rule(current)
        self.fullColumnName(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.AS(parent=current)
                self.uid(parent=current)
        self.exit_rule(current)
        return current
    selectElement_selectColumnElement.min_depth = 3

    @depthcontrol
    def selectElement_selectFunctionElement(self, parent=None):
        current = UnparserRule(name='selectElement_selectFunctionElement', parent=parent)
        self.enter_rule(current)
        self.functionCall(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.AS(parent=current)
                self.uid(parent=current)
        self.exit_rule(current)
        return current
    selectElement_selectFunctionElement.min_depth = 4

    @depthcontrol
    def selectElement_selectExpressionElement(self, parent=None):
        current = UnparserRule(name='selectElement_selectExpressionElement', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.LOCAL_ID(parent=current)
                self.VAR_ASSIGN(parent=current)
        self.expression(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        self.AS(parent=current)
                self.uid(parent=current)
        self.exit_rule(current)
        return current
    selectElement_selectExpressionElement.min_depth = 8

    @depthcontrol
    def selectIntoExpression_selectIntoVariables(self, parent=None):
        current = UnparserRule(name='selectIntoExpression_selectIntoVariables', parent=parent)
        self.enter_rule(current)
        self.INTO(parent=current)
        self.assignmentField(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.assignmentField(parent=current)
        self.exit_rule(current)
        return current
    selectIntoExpression_selectIntoVariables.min_depth = 2

    @depthcontrol
    def selectIntoExpression_selectIntoDumpFile(self, parent=None):
        current = UnparserRule(name='selectIntoExpression_selectIntoDumpFile', parent=parent)
        self.enter_rule(current)
        self.INTO(parent=current)
        self.DUMPFILE(parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    selectIntoExpression_selectIntoDumpFile.min_depth = 2

    @depthcontrol
    def selectIntoExpression_selectIntoTextFile(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='selectIntoExpression_selectIntoTextFile', parent=parent)
        self.enter_rule(current)
        self.INTO(parent=current)
        self.OUTFILE(parent=current)
        self.STRING_LITERAL(parent=current)
        local_ctx['filename'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.CHARACTER(parent=current)
                self.SET(parent=current)
                self.charsetName(parent=current)
                local_ctx['charset'] = current.last_child
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.FIELDS(parent=current)
                elif choice == 1:
                    self.COLUMNS(parent=current)
                local_ctx['fieldsFormat'] = current.last_child
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 2, min=1, max=inf):
                        self.selectFieldsInto(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.LINES(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 4, min=1, max=inf):
                        self.selectLinesInto(parent=current)
        self.exit_rule(current)
        return current
    selectIntoExpression_selectIntoTextFile.min_depth = 2

    @depthcontrol
    def masterOption_masterStringOption(self, parent=None):
        current = UnparserRule(name='masterOption_masterStringOption', parent=parent)
        self.enter_rule(current)
        self.stringMasterOption(parent=current)
        UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    masterOption_masterStringOption.min_depth = 2

    @depthcontrol
    def masterOption_masterDecimalOption(self, parent=None):
        current = UnparserRule(name='masterOption_masterDecimalOption', parent=parent)
        self.enter_rule(current)
        self.decimalMasterOption(parent=current)
        UnlexerRule(src='=', parent=current)
        self.decimalLiteral(parent=current)
        self.exit_rule(current)
        return current
    masterOption_masterDecimalOption.min_depth = 2

    @depthcontrol
    def masterOption_masterBoolOption(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='masterOption_masterBoolOption', parent=parent)
        self.enter_rule(current)
        self.boolMasterOption(parent=current)
        UnlexerRule(src='=', parent=current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='0', parent=current)
        elif choice == 1:
            UnlexerRule(src='1', parent=current)
        local_ctx['boolVal'] = current.last_child
        self.exit_rule(current)
        return current
    masterOption_masterBoolOption.min_depth = 2

    @depthcontrol
    def masterOption_masterRealOption(self, parent=None):
        current = UnparserRule(name='masterOption_masterRealOption', parent=parent)
        self.enter_rule(current)
        self.MASTER_HEARTBEAT_PERIOD(parent=current)
        UnlexerRule(src='=', parent=current)
        self.REAL_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    masterOption_masterRealOption.min_depth = 2

    @depthcontrol
    def masterOption_masterUidListOption(self, parent=None):
        current = UnparserRule(name='masterOption_masterUidListOption', parent=parent)
        self.enter_rule(current)
        self.IGNORE_SERVER_IDS(parent=current)
        UnlexerRule(src='=', parent=current)
        UnlexerRule(src='(', parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.uid(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.uid(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    masterOption_masterUidListOption.min_depth = 1

    @depthcontrol
    def replicationFilter_doDbReplication(self, parent=None):
        current = UnparserRule(name='replicationFilter_doDbReplication', parent=parent)
        self.enter_rule(current)
        self.REPLICATE_DO_DB(parent=current)
        UnlexerRule(src='=', parent=current)
        UnlexerRule(src='(', parent=current)
        self.uidList(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    replicationFilter_doDbReplication.min_depth = 3

    @depthcontrol
    def replicationFilter_ignoreDbReplication(self, parent=None):
        current = UnparserRule(name='replicationFilter_ignoreDbReplication', parent=parent)
        self.enter_rule(current)
        self.REPLICATE_IGNORE_DB(parent=current)
        UnlexerRule(src='=', parent=current)
        UnlexerRule(src='(', parent=current)
        self.uidList(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    replicationFilter_ignoreDbReplication.min_depth = 3

    @depthcontrol
    def replicationFilter_doTableReplication(self, parent=None):
        current = UnparserRule(name='replicationFilter_doTableReplication', parent=parent)
        self.enter_rule(current)
        self.REPLICATE_DO_TABLE(parent=current)
        UnlexerRule(src='=', parent=current)
        UnlexerRule(src='(', parent=current)
        self.tables(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    replicationFilter_doTableReplication.min_depth = 5

    @depthcontrol
    def replicationFilter_ignoreTableReplication(self, parent=None):
        current = UnparserRule(name='replicationFilter_ignoreTableReplication', parent=parent)
        self.enter_rule(current)
        self.REPLICATE_IGNORE_TABLE(parent=current)
        UnlexerRule(src='=', parent=current)
        UnlexerRule(src='(', parent=current)
        self.tables(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    replicationFilter_ignoreTableReplication.min_depth = 5

    @depthcontrol
    def replicationFilter_wildDoTableReplication(self, parent=None):
        current = UnparserRule(name='replicationFilter_wildDoTableReplication', parent=parent)
        self.enter_rule(current)
        self.REPLICATE_WILD_DO_TABLE(parent=current)
        UnlexerRule(src='=', parent=current)
        UnlexerRule(src='(', parent=current)
        self.simpleStrings(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    replicationFilter_wildDoTableReplication.min_depth = 3

    @depthcontrol
    def replicationFilter_wildIgnoreTableReplication(self, parent=None):
        current = UnparserRule(name='replicationFilter_wildIgnoreTableReplication', parent=parent)
        self.enter_rule(current)
        self.REPLICATE_WILD_IGNORE_TABLE(parent=current)
        UnlexerRule(src='=', parent=current)
        UnlexerRule(src='(', parent=current)
        self.simpleStrings(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    replicationFilter_wildIgnoreTableReplication.min_depth = 3

    @depthcontrol
    def replicationFilter_rewriteDbReplication(self, parent=None):
        current = UnparserRule(name='replicationFilter_rewriteDbReplication', parent=parent)
        self.enter_rule(current)
        self.REPLICATE_REWRITE_DB(parent=current)
        UnlexerRule(src='=', parent=current)
        UnlexerRule(src='(', parent=current)
        self.tablePair(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.tablePair(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    replicationFilter_rewriteDbReplication.min_depth = 5

    @depthcontrol
    def untilOption_gtidsUntilOption(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='untilOption_gtidsUntilOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.SQL_BEFORE_GTIDS(parent=current)
        elif choice == 1:
            self.SQL_AFTER_GTIDS(parent=current)
        local_ctx['gtids'] = current.last_child
        UnlexerRule(src='=', parent=current)
        self.gtuidSet(parent=current)
        self.exit_rule(current)
        return current
    untilOption_gtidsUntilOption.min_depth = 3

    @depthcontrol
    def untilOption_masterLogUntilOption(self, parent=None):
        current = UnparserRule(name='untilOption_masterLogUntilOption', parent=parent)
        self.enter_rule(current)
        self.MASTER_LOG_FILE(parent=current)
        UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        UnlexerRule(src=',', parent=current)
        self.MASTER_LOG_POS(parent=current)
        UnlexerRule(src='=', parent=current)
        self.decimalLiteral(parent=current)
        self.exit_rule(current)
        return current
    untilOption_masterLogUntilOption.min_depth = 2

    @depthcontrol
    def untilOption_relayLogUntilOption(self, parent=None):
        current = UnparserRule(name='untilOption_relayLogUntilOption', parent=parent)
        self.enter_rule(current)
        self.RELAY_LOG_FILE(parent=current)
        UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        UnlexerRule(src=',', parent=current)
        self.RELAY_LOG_POS(parent=current)
        UnlexerRule(src='=', parent=current)
        self.decimalLiteral(parent=current)
        self.exit_rule(current)
        return current
    untilOption_relayLogUntilOption.min_depth = 2

    @depthcontrol
    def untilOption_sqlGapsUntilOption(self, parent=None):
        current = UnparserRule(name='untilOption_sqlGapsUntilOption', parent=parent)
        self.enter_rule(current)
        self.SQL_AFTER_MTS_GAPS(parent=current)
        self.exit_rule(current)
        return current
    untilOption_sqlGapsUntilOption.min_depth = 1

    @depthcontrol
    def connectionOption_userConnectionOption(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='connectionOption_userConnectionOption', parent=parent)
        self.enter_rule(current)
        self.USER(parent=current)
        UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        local_ctx['conOptUser'] = current.last_child
        self.exit_rule(current)
        return current
    connectionOption_userConnectionOption.min_depth = 2

    @depthcontrol
    def connectionOption_passwordConnectionOption(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='connectionOption_passwordConnectionOption', parent=parent)
        self.enter_rule(current)
        self.PASSWORD(parent=current)
        UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        local_ctx['conOptPassword'] = current.last_child
        self.exit_rule(current)
        return current
    connectionOption_passwordConnectionOption.min_depth = 2

    @depthcontrol
    def connectionOption_defaultAuthConnectionOption(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='connectionOption_defaultAuthConnectionOption', parent=parent)
        self.enter_rule(current)
        self.DEFAULT_AUTH(parent=current)
        UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        local_ctx['conOptDefAuth'] = current.last_child
        self.exit_rule(current)
        return current
    connectionOption_defaultAuthConnectionOption.min_depth = 2

    @depthcontrol
    def connectionOption_pluginDirConnectionOption(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='connectionOption_pluginDirConnectionOption', parent=parent)
        self.enter_rule(current)
        self.PLUGIN_DIR(parent=current)
        UnlexerRule(src='=', parent=current)
        self.STRING_LITERAL(parent=current)
        local_ctx['conOptPluginDir'] = current.last_child
        self.exit_rule(current)
        return current
    connectionOption_pluginDirConnectionOption.min_depth = 2

    @depthcontrol
    def cursorStatement_CloseCursor(self, parent=None):
        current = UnparserRule(name='cursorStatement_CloseCursor', parent=parent)
        self.enter_rule(current)
        self.CLOSE(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    cursorStatement_CloseCursor.min_depth = 2

    @depthcontrol
    def cursorStatement_FetchCursor(self, parent=None):
        current = UnparserRule(name='cursorStatement_FetchCursor', parent=parent)
        self.enter_rule(current)
        self.FETCH(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.NEXT(parent=current)
                self.FROM(parent=current)
        self.uid(parent=current)
        self.INTO(parent=current)
        self.uidList(parent=current)
        self.exit_rule(current)
        return current
    cursorStatement_FetchCursor.min_depth = 3

    @depthcontrol
    def cursorStatement_OpenCursor(self, parent=None):
        current = UnparserRule(name='cursorStatement_OpenCursor', parent=parent)
        self.enter_rule(current)
        self.OPEN(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    cursorStatement_OpenCursor.min_depth = 2

    @depthcontrol
    def handlerConditionValue_handlerConditionCode(self, parent=None):
        current = UnparserRule(name='handlerConditionValue_handlerConditionCode', parent=parent)
        self.enter_rule(current)
        self.decimalLiteral(parent=current)
        self.exit_rule(current)
        return current
    handlerConditionValue_handlerConditionCode.min_depth = 2

    @depthcontrol
    def handlerConditionValue_handlerConditionState(self, parent=None):
        current = UnparserRule(name='handlerConditionValue_handlerConditionState', parent=parent)
        self.enter_rule(current)
        self.SQLSTATE(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.VALUE(parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    handlerConditionValue_handlerConditionState.min_depth = 2

    @depthcontrol
    def handlerConditionValue_handlerConditionName(self, parent=None):
        current = UnparserRule(name='handlerConditionValue_handlerConditionName', parent=parent)
        self.enter_rule(current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    handlerConditionValue_handlerConditionName.min_depth = 2

    @depthcontrol
    def handlerConditionValue_handlerConditionWarning(self, parent=None):
        current = UnparserRule(name='handlerConditionValue_handlerConditionWarning', parent=parent)
        self.enter_rule(current)
        self.SQLWARNING(parent=current)
        self.exit_rule(current)
        return current
    handlerConditionValue_handlerConditionWarning.min_depth = 1

    @depthcontrol
    def handlerConditionValue_handlerConditionNotfound(self, parent=None):
        current = UnparserRule(name='handlerConditionValue_handlerConditionNotfound', parent=parent)
        self.enter_rule(current)
        self.NOT(parent=current)
        self.FOUND(parent=current)
        self.exit_rule(current)
        return current
    handlerConditionValue_handlerConditionNotfound.min_depth = 1

    @depthcontrol
    def handlerConditionValue_handlerConditionException(self, parent=None):
        current = UnparserRule(name='handlerConditionValue_handlerConditionException', parent=parent)
        self.enter_rule(current)
        self.SQLEXCEPTION(parent=current)
        self.exit_rule(current)
        return current
    handlerConditionValue_handlerConditionException.min_depth = 1

    @depthcontrol
    def alterUser_alterUserMysqlV56(self, parent=None):
        current = UnparserRule(name='alterUser_alterUserMysqlV56', parent=parent)
        self.enter_rule(current)
        self.ALTER(parent=current)
        self.USER(parent=current)
        self.userSpecification(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.userSpecification(parent=current)
        self.exit_rule(current)
        return current
    alterUser_alterUserMysqlV56.min_depth = 4

    @depthcontrol
    def alterUser_alterUserMysqlV57(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='alterUser_alterUserMysqlV57', parent=parent)
        self.enter_rule(current)
        self.ALTER(parent=current)
        self.USER(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ifExists(parent=current)
        self.userAuthOption(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.userAuthOption(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.REQUIRE(parent=current)
                choice = self.model.choice(current, 0, [0 if [1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.NONE(parent=current)
                    local_ctx['tlsNone'] = current.last_child
                elif choice == 1:
                    self.tlsOption(parent=current)
                    if self.max_depth >= 2:
                        for _ in self.model.quantify(current, 3, min=0, max=inf):
                            if self.max_depth >= 1:
                                for _ in self.model.quantify(current, 4, min=0, max=1):
                                    self.AND(parent=current)
                            self.tlsOption(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 5, min=0, max=1):
                self.WITH(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 6, min=1, max=inf):
                        self.userResourceOption(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 7, min=0, max=inf):
                choice = self.model.choice(current, 1, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.userPasswordOption(parent=current)
                elif choice == 1:
                    self.userLockOption(parent=current)
        self.exit_rule(current)
        return current
    alterUser_alterUserMysqlV57.min_depth = 5

    @depthcontrol
    def createUser_createUserMysqlV56(self, parent=None):
        current = UnparserRule(name='createUser_createUserMysqlV56', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        self.USER(parent=current)
        self.userAuthOption(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.userAuthOption(parent=current)
        self.exit_rule(current)
        return current
    createUser_createUserMysqlV56.min_depth = 5

    @depthcontrol
    def createUser_createUserMysqlV57(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='createUser_createUserMysqlV57', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        self.USER(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ifNotExists(parent=current)
        self.userAuthOption(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.userAuthOption(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.REQUIRE(parent=current)
                choice = self.model.choice(current, 0, [0 if [1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.NONE(parent=current)
                    local_ctx['tlsNone'] = current.last_child
                elif choice == 1:
                    self.tlsOption(parent=current)
                    if self.max_depth >= 2:
                        for _ in self.model.quantify(current, 3, min=0, max=inf):
                            if self.max_depth >= 1:
                                for _ in self.model.quantify(current, 4, min=0, max=1):
                                    self.AND(parent=current)
                            self.tlsOption(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 5, min=0, max=1):
                self.WITH(parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 6, min=1, max=inf):
                        self.userResourceOption(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 7, min=0, max=inf):
                choice = self.model.choice(current, 1, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.userPasswordOption(parent=current)
                elif choice == 1:
                    self.userLockOption(parent=current)
        self.exit_rule(current)
        return current
    createUser_createUserMysqlV57.min_depth = 5

    @depthcontrol
    def revokeStatement_detailRevoke(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='revokeStatement_detailRevoke', parent=parent)
        self.enter_rule(current)
        self.REVOKE(parent=current)
        self.privelegeClause(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.privelegeClause(parent=current)
        self.ON(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    self.TABLE(parent=current)
                elif choice == 1:
                    self.FUNCTION(parent=current)
                elif choice == 2:
                    self.PROCEDURE(parent=current)
                local_ctx['privilegeObject'] = current.last_child
        self.privilegeLevel(parent=current)
        self.FROM(parent=current)
        self.userName(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 2, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.userName(parent=current)
        self.exit_rule(current)
        return current
    revokeStatement_detailRevoke.min_depth = 3

    @depthcontrol
    def revokeStatement_shortRevoke(self, parent=None):
        current = UnparserRule(name='revokeStatement_shortRevoke', parent=parent)
        self.enter_rule(current)
        self.REVOKE(parent=current)
        self.ALL(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.PRIVILEGES(parent=current)
        UnlexerRule(src=',', parent=current)
        self.GRANT(parent=current)
        self.OPTION(parent=current)
        self.FROM(parent=current)
        self.userName(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.userName(parent=current)
        self.exit_rule(current)
        return current
    revokeStatement_shortRevoke.min_depth = 3

    @depthcontrol
    def revokeStatement_roleRevoke(self, parent=None):
        current = UnparserRule(name='revokeStatement_roleRevoke', parent=parent)
        self.enter_rule(current)
        self.REVOKE(parent=current)
        self.uid(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.uid(parent=current)
        self.FROM(parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.userName(parent=current)
        elif choice == 1:
            self.uid(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                choice = self.model.choice(current, 1, [0 if [3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.userName(parent=current)
                elif choice == 1:
                    self.uid(parent=current)
        self.exit_rule(current)
        return current
    revokeStatement_roleRevoke.min_depth = 2

    @depthcontrol
    def userAuthOption_passwordAuthOption(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='userAuthOption_passwordAuthOption', parent=parent)
        self.enter_rule(current)
        self.userName(parent=current)
        self.IDENTIFIED(parent=current)
        self.BY(parent=current)
        self.PASSWORD(parent=current)
        self.STRING_LITERAL(parent=current)
        local_ctx['hashed'] = current.last_child
        self.exit_rule(current)
        return current
    userAuthOption_passwordAuthOption.min_depth = 3

    @depthcontrol
    def userAuthOption_stringAuthOption(self, parent=None):
        current = UnparserRule(name='userAuthOption_stringAuthOption', parent=parent)
        self.enter_rule(current)
        self.userName(parent=current)
        self.IDENTIFIED(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.WITH(parent=current)
                self.authPlugin(parent=current)
        self.BY(parent=current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    userAuthOption_stringAuthOption.min_depth = 3

    @depthcontrol
    def userAuthOption_hashAuthOption(self, parent=None):
        current = UnparserRule(name='userAuthOption_hashAuthOption', parent=parent)
        self.enter_rule(current)
        self.userName(parent=current)
        self.IDENTIFIED(parent=current)
        self.WITH(parent=current)
        self.authPlugin(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.AS(parent=current)
                self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    userAuthOption_hashAuthOption.min_depth = 3

    @depthcontrol
    def userAuthOption_simpleAuthOption(self, parent=None):
        current = UnparserRule(name='userAuthOption_simpleAuthOption', parent=parent)
        self.enter_rule(current)
        self.userName(parent=current)
        self.exit_rule(current)
        return current
    userAuthOption_simpleAuthOption.min_depth = 3

    @depthcontrol
    def privilegeLevel_currentSchemaPriviLevel(self, parent=None):
        current = UnparserRule(name='privilegeLevel_currentSchemaPriviLevel', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='*', parent=current)
        self.exit_rule(current)
        return current
    privilegeLevel_currentSchemaPriviLevel.min_depth = 0

    @depthcontrol
    def privilegeLevel_globalPrivLevel(self, parent=None):
        current = UnparserRule(name='privilegeLevel_globalPrivLevel', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='*', parent=current)
        UnlexerRule(src='.', parent=current)
        UnlexerRule(src='*', parent=current)
        self.exit_rule(current)
        return current
    privilegeLevel_globalPrivLevel.min_depth = 0

    @depthcontrol
    def privilegeLevel_definiteSchemaPrivLevel(self, parent=None):
        current = UnparserRule(name='privilegeLevel_definiteSchemaPrivLevel', parent=parent)
        self.enter_rule(current)
        self.uid(parent=current)
        UnlexerRule(src='.', parent=current)
        UnlexerRule(src='*', parent=current)
        self.exit_rule(current)
        return current
    privilegeLevel_definiteSchemaPrivLevel.min_depth = 2

    @depthcontrol
    def privilegeLevel_definiteFullTablePrivLevel(self, parent=None):
        current = UnparserRule(name='privilegeLevel_definiteFullTablePrivLevel', parent=parent)
        self.enter_rule(current)
        self.uid(parent=current)
        UnlexerRule(src='.', parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    privilegeLevel_definiteFullTablePrivLevel.min_depth = 2

    @depthcontrol
    def privilegeLevel_definiteFullTablePrivLevel2(self, parent=None):
        current = UnparserRule(name='privilegeLevel_definiteFullTablePrivLevel2', parent=parent)
        self.enter_rule(current)
        self.uid(parent=current)
        self.dottedId(parent=current)
        self.exit_rule(current)
        return current
    privilegeLevel_definiteFullTablePrivLevel2.min_depth = 3

    @depthcontrol
    def privilegeLevel_definiteTablePrivLevel(self, parent=None):
        current = UnparserRule(name='privilegeLevel_definiteTablePrivLevel', parent=parent)
        self.enter_rule(current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    privilegeLevel_definiteTablePrivLevel.min_depth = 2

    @depthcontrol
    def setStatement_setVariable(self, parent=None):
        current = UnparserRule(name='setStatement_setVariable', parent=parent)
        self.enter_rule(current)
        self.SET(parent=current)
        self.variableClause(parent=current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='=', parent=current)
        elif choice == 1:
            UnlexerRule(src=':=', parent=current)
        self.expression(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.variableClause(parent=current)
                choice = self.model.choice(current, 1, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='=', parent=current)
                elif choice == 1:
                    UnlexerRule(src=':=', parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    setStatement_setVariable.min_depth = 8

    @depthcontrol
    def setStatement_setCharset(self, parent=None):
        current = UnparserRule(name='setStatement_setCharset', parent=parent)
        self.enter_rule(current)
        self.SET(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.CHARACTER(parent=current)
            self.SET(parent=current)
        elif choice == 1:
            self.CHARSET(parent=current)
        choice = self.model.choice(current, 1, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.charsetName(parent=current)
        elif choice == 1:
            self.DEFAULT(parent=current)
        self.exit_rule(current)
        return current
    setStatement_setCharset.min_depth = 1

    @depthcontrol
    def setStatement_setNames(self, parent=None):
        current = UnparserRule(name='setStatement_setNames', parent=parent)
        self.enter_rule(current)
        self.SET(parent=current)
        self.NAMES(parent=current)
        choice = self.model.choice(current, 0, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.charsetName(parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.COLLATE(parent=current)
                    self.collationName(parent=current)
        elif choice == 1:
            self.DEFAULT(parent=current)
        self.exit_rule(current)
        return current
    setStatement_setNames.min_depth = 1

    @depthcontrol
    def setStatement_setPassword(self, parent=None):
        current = UnparserRule(name='setStatement_setPassword', parent=parent)
        self.enter_rule(current)
        self.setPasswordStatement(parent=current)
        self.exit_rule(current)
        return current
    setStatement_setPassword.min_depth = 3

    @depthcontrol
    def setStatement_setTransaction(self, parent=None):
        current = UnparserRule(name='setStatement_setTransaction', parent=parent)
        self.enter_rule(current)
        self.setTransactionStatement(parent=current)
        self.exit_rule(current)
        return current
    setStatement_setTransaction.min_depth = 3

    @depthcontrol
    def setStatement_setAutocommit(self, parent=None):
        current = UnparserRule(name='setStatement_setAutocommit', parent=parent)
        self.enter_rule(current)
        self.setAutocommitStatement(parent=current)
        self.exit_rule(current)
        return current
    setStatement_setAutocommit.min_depth = 2

    @depthcontrol
    def setStatement_setNewValueInsideTrigger(self, parent=None):
        current = UnparserRule(name='setStatement_setNewValueInsideTrigger', parent=parent)
        self.enter_rule(current)
        self.SET(parent=current)
        self.fullId(parent=current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='=', parent=current)
        elif choice == 1:
            UnlexerRule(src=':=', parent=current)
        self.expression(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.fullId(parent=current)
                choice = self.model.choice(current, 1, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='=', parent=current)
                elif choice == 1:
                    UnlexerRule(src=':=', parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    setStatement_setNewValueInsideTrigger.min_depth = 8

    @depthcontrol
    def showStatement_showMasterLogs(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='showStatement_showMasterLogs', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.BINARY(parent=current)
        elif choice == 1:
            self.MASTER(parent=current)
        local_ctx['logFormat'] = current.last_child
        self.LOGS(parent=current)
        self.exit_rule(current)
        return current
    showStatement_showMasterLogs.min_depth = 1

    @depthcontrol
    def showStatement_showLogEvents(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='showStatement_showLogEvents', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.BINLOG(parent=current)
        elif choice == 1:
            self.RELAYLOG(parent=current)
        local_ctx['logFormat'] = current.last_child
        self.EVENTS(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.IN(parent=current)
                self.STRING_LITERAL(parent=current)
                local_ctx['filename'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.FROM(parent=current)
                self.decimalLiteral(parent=current)
                local_ctx['fromPosition'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.LIMIT(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 3, min=0, max=1):
                        self.decimalLiteral(parent=current)
                        local_ctx['offset'] = current.last_child
                        UnlexerRule(src=',', parent=current)
                self.decimalLiteral(parent=current)
                local_ctx['rowCount'] = current.last_child
        self.exit_rule(current)
        return current
    showStatement_showLogEvents.min_depth = 1

    @depthcontrol
    def showStatement_showObjectFilter(self, parent=None):
        current = UnparserRule(name='showStatement_showObjectFilter', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        self.showCommonEntity(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.showFilter(parent=current)
        self.exit_rule(current)
        return current
    showStatement_showObjectFilter.min_depth = 2

    @depthcontrol
    def showStatement_showColumns(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='showStatement_showColumns', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.FULL(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.COLUMNS(parent=current)
        elif choice == 1:
            self.FIELDS(parent=current)
        local_ctx['columnsFormat'] = current.last_child
        choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.FROM(parent=current)
        elif choice == 1:
            self.IN(parent=current)
        local_ctx['tableFormat'] = current.last_child
        self.tableName(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                choice = self.model.choice(current, 2, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.FROM(parent=current)
                elif choice == 1:
                    self.IN(parent=current)
                local_ctx['schemaFormat'] = current.last_child
                self.uid(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.showFilter(parent=current)
        self.exit_rule(current)
        return current
    showStatement_showColumns.min_depth = 4

    @depthcontrol
    def showStatement_showCreateDb(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='showStatement_showCreateDb', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        self.CREATE(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.DATABASE(parent=current)
        elif choice == 1:
            self.SCHEMA(parent=current)
        local_ctx['schemaFormat'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ifNotExists(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    showStatement_showCreateDb.min_depth = 2

    @depthcontrol
    def showStatement_showCreateFullIdObject(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='showStatement_showCreateFullIdObject', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        self.CREATE(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.EVENT(parent=current)
        elif choice == 1:
            self.FUNCTION(parent=current)
        elif choice == 2:
            self.PROCEDURE(parent=current)
        elif choice == 3:
            self.TABLE(parent=current)
        elif choice == 4:
            self.TRIGGER(parent=current)
        elif choice == 5:
            self.VIEW(parent=current)
        local_ctx['namedEntity'] = current.last_child
        self.fullId(parent=current)
        self.exit_rule(current)
        return current
    showStatement_showCreateFullIdObject.min_depth = 3

    @depthcontrol
    def showStatement_showCreateUser(self, parent=None):
        current = UnparserRule(name='showStatement_showCreateUser', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        self.CREATE(parent=current)
        self.USER(parent=current)
        self.userName(parent=current)
        self.exit_rule(current)
        return current
    showStatement_showCreateUser.min_depth = 3

    @depthcontrol
    def showStatement_showEngine(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='showStatement_showEngine', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        self.ENGINE(parent=current)
        self.engineName(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.STATUS(parent=current)
        elif choice == 1:
            self.MUTEX(parent=current)
        local_ctx['engineOption'] = current.last_child
        self.exit_rule(current)
        return current
    showStatement_showEngine.min_depth = 2

    @depthcontrol
    def showStatement_showGlobalInfo(self, parent=None):
        current = UnparserRule(name='showStatement_showGlobalInfo', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        self.showGlobalInfoClause(parent=current)
        self.exit_rule(current)
        return current
    showStatement_showGlobalInfo.min_depth = 2

    @depthcontrol
    def showStatement_showErrors(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='showStatement_showErrors', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.ERRORS(parent=current)
        elif choice == 1:
            self.WARNINGS(parent=current)
        local_ctx['errorFormat'] = current.last_child
        self.LIMIT(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.decimalLiteral(parent=current)
                local_ctx['offset'] = current.last_child
                UnlexerRule(src=',', parent=current)
        self.decimalLiteral(parent=current)
        local_ctx['rowCount'] = current.last_child
        self.exit_rule(current)
        return current
    showStatement_showErrors.min_depth = 2

    @depthcontrol
    def showStatement_showCountErrors(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='showStatement_showCountErrors', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        self.COUNT(parent=current)
        UnlexerRule(src='(', parent=current)
        UnlexerRule(src='*', parent=current)
        UnlexerRule(src=')', parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.ERRORS(parent=current)
        elif choice == 1:
            self.WARNINGS(parent=current)
        local_ctx['errorFormat'] = current.last_child
        self.exit_rule(current)
        return current
    showStatement_showCountErrors.min_depth = 1

    @depthcontrol
    def showStatement_showSchemaFilter(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='showStatement_showSchemaFilter', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        self.showSchemaEntity(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.FROM(parent=current)
                elif choice == 1:
                    self.IN(parent=current)
                local_ctx['schemaFormat'] = current.last_child
                self.uid(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.showFilter(parent=current)
        self.exit_rule(current)
        return current
    showStatement_showSchemaFilter.min_depth = 2

    @depthcontrol
    def showStatement_showRoutine(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='showStatement_showRoutine', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.FUNCTION(parent=current)
        elif choice == 1:
            self.PROCEDURE(parent=current)
        local_ctx['routine'] = current.last_child
        self.CODE(parent=current)
        self.fullId(parent=current)
        self.exit_rule(current)
        return current
    showStatement_showRoutine.min_depth = 3

    @depthcontrol
    def showStatement_showGrants(self, parent=None):
        current = UnparserRule(name='showStatement_showGrants', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        self.GRANTS(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.FOR(parent=current)
                self.userName(parent=current)
        self.exit_rule(current)
        return current
    showStatement_showGrants.min_depth = 1

    @depthcontrol
    def showStatement_showIndexes(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='showStatement_showIndexes', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.INDEX(parent=current)
        elif choice == 1:
            self.INDEXES(parent=current)
        elif choice == 2:
            self.KEYS(parent=current)
        local_ctx['indexFormat'] = current.last_child
        choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.FROM(parent=current)
        elif choice == 1:
            self.IN(parent=current)
        local_ctx['tableFormat'] = current.last_child
        self.tableName(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 2, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.FROM(parent=current)
                elif choice == 1:
                    self.IN(parent=current)
                local_ctx['schemaFormat'] = current.last_child
                self.uid(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.WHERE(parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    showStatement_showIndexes.min_depth = 4

    @depthcontrol
    def showStatement_showOpenTables(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='showStatement_showOpenTables', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        self.OPEN(parent=current)
        self.TABLES(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.FROM(parent=current)
                elif choice == 1:
                    self.IN(parent=current)
                local_ctx['schemaFormat'] = current.last_child
                self.uid(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.showFilter(parent=current)
        self.exit_rule(current)
        return current
    showStatement_showOpenTables.min_depth = 1

    @depthcontrol
    def showStatement_showProfile(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='showStatement_showProfile', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        self.PROFILE(parent=current)
        self.showProfileType(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.showProfileType(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.FOR(parent=current)
                self.QUERY(parent=current)
                self.decimalLiteral(parent=current)
                local_ctx['queryCount'] = current.last_child
        self.LIMIT(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.decimalLiteral(parent=current)
                local_ctx['offset'] = current.last_child
                UnlexerRule(src=',', parent=current)
        self.decimalLiteral(parent=current)
        local_ctx['rowCount'] = current.last_child
        self.exit_rule(current)
        return current
    showStatement_showProfile.min_depth = 2

    @depthcontrol
    def showStatement_showSlaveStatus(self, parent=None):
        current = UnparserRule(name='showStatement_showSlaveStatus', parent=parent)
        self.enter_rule(current)
        self.SHOW(parent=current)
        self.SLAVE(parent=current)
        self.STATUS(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.FOR(parent=current)
                self.CHANNEL(parent=current)
                self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    showStatement_showSlaveStatus.min_depth = 1

    @depthcontrol
    def flushOption_simpleFlushOption(self, parent=None):
        current = UnparserRule(name='flushOption_simpleFlushOption', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.DES_KEY_FILE(parent=current)
        elif choice == 1:
            self.HOSTS(parent=current)
        elif choice == 2:
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    choice = self.model.choice(current, 1, [0 if [1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
                    if choice == 0:
                        self.BINARY(parent=current)
                    elif choice == 1:
                        self.ENGINE(parent=current)
                    elif choice == 2:
                        self.ERROR(parent=current)
                    elif choice == 3:
                        self.GENERAL(parent=current)
                    elif choice == 4:
                        self.RELAY(parent=current)
                    elif choice == 5:
                        self.SLOW(parent=current)
            self.LOGS(parent=current)
        elif choice == 3:
            self.OPTIMIZER_COSTS(parent=current)
        elif choice == 4:
            self.PRIVILEGES(parent=current)
        elif choice == 5:
            self.QUERY(parent=current)
            self.CACHE(parent=current)
        elif choice == 6:
            self.STATUS(parent=current)
        elif choice == 7:
            self.USER_RESOURCES(parent=current)
        elif choice == 8:
            self.TABLES(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    self.WITH(parent=current)
                    self.READ(parent=current)
                    self.LOCK(parent=current)
        self.exit_rule(current)
        return current
    flushOption_simpleFlushOption.min_depth = 1

    @depthcontrol
    def flushOption_channelFlushOption(self, parent=None):
        current = UnparserRule(name='flushOption_channelFlushOption', parent=parent)
        self.enter_rule(current)
        self.RELAY(parent=current)
        self.LOGS(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.channelOption(parent=current)
        self.exit_rule(current)
        return current
    flushOption_channelFlushOption.min_depth = 1

    @depthcontrol
    def flushOption_tableFlushOption(self, parent=None):
        current = UnparserRule(name='flushOption_tableFlushOption', parent=parent)
        self.enter_rule(current)
        self.TABLES(parent=current)
        self.tables(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.flushTableOption(parent=current)
        self.exit_rule(current)
        return current
    flushOption_tableFlushOption.min_depth = 5

    @depthcontrol
    def describeObjectClause_describeStatements(self, parent=None):
        current = UnparserRule(name='describeObjectClause_describeStatements', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 6, 5, 5, 6][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            self.selectStatement(parent=current)
        elif choice == 1:
            self.deleteStatement(parent=current)
        elif choice == 2:
            self.insertStatement(parent=current)
        elif choice == 3:
            self.replaceStatement(parent=current)
        elif choice == 4:
            self.updateStatement(parent=current)
        self.exit_rule(current)
        return current
    describeObjectClause_describeStatements.min_depth = 4

    @depthcontrol
    def describeObjectClause_describeConnection(self, parent=None):
        current = UnparserRule(name='describeObjectClause_describeConnection', parent=parent)
        self.enter_rule(current)
        self.FOR(parent=current)
        self.CONNECTION(parent=current)
        self.uid(parent=current)
        self.exit_rule(current)
        return current
    describeObjectClause_describeConnection.min_depth = 2

    @depthcontrol
    def dataType_stringDataType(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='dataType_stringDataType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.CHAR(parent=current)
        elif choice == 1:
            self.CHARACTER(parent=current)
        elif choice == 2:
            self.VARCHAR(parent=current)
        elif choice == 3:
            self.TINYTEXT(parent=current)
        elif choice == 4:
            self.TEXT(parent=current)
        elif choice == 5:
            self.MEDIUMTEXT(parent=current)
        elif choice == 6:
            self.LONGTEXT(parent=current)
        elif choice == 7:
            self.NCHAR(parent=current)
        elif choice == 8:
            self.NVARCHAR(parent=current)
        elif choice == 9:
            self.LONG(parent=current)
        local_ctx['typeName'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.VARYING(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.lengthOneDimension(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.BINARY(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.CHARACTER(parent=current)
                    self.SET(parent=current)
                elif choice == 1:
                    self.CHARSET(parent=current)
                self.charsetName(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                choice = self.model.choice(current, 2, [0 if [3, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.COLLATE(parent=current)
                    self.collationName(parent=current)
                elif choice == 1:
                    self.BINARY(parent=current)
        self.exit_rule(current)
        return current
    dataType_stringDataType.min_depth = 1

    @depthcontrol
    def dataType_nationalStringDataType(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='dataType_nationalStringDataType', parent=parent)
        self.enter_rule(current)
        self.NCHAR(parent=current)
        self.VARCHAR(parent=current)
        local_ctx['typeName'] = current.last_child
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.lengthOneDimension(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.BINARY(parent=current)
        self.exit_rule(current)
        return current
    dataType_nationalStringDataType.min_depth = 1

    @depthcontrol
    def dataType_nationalVaryingStringDataType(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='dataType_nationalVaryingStringDataType', parent=parent)
        self.enter_rule(current)
        self.NATIONAL(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.CHAR(parent=current)
        elif choice == 1:
            self.CHARACTER(parent=current)
        local_ctx['typeName'] = current.last_child
        self.VARYING(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.lengthOneDimension(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.BINARY(parent=current)
        self.exit_rule(current)
        return current
    dataType_nationalVaryingStringDataType.min_depth = 1

    @depthcontrol
    def dataType_dimensionDataType(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='dataType_dimensionDataType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.BIT(parent=current)
        elif choice == 1:
            self.TIME(parent=current)
        elif choice == 2:
            self.TIMESTAMP(parent=current)
        elif choice == 3:
            self.DATETIME(parent=current)
        elif choice == 4:
            self.BINARY(parent=current)
        elif choice == 5:
            self.VARBINARY(parent=current)
        elif choice == 6:
            self.BLOB(parent=current)
        elif choice == 7:
            self.YEAR(parent=current)
        local_ctx['typeName'] = current.last_child
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.lengthOneDimension(parent=current)
        self.exit_rule(current)
        return current
    dataType_dimensionDataType.min_depth = 1

    @depthcontrol
    def dataType_simpleDataType(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='dataType_simpleDataType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.DATE(parent=current)
        elif choice == 1:
            self.TINYBLOB(parent=current)
        elif choice == 2:
            self.MEDIUMBLOB(parent=current)
        elif choice == 3:
            self.LONGBLOB(parent=current)
        elif choice == 4:
            self.BOOL(parent=current)
        elif choice == 5:
            self.BOOLEAN(parent=current)
        elif choice == 6:
            self.SERIAL(parent=current)
        local_ctx['typeName'] = current.last_child
        self.exit_rule(current)
        return current
    dataType_simpleDataType.min_depth = 1

    @depthcontrol
    def dataType_collectionDataType(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='dataType_collectionDataType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.ENUM(parent=current)
        elif choice == 1:
            self.SET(parent=current)
        local_ctx['typeName'] = current.last_child
        self.collectionOptions(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.BINARY(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.CHARACTER(parent=current)
                    self.SET(parent=current)
                elif choice == 1:
                    self.CHARSET(parent=current)
                self.charsetName(parent=current)
        self.exit_rule(current)
        return current
    dataType_collectionDataType.min_depth = 3

    @depthcontrol
    def dataType_spatialDataType(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='dataType_spatialDataType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.GEOMETRYCOLLECTION(parent=current)
        elif choice == 1:
            self.GEOMCOLLECTION(parent=current)
        elif choice == 2:
            self.LINESTRING(parent=current)
        elif choice == 3:
            self.MULTILINESTRING(parent=current)
        elif choice == 4:
            self.MULTIPOINT(parent=current)
        elif choice == 5:
            self.MULTIPOLYGON(parent=current)
        elif choice == 6:
            self.POINT(parent=current)
        elif choice == 7:
            self.POLYGON(parent=current)
        elif choice == 8:
            self.JSON(parent=current)
        elif choice == 9:
            self.GEOMETRY(parent=current)
        local_ctx['typeName'] = current.last_child
        self.exit_rule(current)
        return current
    dataType_spatialDataType.min_depth = 1

    @depthcontrol
    def dataType_longVarcharDataType(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='dataType_longVarcharDataType', parent=parent)
        self.enter_rule(current)
        self.LONG(parent=current)
        local_ctx['typeName'] = current.last_child
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.VARCHAR(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.BINARY(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.CHARACTER(parent=current)
                    self.SET(parent=current)
                elif choice == 1:
                    self.CHARSET(parent=current)
                self.charsetName(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.COLLATE(parent=current)
                self.collationName(parent=current)
        self.exit_rule(current)
        return current
    dataType_longVarcharDataType.min_depth = 1

    @depthcontrol
    def dataType_longVarbinaryDataType(self, parent=None):
        current = UnparserRule(name='dataType_longVarbinaryDataType', parent=parent)
        self.enter_rule(current)
        self.LONG(parent=current)
        self.VARBINARY(parent=current)
        self.exit_rule(current)
        return current
    dataType_longVarbinaryDataType.min_depth = 1

    @depthcontrol
    def functionCall_specificFunctionCall(self, parent=None):
        current = UnparserRule(name='functionCall_specificFunctionCall', parent=parent)
        self.enter_rule(current)
        self.specificFunction(parent=current)
        self.exit_rule(current)
        return current
    functionCall_specificFunctionCall.min_depth = 3

    @depthcontrol
    def functionCall_aggregateFunctionCall(self, parent=None):
        current = UnparserRule(name='functionCall_aggregateFunctionCall', parent=parent)
        self.enter_rule(current)
        self.aggregateWindowedFunction(parent=current)
        self.exit_rule(current)
        return current
    functionCall_aggregateFunctionCall.min_depth = 2

    @depthcontrol
    def functionCall_scalarFunctionCall(self, parent=None):
        current = UnparserRule(name='functionCall_scalarFunctionCall', parent=parent)
        self.enter_rule(current)
        self.scalarFunctionName(parent=current)
        UnlexerRule(src='(', parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.functionArgs(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    functionCall_scalarFunctionCall.min_depth = 2

    @depthcontrol
    def functionCall_udfFunctionCall(self, parent=None):
        current = UnparserRule(name='functionCall_udfFunctionCall', parent=parent)
        self.enter_rule(current)
        self.fullId(parent=current)
        UnlexerRule(src='(', parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.functionArgs(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    functionCall_udfFunctionCall.min_depth = 3

    @depthcontrol
    def functionCall_passwordFunctionCall(self, parent=None):
        current = UnparserRule(name='functionCall_passwordFunctionCall', parent=parent)
        self.enter_rule(current)
        self.passwordFunctionClause(parent=current)
        self.exit_rule(current)
        return current
    functionCall_passwordFunctionCall.min_depth = 4

    @depthcontrol
    def specificFunction_simpleFunctionCall(self, parent=None):
        current = UnparserRule(name='specificFunction_simpleFunctionCall', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            self.CURRENT_DATE(parent=current)
        elif choice == 1:
            self.CURRENT_TIME(parent=current)
        elif choice == 2:
            self.CURRENT_TIMESTAMP(parent=current)
        elif choice == 3:
            self.CURRENT_USER(parent=current)
        elif choice == 4:
            self.LOCALTIME(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='(', parent=current)
                UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    specificFunction_simpleFunctionCall.min_depth = 1

    @depthcontrol
    def specificFunction_dataTypeFunctionCall(self, parent=None):
        current = UnparserRule(name='specificFunction_dataTypeFunctionCall', parent=parent)
        self.enter_rule(current)
        self.CAST(parent=current)
        UnlexerRule(src='(', parent=current)
        self.expression(parent=current)
        self.AS(parent=current)
        self.convertedDataType(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    specificFunction_dataTypeFunctionCall.min_depth = 8

    @depthcontrol
    def specificFunction_valuesFunctionCall(self, parent=None):
        current = UnparserRule(name='specificFunction_valuesFunctionCall', parent=parent)
        self.enter_rule(current)
        self.VALUES(parent=current)
        UnlexerRule(src='(', parent=current)
        self.fullColumnName(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    specificFunction_valuesFunctionCall.min_depth = 3

    @depthcontrol
    def specificFunction_caseExpressionFunctionCall(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='specificFunction_caseExpressionFunctionCall', parent=parent)
        self.enter_rule(current)
        self.CASE(parent=current)
        self.expression(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.caseFuncAlternative(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.ELSE(parent=current)
                self.functionArg(parent=current)
                local_ctx['elseArg'] = current.last_child
        self.END(parent=current)
        self.exit_rule(current)
        return current
    specificFunction_caseExpressionFunctionCall.min_depth = 8

    @depthcontrol
    def specificFunction_caseFunctionCall(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='specificFunction_caseFunctionCall', parent=parent)
        self.enter_rule(current)
        self.CASE(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.caseFuncAlternative(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.ELSE(parent=current)
                self.functionArg(parent=current)
                local_ctx['elseArg'] = current.last_child
        self.END(parent=current)
        self.exit_rule(current)
        return current
    specificFunction_caseFunctionCall.min_depth = 4

    @depthcontrol
    def specificFunction_charFunctionCall(self, parent=None):
        current = UnparserRule(name='specificFunction_charFunctionCall', parent=parent)
        self.enter_rule(current)
        self.CHAR(parent=current)
        UnlexerRule(src='(', parent=current)
        self.functionArgs(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.USING(parent=current)
                self.charsetName(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    specificFunction_charFunctionCall.min_depth = 3

    @depthcontrol
    def specificFunction_positionFunctionCall(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='specificFunction_positionFunctionCall', parent=parent)
        self.enter_rule(current)
        self.POSITION(parent=current)
        UnlexerRule(src='(', parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.stringLiteral(parent=current)
            local_ctx['positionString'] = current.last_child
        elif choice == 1:
            self.expression(parent=current)
            local_ctx['positionExpression'] = current.last_child
        self.IN(parent=current)
        choice = self.model.choice(current, 1, [0 if [3, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.stringLiteral(parent=current)
            local_ctx['inString'] = current.last_child
        elif choice == 1:
            self.expression(parent=current)
            local_ctx['inExpression'] = current.last_child
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    specificFunction_positionFunctionCall.min_depth = 3

    @depthcontrol
    def specificFunction_substrFunctionCall(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='specificFunction_substrFunctionCall', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.SUBSTR(parent=current)
        elif choice == 1:
            self.SUBSTRING(parent=current)
        UnlexerRule(src='(', parent=current)
        choice = self.model.choice(current, 1, [0 if [3, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.stringLiteral(parent=current)
            local_ctx['sourceString'] = current.last_child
        elif choice == 1:
            self.expression(parent=current)
            local_ctx['sourceExpression'] = current.last_child
        self.FROM(parent=current)
        choice = self.model.choice(current, 2, [0 if [2, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.decimalLiteral(parent=current)
            local_ctx['fromDecimal'] = current.last_child
        elif choice == 1:
            self.expression(parent=current)
            local_ctx['fromExpression'] = current.last_child
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.FOR(parent=current)
                choice = self.model.choice(current, 3, [0 if [2, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.decimalLiteral(parent=current)
                    local_ctx['forDecimal'] = current.last_child
                elif choice == 1:
                    self.expression(parent=current)
                    local_ctx['forExpression'] = current.last_child
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    specificFunction_substrFunctionCall.min_depth = 3

    @depthcontrol
    def specificFunction_trimFunctionCall(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='specificFunction_trimFunctionCall', parent=parent)
        self.enter_rule(current)
        self.TRIM(parent=current)
        UnlexerRule(src='(', parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.stringLiteral(parent=current)
            local_ctx['sourceString'] = current.last_child
        elif choice == 1:
            self.expression(parent=current)
            local_ctx['sourceExpression'] = current.last_child
        self.FROM(parent=current)
        choice = self.model.choice(current, 1, [0 if [3, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.stringLiteral(parent=current)
            local_ctx['fromString'] = current.last_child
        elif choice == 1:
            self.expression(parent=current)
            local_ctx['fromExpression'] = current.last_child
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    specificFunction_trimFunctionCall.min_depth = 3

    @depthcontrol
    def specificFunction_weightFunctionCall(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='specificFunction_weightFunctionCall', parent=parent)
        self.enter_rule(current)
        self.WEIGHT_STRING(parent=current)
        UnlexerRule(src='(', parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.stringLiteral(parent=current)
        elif choice == 1:
            self.expression(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.AS(parent=current)
                choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.CHAR(parent=current)
                elif choice == 1:
                    self.BINARY(parent=current)
                local_ctx['stringFormat'] = current.last_child
                UnlexerRule(src='(', parent=current)
                self.decimalLiteral(parent=current)
                UnlexerRule(src=')', parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.levelsInWeightString(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    specificFunction_weightFunctionCall.min_depth = 3

    @depthcontrol
    def specificFunction_extractFunctionCall(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='specificFunction_extractFunctionCall', parent=parent)
        self.enter_rule(current)
        self.EXTRACT(parent=current)
        UnlexerRule(src='(', parent=current)
        self.intervalType(parent=current)
        self.FROM(parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.stringLiteral(parent=current)
            local_ctx['sourceString'] = current.last_child
        elif choice == 1:
            self.expression(parent=current)
            local_ctx['sourceExpression'] = current.last_child
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    specificFunction_extractFunctionCall.min_depth = 3

    @depthcontrol
    def specificFunction_getFormatFunctionCall(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='specificFunction_getFormatFunctionCall', parent=parent)
        self.enter_rule(current)
        self.GET_FORMAT(parent=current)
        UnlexerRule(src='(', parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.DATE(parent=current)
        elif choice == 1:
            self.TIME(parent=current)
        elif choice == 2:
            self.DATETIME(parent=current)
        local_ctx['datetimeFormat'] = current.last_child
        UnlexerRule(src=',', parent=current)
        self.stringLiteral(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    specificFunction_getFormatFunctionCall.min_depth = 3

    @depthcontrol
    def specificFunction_jsonValueFunctionCall(self, parent=None):
        current = UnparserRule(name='specificFunction_jsonValueFunctionCall', parent=parent)
        self.enter_rule(current)
        self.JSON_VALUE(parent=current)
        UnlexerRule(src='(', parent=current)
        self.expression(parent=current)
        UnlexerRule(src=',', parent=current)
        self.expression(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.RETURNING(parent=current)
                self.convertedDataType(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    self.NULL(parent=current)
                elif choice == 1:
                    self.ERROR(parent=current)
                elif choice == 2:
                    self.DEFAULT(parent=current)
                    self.defaultValue(parent=current)
                self.ON(parent=current)
                self.EMPTY(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                choice = self.model.choice(current, 1, [0 if [1, 1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    self.NULL(parent=current)
                elif choice == 1:
                    self.ERROR(parent=current)
                elif choice == 2:
                    self.DEFAULT(parent=current)
                    self.defaultValue(parent=current)
                self.ON(parent=current)
                self.ERROR(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    specificFunction_jsonValueFunctionCall.min_depth = 8

    @depthcontrol
    def levelsInWeightString_levelWeightList(self, parent=None):
        current = UnparserRule(name='levelsInWeightString_levelWeightList', parent=parent)
        self.enter_rule(current)
        self.LEVEL(parent=current)
        self.levelInWeightListElement(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.levelInWeightListElement(parent=current)
        self.exit_rule(current)
        return current
    levelsInWeightString_levelWeightList.min_depth = 3

    @depthcontrol
    def levelsInWeightString_levelWeightRange(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='levelsInWeightString_levelWeightRange', parent=parent)
        self.enter_rule(current)
        self.LEVEL(parent=current)
        self.decimalLiteral(parent=current)
        local_ctx['firstLevel'] = current.last_child
        UnlexerRule(src='-', parent=current)
        self.decimalLiteral(parent=current)
        local_ctx['lastLevel'] = current.last_child
        self.exit_rule(current)
        return current
    levelsInWeightString_levelWeightRange.min_depth = 2

    @depthcontrol
    def expression_notExpression(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='expression_notExpression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.NOT(parent=current)
        elif choice == 1:
            UnlexerRule(src='!', parent=current)
        local_ctx['notOperator'] = current.last_child
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    expression_notExpression.min_depth = 8

    @depthcontrol
    def expression_logicalExpression(self, parent=None):
        current = UnparserRule(name='expression_logicalExpression', parent=parent)
        self.enter_rule(current)
        self.expression(parent=current)
        self.logicalOperator(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    expression_logicalExpression.min_depth = 8

    @depthcontrol
    def expression_isExpression(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='expression_isExpression', parent=parent)
        self.enter_rule(current)
        self.predicate(parent=current)
        self.IS(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.NOT(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.TRUE(parent=current)
        elif choice == 1:
            self.FALSE(parent=current)
        elif choice == 2:
            self.UNKNOWN(parent=current)
        local_ctx['testValue'] = current.last_child
        self.exit_rule(current)
        return current
    expression_isExpression.min_depth = 6

    @depthcontrol
    def expression_predicateExpression(self, parent=None):
        current = UnparserRule(name='expression_predicateExpression', parent=parent)
        self.enter_rule(current)
        self.predicate(parent=current)
        self.exit_rule(current)
        return current
    expression_predicateExpression.min_depth = 6

    @depthcontrol
    def predicate_inPredicate(self, parent=None):
        current = UnparserRule(name='predicate_inPredicate', parent=parent)
        self.enter_rule(current)
        self.predicate(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.NOT(parent=current)
        self.IN(parent=current)
        UnlexerRule(src='(', parent=current)
        choice = self.model.choice(current, 0, [0 if [4, 9][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.selectStatement(parent=current)
        elif choice == 1:
            self.expressions(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    predicate_inPredicate.min_depth = 6

    @depthcontrol
    def predicate_isNullPredicate(self, parent=None):
        current = UnparserRule(name='predicate_isNullPredicate', parent=parent)
        self.enter_rule(current)
        self.predicate(parent=current)
        self.IS(parent=current)
        self.nullNotnull(parent=current)
        self.exit_rule(current)
        return current
    predicate_isNullPredicate.min_depth = 6

    @depthcontrol
    def predicate_binaryComparisonPredicate(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='predicate_binaryComparisonPredicate', parent=parent)
        self.enter_rule(current)
        self.predicate(parent=current)
        local_ctx['left'] = current.last_child
        self.comparisonOperator(parent=current)
        self.predicate(parent=current)
        local_ctx['right'] = current.last_child
        self.exit_rule(current)
        return current
    predicate_binaryComparisonPredicate.min_depth = 6

    @depthcontrol
    def predicate_subqueryComparisonPredicate(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='predicate_subqueryComparisonPredicate', parent=parent)
        self.enter_rule(current)
        self.predicate(parent=current)
        self.comparisonOperator(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.ALL(parent=current)
        elif choice == 1:
            self.ANY(parent=current)
        elif choice == 2:
            self.SOME(parent=current)
        local_ctx['quantifier'] = current.last_child
        UnlexerRule(src='(', parent=current)
        self.selectStatement(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    predicate_subqueryComparisonPredicate.min_depth = 6

    @depthcontrol
    def predicate_betweenPredicate(self, parent=None):
        current = UnparserRule(name='predicate_betweenPredicate', parent=parent)
        self.enter_rule(current)
        self.predicate(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.NOT(parent=current)
        self.BETWEEN(parent=current)
        self.predicate(parent=current)
        self.AND(parent=current)
        self.predicate(parent=current)
        self.exit_rule(current)
        return current
    predicate_betweenPredicate.min_depth = 6

    @depthcontrol
    def predicate_soundsLikePredicate(self, parent=None):
        current = UnparserRule(name='predicate_soundsLikePredicate', parent=parent)
        self.enter_rule(current)
        self.predicate(parent=current)
        self.SOUNDS(parent=current)
        self.LIKE(parent=current)
        self.predicate(parent=current)
        self.exit_rule(current)
        return current
    predicate_soundsLikePredicate.min_depth = 6

    @depthcontrol
    def predicate_likePredicate(self, parent=None):
        current = UnparserRule(name='predicate_likePredicate', parent=parent)
        self.enter_rule(current)
        self.predicate(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.NOT(parent=current)
        self.LIKE(parent=current)
        self.predicate(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.ESCAPE(parent=current)
                self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    predicate_likePredicate.min_depth = 6

    @depthcontrol
    def predicate_regexpPredicate(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='predicate_regexpPredicate', parent=parent)
        self.enter_rule(current)
        self.predicate(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.NOT(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.REGEXP(parent=current)
        elif choice == 1:
            self.RLIKE(parent=current)
        local_ctx['regex'] = current.last_child
        self.predicate(parent=current)
        self.exit_rule(current)
        return current
    predicate_regexpPredicate.min_depth = 6

    @depthcontrol
    def predicate_expressionAtomPredicate(self, parent=None):
        current = UnparserRule(name='predicate_expressionAtomPredicate', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.LOCAL_ID(parent=current)
                self.VAR_ASSIGN(parent=current)
        self.expressionAtom(parent=current)
        self.exit_rule(current)
        return current
    predicate_expressionAtomPredicate.min_depth = 4

    @depthcontrol
    def predicate_jsonMemberOfPredicate(self, parent=None):
        current = UnparserRule(name='predicate_jsonMemberOfPredicate', parent=parent)
        self.enter_rule(current)
        self.predicate(parent=current)
        self.MEMBER(parent=current)
        self.OF(parent=current)
        UnlexerRule(src='(', parent=current)
        self.predicate(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    predicate_jsonMemberOfPredicate.min_depth = 6

    @depthcontrol
    def expressionAtom_constantExpressionAtom(self, parent=None):
        current = UnparserRule(name='expressionAtom_constantExpressionAtom', parent=parent)
        self.enter_rule(current)
        self.constant(parent=current)
        self.exit_rule(current)
        return current
    expressionAtom_constantExpressionAtom.min_depth = 2

    @depthcontrol
    def expressionAtom_fullColumnNameExpressionAtom(self, parent=None):
        current = UnparserRule(name='expressionAtom_fullColumnNameExpressionAtom', parent=parent)
        self.enter_rule(current)
        self.fullColumnName(parent=current)
        self.exit_rule(current)
        return current
    expressionAtom_fullColumnNameExpressionAtom.min_depth = 3

    @depthcontrol
    def expressionAtom_functionCallExpressionAtom(self, parent=None):
        current = UnparserRule(name='expressionAtom_functionCallExpressionAtom', parent=parent)
        self.enter_rule(current)
        self.functionCall(parent=current)
        self.exit_rule(current)
        return current
    expressionAtom_functionCallExpressionAtom.min_depth = 4

    @depthcontrol
    def expressionAtom_collateExpressionAtom(self, parent=None):
        current = UnparserRule(name='expressionAtom_collateExpressionAtom', parent=parent)
        self.enter_rule(current)
        self.expressionAtom(parent=current)
        self.COLLATE(parent=current)
        self.collationName(parent=current)
        self.exit_rule(current)
        return current
    expressionAtom_collateExpressionAtom.min_depth = 4

    @depthcontrol
    def expressionAtom_mysqlVariableExpressionAtom(self, parent=None):
        current = UnparserRule(name='expressionAtom_mysqlVariableExpressionAtom', parent=parent)
        self.enter_rule(current)
        self.mysqlVariable(parent=current)
        self.exit_rule(current)
        return current
    expressionAtom_mysqlVariableExpressionAtom.min_depth = 2

    @depthcontrol
    def expressionAtom_unaryExpressionAtom(self, parent=None):
        current = UnparserRule(name='expressionAtom_unaryExpressionAtom', parent=parent)
        self.enter_rule(current)
        self.unaryOperator(parent=current)
        self.expressionAtom(parent=current)
        self.exit_rule(current)
        return current
    expressionAtom_unaryExpressionAtom.min_depth = 4

    @depthcontrol
    def expressionAtom_binaryExpressionAtom(self, parent=None):
        current = UnparserRule(name='expressionAtom_binaryExpressionAtom', parent=parent)
        self.enter_rule(current)
        self.BINARY(parent=current)
        self.expressionAtom(parent=current)
        self.exit_rule(current)
        return current
    expressionAtom_binaryExpressionAtom.min_depth = 4

    @depthcontrol
    def expressionAtom_nestedExpressionAtom(self, parent=None):
        current = UnparserRule(name='expressionAtom_nestedExpressionAtom', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.expression(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.expression(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    expressionAtom_nestedExpressionAtom.min_depth = 8

    @depthcontrol
    def expressionAtom_nestedRowExpressionAtom(self, parent=None):
        current = UnparserRule(name='expressionAtom_nestedRowExpressionAtom', parent=parent)
        self.enter_rule(current)
        self.ROW(parent=current)
        UnlexerRule(src='(', parent=current)
        self.expression(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=',', parent=current)
                self.expression(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    expressionAtom_nestedRowExpressionAtom.min_depth = 8

    @depthcontrol
    def expressionAtom_existsExpressionAtom(self, parent=None):
        current = UnparserRule(name='expressionAtom_existsExpressionAtom', parent=parent)
        self.enter_rule(current)
        self.EXISTS(parent=current)
        UnlexerRule(src='(', parent=current)
        self.selectStatement(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    expressionAtom_existsExpressionAtom.min_depth = 4

    @depthcontrol
    def expressionAtom_subqueryExpressionAtom(self, parent=None):
        current = UnparserRule(name='expressionAtom_subqueryExpressionAtom', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.selectStatement(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    expressionAtom_subqueryExpressionAtom.min_depth = 4

    @depthcontrol
    def expressionAtom_intervalExpressionAtom(self, parent=None):
        current = UnparserRule(name='expressionAtom_intervalExpressionAtom', parent=parent)
        self.enter_rule(current)
        self.INTERVAL(parent=current)
        self.expression(parent=current)
        self.intervalType(parent=current)
        self.exit_rule(current)
        return current
    expressionAtom_intervalExpressionAtom.min_depth = 8

    @depthcontrol
    def expressionAtom_bitExpressionAtom(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='expressionAtom_bitExpressionAtom', parent=parent)
        self.enter_rule(current)
        self.expressionAtom(parent=current)
        local_ctx['left'] = current.last_child
        self.bitOperator(parent=current)
        self.expressionAtom(parent=current)
        local_ctx['right'] = current.last_child
        self.exit_rule(current)
        return current
    expressionAtom_bitExpressionAtom.min_depth = 4

    @depthcontrol
    def expressionAtom_mathExpressionAtom(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='expressionAtom_mathExpressionAtom', parent=parent)
        self.enter_rule(current)
        self.expressionAtom(parent=current)
        local_ctx['left'] = current.last_child
        self.mathOperator(parent=current)
        self.expressionAtom(parent=current)
        local_ctx['right'] = current.last_child
        self.exit_rule(current)
        return current
    expressionAtom_mathExpressionAtom.min_depth = 4

    @depthcontrol
    def expressionAtom_jsonExpressionAtom(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='expressionAtom_jsonExpressionAtom', parent=parent)
        self.enter_rule(current)
        self.expressionAtom(parent=current)
        local_ctx['left'] = current.last_child
        self.jsonOperator(parent=current)
        self.expressionAtom(parent=current)
        local_ctx['right'] = current.last_child
        self.exit_rule(current)
        return current
    expressionAtom_jsonExpressionAtom.min_depth = 4

    default_rule = root

    _charsets = {
        0: list(chain.from_iterable([range(32, 127)])),
        1: list(chain.from_iterable([range(9, 10), range(10, 11), range(13, 14), range(32, 33)])),
        2: list(chain.from_iterable([range(9, 10), range(32, 33)])),
        3: list(chain.from_iterable([range(32, 127)])),
        4: list(chain.from_iterable([range(32, 96), range(97, 127)])),
        5: list(chain.from_iterable([range(48, 58)])),
        6: list(chain.from_iterable([range(46, 47), range(48, 58)])),
        7: list(chain.from_iterable([range(48, 58), range(58, 59), range(65, 71)])),
        8: list(chain.from_iterable([range(48, 58), range(58, 59), range(65, 71)])),
        9: list(chain.from_iterable([range(36, 37), range(46, 47), range(48, 58), range(65, 91), range(95, 96)])),
        10: list(chain.from_iterable([range(36, 37), range(46, 47), range(48, 58), range(65, 91), range(95, 96)])),
        11: list(chain.from_iterable([range(43, 44), range(45, 46)])),
        12: list(chain.from_iterable([range(36, 37), range(48, 58), range(65, 91), range(95, 96), range(128, 65536)])),
        13: list(chain.from_iterable([range(36, 37), range(65, 91), range(95, 96), range(128, 65536)])),
        14: list(chain.from_iterable([range(36, 37), range(48, 58), range(65, 91), range(95, 96), range(128, 65536)])),
        15: list(chain.from_iterable([range(32, 34), range(35, 92), range(93, 127)])),
        16: list(chain.from_iterable([range(32, 92), range(93, 127)])),
        17: list(chain.from_iterable([range(32, 92), range(93, 96), range(97, 127)])),
        18: list(chain.from_iterable([range(48, 58), range(65, 71)])),
        19: list(chain.from_iterable([range(48, 58)])),
        20: list(chain.from_iterable([range(48, 49), range(49, 50)])),
    }

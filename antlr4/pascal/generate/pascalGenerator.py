# Generated by Grammarinator 0.0.0

from itertools import chain
from math import inf
from grammarinator.runtime import *

class pascalGenerator(Generator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)


    @depthcontrol
    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    @depthcontrol
    def program(self, parent=None):
        current = UnparserRule(name='program', parent=parent)
        self.enter_rule(current)
        self.programHeading(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.INTERFACE(parent=current)
        self.block(parent=current)
        self.DOT(parent=current)
        self.exit_rule(current)
        return current
    program.min_depth = 7

    @depthcontrol
    def programHeading(self, parent=None):
        current = UnparserRule(name='programHeading', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.PROGRAM(parent=current)
            self.identifier(parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.LPAREN(parent=current)
                    self.identifierList(parent=current)
                    self.RPAREN(parent=current)
            self.SEMI(parent=current)
        elif choice == 1:
            self.UNIT(parent=current)
            self.identifier(parent=current)
            self.SEMI(parent=current)
        self.exit_rule(current)
        return current
    programHeading.min_depth = 2

    @depthcontrol
    def identifier(self, parent=None):
        current = UnparserRule(name='identifier', parent=parent)
        self.enter_rule(current)
        self.SPACE(parent=current)
        self.IDENT(parent=current)
        self.exit_rule(current)
        return current
    identifier.min_depth = 1

    @depthcontrol
    def block(self, parent=None):
        current = UnparserRule(name='block', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [4, 5, 5, 7, 10, 4, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
                if choice == 0:
                    self.labelDeclarationPart(parent=current)
                elif choice == 1:
                    self.constantDefinitionPart(parent=current)
                elif choice == 2:
                    self.typeDefinitionPart(parent=current)
                elif choice == 3:
                    self.variableDeclarationPart(parent=current)
                elif choice == 4:
                    self.procedureAndFunctionDeclarationPart(parent=current)
                elif choice == 5:
                    self.usesUnitsPart(parent=current)
                elif choice == 6:
                    self.IMPLEMENTATION(parent=current)
        self.compoundStatement(parent=current)
        self.exit_rule(current)
        return current
    block.min_depth = 6

    @depthcontrol
    def usesUnitsPart(self, parent=None):
        current = UnparserRule(name='usesUnitsPart', parent=parent)
        self.enter_rule(current)
        self.USES(parent=current)
        self.identifierList(parent=current)
        self.SEMI(parent=current)
        self.exit_rule(current)
        return current
    usesUnitsPart.min_depth = 3

    @depthcontrol
    def labelDeclarationPart(self, parent=None):
        current = UnparserRule(name='labelDeclarationPart', parent=parent)
        self.enter_rule(current)
        self.LABEL(parent=current)
        self.label(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.COMMA(parent=current)
                self.label(parent=current)
        self.SEMI(parent=current)
        self.exit_rule(current)
        return current
    labelDeclarationPart.min_depth = 3

    @depthcontrol
    def label(self, parent=None):
        current = UnparserRule(name='label', parent=parent)
        self.enter_rule(current)
        self.unsignedInteger(parent=current)
        self.exit_rule(current)
        return current
    label.min_depth = 2

    @depthcontrol
    def constantDefinitionPart(self, parent=None):
        current = UnparserRule(name='constantDefinitionPart', parent=parent)
        self.enter_rule(current)
        self.CONST(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.constantDefinition(parent=current)
                self.SEMI(parent=current)
        self.exit_rule(current)
        return current
    constantDefinitionPart.min_depth = 4

    @depthcontrol
    def constantDefinition(self, parent=None):
        current = UnparserRule(name='constantDefinition', parent=parent)
        self.enter_rule(current)
        self.identifier(parent=current)
        self.EQUAL(parent=current)
        self.constant(parent=current)
        self.exit_rule(current)
        return current
    constantDefinition.min_depth = 3

    @depthcontrol
    def constantChr(self, parent=None):
        current = UnparserRule(name='constantChr', parent=parent)
        self.enter_rule(current)
        self.CHR(parent=current)
        self.LPAREN(parent=current)
        self.unsignedInteger(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    constantChr.min_depth = 2

    @depthcontrol
    def constant(self, parent=None):
        current = UnparserRule(name='constant', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3, 2, 2, 2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.unsignedNumber(parent=current)
        elif choice == 1:
            self.sign(parent=current)
            self.unsignedNumber(parent=current)
        elif choice == 2:
            self.identifier(parent=current)
        elif choice == 3:
            self.sign(parent=current)
            self.identifier(parent=current)
        elif choice == 4:
            self.string(parent=current)
        elif choice == 5:
            self.constantChr(parent=current)
        self.exit_rule(current)
        return current
    constant.min_depth = 2

    @depthcontrol
    def unsignedNumber(self, parent=None):
        current = UnparserRule(name='unsignedNumber', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.unsignedInteger(parent=current)
        elif choice == 1:
            self.unsignedReal(parent=current)
        self.exit_rule(current)
        return current
    unsignedNumber.min_depth = 2

    @depthcontrol
    def unsignedInteger(self, parent=None):
        current = UnparserRule(name='unsignedInteger', parent=parent)
        self.enter_rule(current)
        self.NUM_INT(parent=current)
        self.exit_rule(current)
        return current
    unsignedInteger.min_depth = 1

    @depthcontrol
    def unsignedReal(self, parent=None):
        current = UnparserRule(name='unsignedReal', parent=parent)
        self.enter_rule(current)
        self.NUM_REAL(parent=current)
        self.exit_rule(current)
        return current
    unsignedReal.min_depth = 1

    @depthcontrol
    def sign(self, parent=None):
        current = UnparserRule(name='sign', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.PLUS(parent=current)
        elif choice == 1:
            self.MINUS(parent=current)
        self.exit_rule(current)
        return current
    sign.min_depth = 1

    @depthcontrol
    def bool_(self, parent=None):
        current = UnparserRule(name='bool_', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.TRUE(parent=current)
        elif choice == 1:
            self.FALSE(parent=current)
        self.exit_rule(current)
        return current
    bool_.min_depth = 2

    @depthcontrol
    def string(self, parent=None):
        current = UnparserRule(name='string', parent=parent)
        self.enter_rule(current)
        self.STRING_LITERAL(parent=current)
        self.exit_rule(current)
        return current
    string.min_depth = 1

    @depthcontrol
    def typeDefinitionPart(self, parent=None):
        current = UnparserRule(name='typeDefinitionPart', parent=parent)
        self.enter_rule(current)
        self.TYPE(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.typeDefinition(parent=current)
                self.SEMI(parent=current)
        self.exit_rule(current)
        return current
    typeDefinitionPart.min_depth = 4

    @depthcontrol
    def typeDefinition(self, parent=None):
        current = UnparserRule(name='typeDefinition', parent=parent)
        self.enter_rule(current)
        self.identifier(parent=current)
        self.EQUAL(parent=current)
        choice = self.model.choice(current, 0, [0 if [5, 5, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.type_(parent=current)
        elif choice == 1:
            self.functionType(parent=current)
        elif choice == 2:
            self.procedureType(parent=current)
        self.exit_rule(current)
        return current
    typeDefinition.min_depth = 3

    @depthcontrol
    def functionType(self, parent=None):
        current = UnparserRule(name='functionType', parent=parent)
        self.enter_rule(current)
        self.FUNCTION(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.formalParameterList(parent=current)
        self.COLON(parent=current)
        self.resultType(parent=current)
        self.exit_rule(current)
        return current
    functionType.min_depth = 4

    @depthcontrol
    def procedureType(self, parent=None):
        current = UnparserRule(name='procedureType', parent=parent)
        self.enter_rule(current)
        self.PROCEDURE(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.formalParameterList(parent=current)
        self.exit_rule(current)
        return current
    procedureType.min_depth = 2

    @depthcontrol
    def type_(self, parent=None):
        current = UnparserRule(name='type_', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 5, 4][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.simpleType(parent=current)
        elif choice == 1:
            self.structuredType(parent=current)
        elif choice == 2:
            self.pointerType(parent=current)
        self.exit_rule(current)
        return current
    type_.min_depth = 4

    @depthcontrol
    def simpleType(self, parent=None):
        current = UnparserRule(name='simpleType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 4, 3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.scalarType(parent=current)
        elif choice == 1:
            self.subrangeType(parent=current)
        elif choice == 2:
            self.typeIdentifier(parent=current)
        elif choice == 3:
            self.stringtype(parent=current)
        self.exit_rule(current)
        return current
    simpleType.min_depth = 3

    @depthcontrol
    def scalarType(self, parent=None):
        current = UnparserRule(name='scalarType', parent=parent)
        self.enter_rule(current)
        self.LPAREN(parent=current)
        self.identifierList(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    scalarType.min_depth = 3

    @depthcontrol
    def subrangeType(self, parent=None):
        current = UnparserRule(name='subrangeType', parent=parent)
        self.enter_rule(current)
        self.constant(parent=current)
        self.DOTDOT(parent=current)
        self.constant(parent=current)
        self.exit_rule(current)
        return current
    subrangeType.min_depth = 3

    @depthcontrol
    def typeIdentifier(self, parent=None):
        current = UnparserRule(name='typeIdentifier', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.identifier(parent=current)
        elif choice == 1:
            choice = self.model.choice(current, 1, [0 if [2, 2, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
            if choice == 0:
                self.CHAR(parent=current)
            elif choice == 1:
                self.BOOLEAN(parent=current)
            elif choice == 2:
                self.INTEGER(parent=current)
            elif choice == 3:
                self.REAL(parent=current)
            elif choice == 4:
                self.STRING(parent=current)
        self.exit_rule(current)
        return current
    typeIdentifier.min_depth = 2

    @depthcontrol
    def structuredType(self, parent=None):
        current = UnparserRule(name='structuredType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.PACKED(parent=current)
            self.unpackedStructuredType(parent=current)
        elif choice == 1:
            self.unpackedStructuredType(parent=current)
        self.exit_rule(current)
        return current
    structuredType.min_depth = 4

    @depthcontrol
    def unpackedStructuredType(self, parent=None):
        current = UnparserRule(name='unpackedStructuredType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [7, 3, 6, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.arrayType(parent=current)
        elif choice == 1:
            self.recordType(parent=current)
        elif choice == 2:
            self.setType(parent=current)
        elif choice == 3:
            self.fileType(parent=current)
        self.exit_rule(current)
        return current
    unpackedStructuredType.min_depth = 3

    @depthcontrol
    def stringtype(self, parent=None):
        current = UnparserRule(name='stringtype', parent=parent)
        self.enter_rule(current)
        self.STRING(parent=current)
        self.LBRACK(parent=current)
        choice = self.model.choice(current, 0, [0 if [2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.identifier(parent=current)
        elif choice == 1:
            self.unsignedNumber(parent=current)
        self.RBRACK(parent=current)
        self.exit_rule(current)
        return current
    stringtype.min_depth = 2

    @depthcontrol
    def arrayType(self, parent=None):
        current = UnparserRule(name='arrayType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [6, 6][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.ARRAY(parent=current)
            self.LBRACK(parent=current)
            self.typeList(parent=current)
            self.RBRACK(parent=current)
            self.OF(parent=current)
            self.componentType(parent=current)
        elif choice == 1:
            self.ARRAY(parent=current)
            self.LBRACK2(parent=current)
            self.typeList(parent=current)
            self.RBRACK2(parent=current)
            self.OF(parent=current)
            self.componentType(parent=current)
        self.exit_rule(current)
        return current
    arrayType.min_depth = 6

    @depthcontrol
    def typeList(self, parent=None):
        current = UnparserRule(name='typeList', parent=parent)
        self.enter_rule(current)
        self.indexType(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.COMMA(parent=current)
                self.indexType(parent=current)
        self.exit_rule(current)
        return current
    typeList.min_depth = 5

    @depthcontrol
    def indexType(self, parent=None):
        current = UnparserRule(name='indexType', parent=parent)
        self.enter_rule(current)
        self.simpleType(parent=current)
        self.exit_rule(current)
        return current
    indexType.min_depth = 4

    @depthcontrol
    def componentType(self, parent=None):
        current = UnparserRule(name='componentType', parent=parent)
        self.enter_rule(current)
        self.type_(parent=current)
        self.exit_rule(current)
        return current
    componentType.min_depth = 5

    @depthcontrol
    def recordType(self, parent=None):
        current = UnparserRule(name='recordType', parent=parent)
        self.enter_rule(current)
        self.RECORD(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.fieldList(parent=current)
        self.END(parent=current)
        self.exit_rule(current)
        return current
    recordType.min_depth = 2

    @depthcontrol
    def fieldList(self, parent=None):
        current = UnparserRule(name='fieldList', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [7, 10][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.fixedPart(parent=current)
            if self.max_depth >= 10:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.SEMI(parent=current)
                    self.variantPart(parent=current)
        elif choice == 1:
            self.variantPart(parent=current)
        self.exit_rule(current)
        return current
    fieldList.min_depth = 7

    @depthcontrol
    def fixedPart(self, parent=None):
        current = UnparserRule(name='fixedPart', parent=parent)
        self.enter_rule(current)
        self.recordSection(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.SEMI(parent=current)
                self.recordSection(parent=current)
        self.exit_rule(current)
        return current
    fixedPart.min_depth = 6

    @depthcontrol
    def recordSection(self, parent=None):
        current = UnparserRule(name='recordSection', parent=parent)
        self.enter_rule(current)
        self.identifierList(parent=current)
        self.COLON(parent=current)
        self.type_(parent=current)
        self.exit_rule(current)
        return current
    recordSection.min_depth = 5

    @depthcontrol
    def variantPart(self, parent=None):
        current = UnparserRule(name='variantPart', parent=parent)
        self.enter_rule(current)
        self.CASE(parent=current)
        self.tag(parent=current)
        self.OF(parent=current)
        self.variant(parent=current)
        if self.max_depth >= 9:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.SEMI(parent=current)
                self.variant(parent=current)
        self.exit_rule(current)
        return current
    variantPart.min_depth = 9

    @depthcontrol
    def tag(self, parent=None):
        current = UnparserRule(name='tag', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.identifier(parent=current)
            self.COLON(parent=current)
            self.typeIdentifier(parent=current)
        elif choice == 1:
            self.typeIdentifier(parent=current)
        self.exit_rule(current)
        return current
    tag.min_depth = 3

    @depthcontrol
    def variant(self, parent=None):
        current = UnparserRule(name='variant', parent=parent)
        self.enter_rule(current)
        self.constList(parent=current)
        self.COLON(parent=current)
        self.LPAREN(parent=current)
        self.fieldList(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    variant.min_depth = 8

    @depthcontrol
    def setType(self, parent=None):
        current = UnparserRule(name='setType', parent=parent)
        self.enter_rule(current)
        self.SET(parent=current)
        self.OF(parent=current)
        self.baseType(parent=current)
        self.exit_rule(current)
        return current
    setType.min_depth = 5

    @depthcontrol
    def baseType(self, parent=None):
        current = UnparserRule(name='baseType', parent=parent)
        self.enter_rule(current)
        self.simpleType(parent=current)
        self.exit_rule(current)
        return current
    baseType.min_depth = 4

    @depthcontrol
    def fileType(self, parent=None):
        current = UnparserRule(name='fileType', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.FILE(parent=current)
            self.OF(parent=current)
            self.type_(parent=current)
        elif choice == 1:
            self.FILE(parent=current)
        self.exit_rule(current)
        return current
    fileType.min_depth = 2

    @depthcontrol
    def pointerType(self, parent=None):
        current = UnparserRule(name='pointerType', parent=parent)
        self.enter_rule(current)
        self.POINTER(parent=current)
        self.typeIdentifier(parent=current)
        self.exit_rule(current)
        return current
    pointerType.min_depth = 3

    @depthcontrol
    def variableDeclarationPart(self, parent=None):
        current = UnparserRule(name='variableDeclarationPart', parent=parent)
        self.enter_rule(current)
        self.VAR(parent=current)
        self.variableDeclaration(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.SEMI(parent=current)
                self.variableDeclaration(parent=current)
        self.SEMI(parent=current)
        self.exit_rule(current)
        return current
    variableDeclarationPart.min_depth = 6

    @depthcontrol
    def variableDeclaration(self, parent=None):
        current = UnparserRule(name='variableDeclaration', parent=parent)
        self.enter_rule(current)
        self.identifierList(parent=current)
        self.COLON(parent=current)
        self.type_(parent=current)
        self.exit_rule(current)
        return current
    variableDeclaration.min_depth = 5

    @depthcontrol
    def procedureAndFunctionDeclarationPart(self, parent=None):
        current = UnparserRule(name='procedureAndFunctionDeclarationPart', parent=parent)
        self.enter_rule(current)
        self.procedureOrFunctionDeclaration(parent=current)
        self.SEMI(parent=current)
        self.exit_rule(current)
        return current
    procedureAndFunctionDeclarationPart.min_depth = 9

    @depthcontrol
    def procedureOrFunctionDeclaration(self, parent=None):
        current = UnparserRule(name='procedureOrFunctionDeclaration', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [8, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.procedureDeclaration(parent=current)
        elif choice == 1:
            self.functionDeclaration(parent=current)
        self.exit_rule(current)
        return current
    procedureOrFunctionDeclaration.min_depth = 8

    @depthcontrol
    def procedureDeclaration(self, parent=None):
        current = UnparserRule(name='procedureDeclaration', parent=parent)
        self.enter_rule(current)
        self.PROCEDURE(parent=current)
        self.identifier(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.formalParameterList(parent=current)
        self.SEMI(parent=current)
        self.block(parent=current)
        self.exit_rule(current)
        return current
    procedureDeclaration.min_depth = 7

    @depthcontrol
    def formalParameterList(self, parent=None):
        current = UnparserRule(name='formalParameterList', parent=parent)
        self.enter_rule(current)
        self.LPAREN(parent=current)
        self.formalParameterSection(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.SEMI(parent=current)
                self.formalParameterSection(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    formalParameterList.min_depth = 5

    @depthcontrol
    def formalParameterSection(self, parent=None):
        current = UnparserRule(name='formalParameterSection', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 4, 4, 4][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.parameterGroup(parent=current)
        elif choice == 1:
            self.VAR(parent=current)
            self.parameterGroup(parent=current)
        elif choice == 2:
            self.FUNCTION(parent=current)
            self.parameterGroup(parent=current)
        elif choice == 3:
            self.PROCEDURE(parent=current)
            self.parameterGroup(parent=current)
        self.exit_rule(current)
        return current
    formalParameterSection.min_depth = 4

    @depthcontrol
    def parameterGroup(self, parent=None):
        current = UnparserRule(name='parameterGroup', parent=parent)
        self.enter_rule(current)
        self.identifierList(parent=current)
        self.COLON(parent=current)
        self.typeIdentifier(parent=current)
        self.exit_rule(current)
        return current
    parameterGroup.min_depth = 3

    @depthcontrol
    def identifierList(self, parent=None):
        current = UnparserRule(name='identifierList', parent=parent)
        self.enter_rule(current)
        self.identifier(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.COMMA(parent=current)
                self.identifier(parent=current)
        self.exit_rule(current)
        return current
    identifierList.min_depth = 2

    @depthcontrol
    def constList(self, parent=None):
        current = UnparserRule(name='constList', parent=parent)
        self.enter_rule(current)
        self.constant(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.COMMA(parent=current)
                self.constant(parent=current)
        self.exit_rule(current)
        return current
    constList.min_depth = 3

    @depthcontrol
    def functionDeclaration(self, parent=None):
        current = UnparserRule(name='functionDeclaration', parent=parent)
        self.enter_rule(current)
        self.FUNCTION(parent=current)
        self.identifier(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.formalParameterList(parent=current)
        self.COLON(parent=current)
        self.resultType(parent=current)
        self.SEMI(parent=current)
        self.block(parent=current)
        self.exit_rule(current)
        return current
    functionDeclaration.min_depth = 7

    @depthcontrol
    def resultType(self, parent=None):
        current = UnparserRule(name='resultType', parent=parent)
        self.enter_rule(current)
        self.typeIdentifier(parent=current)
        self.exit_rule(current)
        return current
    resultType.min_depth = 3

    @depthcontrol
    def statement(self, parent=None):
        current = UnparserRule(name='statement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.label(parent=current)
            self.COLON(parent=current)
            self.unlabelledStatement(parent=current)
        elif choice == 1:
            self.unlabelledStatement(parent=current)
        self.exit_rule(current)
        return current
    statement.min_depth = 3

    @depthcontrol
    def unlabelledStatement(self, parent=None):
        current = UnparserRule(name='unlabelledStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 6][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.simpleStatement(parent=current)
        elif choice == 1:
            self.structuredStatement(parent=current)
        self.exit_rule(current)
        return current
    unlabelledStatement.min_depth = 2

    @depthcontrol
    def simpleStatement(self, parent=None):
        current = UnparserRule(name='simpleStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [8, 3, 4, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.assignmentStatement(parent=current)
        elif choice == 1:
            self.procedureStatement(parent=current)
        elif choice == 2:
            self.gotoStatement(parent=current)
        elif choice == 3:
            self.emptyStatement(parent=current)
        self.exit_rule(current)
        return current
    simpleStatement.min_depth = 1

    @depthcontrol
    def assignmentStatement(self, parent=None):
        current = UnparserRule(name='assignmentStatement', parent=parent)
        self.enter_rule(current)
        self.variable(parent=current)
        self.ASSIGN(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    assignmentStatement.min_depth = 7

    @depthcontrol
    def variable(self, parent=None):
        current = UnparserRule(name='variable', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.AT(parent=current)
            self.identifier(parent=current)
        elif choice == 1:
            self.identifier(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 1, [0 if [7, 7, 2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
                if choice == 0:
                    self.LBRACK(parent=current)
                    self.expression(parent=current)
                    if self.max_depth >= 7:
                        for _ in self.model.quantify(current, 1, min=0, max=inf):
                            self.COMMA(parent=current)
                            self.expression(parent=current)
                    self.RBRACK(parent=current)
                elif choice == 1:
                    self.LBRACK2(parent=current)
                    self.expression(parent=current)
                    if self.max_depth >= 7:
                        for _ in self.model.quantify(current, 2, min=0, max=inf):
                            self.COMMA(parent=current)
                            self.expression(parent=current)
                    self.RBRACK2(parent=current)
                elif choice == 2:
                    self.DOT(parent=current)
                    self.identifier(parent=current)
                elif choice == 3:
                    self.POINTER(parent=current)
        self.exit_rule(current)
        return current
    variable.min_depth = 2

    @depthcontrol
    def expression(self, parent=None):
        current = UnparserRule(name='expression', parent=parent)
        self.enter_rule(current)
        self.simpleExpression(parent=current)
        if self.max_depth >= 7:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.relationaloperator(parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    expression.min_depth = 6

    @depthcontrol
    def relationaloperator(self, parent=None):
        current = UnparserRule(name='relationaloperator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.EQUAL(parent=current)
        elif choice == 1:
            self.NOT_EQUAL(parent=current)
        elif choice == 2:
            self.LT(parent=current)
        elif choice == 3:
            self.LE(parent=current)
        elif choice == 4:
            self.GE(parent=current)
        elif choice == 5:
            self.GT(parent=current)
        elif choice == 6:
            self.IN(parent=current)
        self.exit_rule(current)
        return current
    relationaloperator.min_depth = 1

    @depthcontrol
    def simpleExpression(self, parent=None):
        current = UnparserRule(name='simpleExpression', parent=parent)
        self.enter_rule(current)
        self.term(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.additiveoperator(parent=current)
                self.simpleExpression(parent=current)
        self.exit_rule(current)
        return current
    simpleExpression.min_depth = 5

    @depthcontrol
    def additiveoperator(self, parent=None):
        current = UnparserRule(name='additiveoperator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.PLUS(parent=current)
        elif choice == 1:
            self.MINUS(parent=current)
        elif choice == 2:
            self.OR(parent=current)
        self.exit_rule(current)
        return current
    additiveoperator.min_depth = 1

    @depthcontrol
    def term(self, parent=None):
        current = UnparserRule(name='term', parent=parent)
        self.enter_rule(current)
        self.signedFactor(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.multiplicativeoperator(parent=current)
                self.term(parent=current)
        self.exit_rule(current)
        return current
    term.min_depth = 4

    @depthcontrol
    def multiplicativeoperator(self, parent=None):
        current = UnparserRule(name='multiplicativeoperator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            self.STAR(parent=current)
        elif choice == 1:
            self.SLASH(parent=current)
        elif choice == 2:
            self.DIV(parent=current)
        elif choice == 3:
            self.MOD(parent=current)
        elif choice == 4:
            self.AND(parent=current)
        self.exit_rule(current)
        return current
    multiplicativeoperator.min_depth = 1

    @depthcontrol
    def signedFactor(self, parent=None):
        current = UnparserRule(name='signedFactor', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.PLUS(parent=current)
                elif choice == 1:
                    self.MINUS(parent=current)
        self.factor(parent=current)
        self.exit_rule(current)
        return current
    signedFactor.min_depth = 3

    @depthcontrol
    def factor(self, parent=None):
        current = UnparserRule(name='factor', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 7, 10, 3, 2, 3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.variable(parent=current)
        elif choice == 1:
            self.LPAREN(parent=current)
            self.expression(parent=current)
            self.RPAREN(parent=current)
        elif choice == 2:
            self.functionDesignator(parent=current)
        elif choice == 3:
            self.unsignedConstant(parent=current)
        elif choice == 4:
            self.set_(parent=current)
        elif choice == 5:
            self.NOT(parent=current)
            self.factor(parent=current)
        elif choice == 6:
            self.bool_(parent=current)
        self.exit_rule(current)
        return current
    factor.min_depth = 2

    @depthcontrol
    def unsignedConstant(self, parent=None):
        current = UnparserRule(name='unsignedConstant', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.unsignedNumber(parent=current)
        elif choice == 1:
            self.constantChr(parent=current)
        elif choice == 2:
            self.string(parent=current)
        elif choice == 3:
            self.NIL(parent=current)
        self.exit_rule(current)
        return current
    unsignedConstant.min_depth = 2

    @depthcontrol
    def functionDesignator(self, parent=None):
        current = UnparserRule(name='functionDesignator', parent=parent)
        self.enter_rule(current)
        self.identifier(parent=current)
        self.LPAREN(parent=current)
        self.parameterList(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    functionDesignator.min_depth = 9

    @depthcontrol
    def parameterList(self, parent=None):
        current = UnparserRule(name='parameterList', parent=parent)
        self.enter_rule(current)
        self.actualParameter(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.COMMA(parent=current)
                self.actualParameter(parent=current)
        self.exit_rule(current)
        return current
    parameterList.min_depth = 8

    @depthcontrol
    def set_(self, parent=None):
        current = UnparserRule(name='set_', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.LBRACK(parent=current)
            self.elementList(parent=current)
            self.RBRACK(parent=current)
        elif choice == 1:
            self.LBRACK2(parent=current)
            self.elementList(parent=current)
            self.RBRACK2(parent=current)
        self.exit_rule(current)
        return current
    set_.min_depth = 1

    @depthcontrol
    def elementList(self, parent=None):
        current = UnparserRule(name='elementList', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [8, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.element(parent=current)
            if self.max_depth >= 8:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    self.COMMA(parent=current)
                    self.element(parent=current)
        elif choice == 1:
            pass
        self.exit_rule(current)
        return current
    elementList.min_depth = 0

    @depthcontrol
    def element(self, parent=None):
        current = UnparserRule(name='element', parent=parent)
        self.enter_rule(current)
        self.expression(parent=current)
        if self.max_depth >= 7:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.DOTDOT(parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    element.min_depth = 7

    @depthcontrol
    def procedureStatement(self, parent=None):
        current = UnparserRule(name='procedureStatement', parent=parent)
        self.enter_rule(current)
        self.identifier(parent=current)
        if self.max_depth >= 9:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.LPAREN(parent=current)
                self.parameterList(parent=current)
                self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    procedureStatement.min_depth = 2

    @depthcontrol
    def actualParameter(self, parent=None):
        current = UnparserRule(name='actualParameter', parent=parent)
        self.enter_rule(current)
        self.expression(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.parameterwidth(parent=current)
        self.exit_rule(current)
        return current
    actualParameter.min_depth = 7

    @depthcontrol
    def parameterwidth(self, parent=None):
        current = UnparserRule(name='parameterwidth', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=':', parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    parameterwidth.min_depth = 7

    @depthcontrol
    def gotoStatement(self, parent=None):
        current = UnparserRule(name='gotoStatement', parent=parent)
        self.enter_rule(current)
        self.GOTO(parent=current)
        self.label(parent=current)
        self.exit_rule(current)
        return current
    gotoStatement.min_depth = 3

    @depthcontrol
    def emptyStatement(self, parent=None):
        current = UnparserRule(name='emptyStatement', parent=parent)
        self.enter_rule(current)
        pass
        self.exit_rule(current)
        return current
    emptyStatement.min_depth = 0

    @depthcontrol
    def empty_(self, parent=None):
        current = UnparserRule(name='empty_', parent=parent)
        self.enter_rule(current)
        pass
        self.exit_rule(current)
        return current
    empty_.min_depth = 0

    @depthcontrol
    def structuredStatement(self, parent=None):
        current = UnparserRule(name='structuredStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [6, 9, 9, 5][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.compoundStatement(parent=current)
        elif choice == 1:
            self.conditionalStatement(parent=current)
        elif choice == 2:
            self.repetetiveStatement(parent=current)
        elif choice == 3:
            self.withStatement(parent=current)
        self.exit_rule(current)
        return current
    structuredStatement.min_depth = 5

    @depthcontrol
    def compoundStatement(self, parent=None):
        current = UnparserRule(name='compoundStatement', parent=parent)
        self.enter_rule(current)
        self.BEGIN(parent=current)
        self.SPACE(parent=current)
        self.statements(parent=current)
        self.END(parent=current)
        self.exit_rule(current)
        return current
    compoundStatement.min_depth = 5

    @depthcontrol
    def statements(self, parent=None):
        current = UnparserRule(name='statements', parent=parent)
        self.enter_rule(current)
        self.statement(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.SEMI(parent=current)
                self.statement(parent=current)
        self.exit_rule(current)
        return current
    statements.min_depth = 4

    @depthcontrol
    def conditionalStatement(self, parent=None):
        current = UnparserRule(name='conditionalStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [8, 8][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.ifStatement(parent=current)
        elif choice == 1:
            self.caseStatement(parent=current)
        self.exit_rule(current)
        return current
    conditionalStatement.min_depth = 8

    @depthcontrol
    def ifStatement(self, parent=None):
        current = UnparserRule(name='ifStatement', parent=parent)
        self.enter_rule(current)
        self.IF(parent=current)
        self.expression(parent=current)
        self.THEN(parent=current)
        self.statement(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.ELSE(parent=current)
                self.statement(parent=current)
        self.exit_rule(current)
        return current
    ifStatement.min_depth = 7

    @depthcontrol
    def caseStatement(self, parent=None):
        current = UnparserRule(name='caseStatement', parent=parent)
        self.enter_rule(current)
        self.CASE(parent=current)
        self.expression(parent=current)
        self.OF(parent=current)
        self.caseListElement(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.SEMI(parent=current)
                self.caseListElement(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.SEMI(parent=current)
                self.ELSE(parent=current)
                self.statements(parent=current)
        self.END(parent=current)
        self.exit_rule(current)
        return current
    caseStatement.min_depth = 7

    @depthcontrol
    def caseListElement(self, parent=None):
        current = UnparserRule(name='caseListElement', parent=parent)
        self.enter_rule(current)
        self.constList(parent=current)
        self.COLON(parent=current)
        self.statement(parent=current)
        self.exit_rule(current)
        return current
    caseListElement.min_depth = 4

    @depthcontrol
    def repetetiveStatement(self, parent=None):
        current = UnparserRule(name='repetetiveStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [8, 8, 10][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.whileStatement(parent=current)
        elif choice == 1:
            self.repeatStatement(parent=current)
        elif choice == 2:
            self.forStatement(parent=current)
        self.exit_rule(current)
        return current
    repetetiveStatement.min_depth = 8

    @depthcontrol
    def whileStatement(self, parent=None):
        current = UnparserRule(name='whileStatement', parent=parent)
        self.enter_rule(current)
        self.WHILE(parent=current)
        self.expression(parent=current)
        self.DO(parent=current)
        self.statement(parent=current)
        self.exit_rule(current)
        return current
    whileStatement.min_depth = 7

    @depthcontrol
    def repeatStatement(self, parent=None):
        current = UnparserRule(name='repeatStatement', parent=parent)
        self.enter_rule(current)
        self.REPEAT(parent=current)
        self.statements(parent=current)
        self.UNTIL(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    repeatStatement.min_depth = 7

    @depthcontrol
    def forStatement(self, parent=None):
        current = UnparserRule(name='forStatement', parent=parent)
        self.enter_rule(current)
        self.FOR(parent=current)
        self.identifier(parent=current)
        self.ASSIGN(parent=current)
        self.forList(parent=current)
        self.DO(parent=current)
        self.statement(parent=current)
        self.exit_rule(current)
        return current
    forStatement.min_depth = 9

    @depthcontrol
    def forList(self, parent=None):
        current = UnparserRule(name='forList', parent=parent)
        self.enter_rule(current)
        self.initialValue(parent=current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.TO(parent=current)
        elif choice == 1:
            self.DOWNTO(parent=current)
        self.finalValue(parent=current)
        self.exit_rule(current)
        return current
    forList.min_depth = 8

    @depthcontrol
    def initialValue(self, parent=None):
        current = UnparserRule(name='initialValue', parent=parent)
        self.enter_rule(current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    initialValue.min_depth = 7

    @depthcontrol
    def finalValue(self, parent=None):
        current = UnparserRule(name='finalValue', parent=parent)
        self.enter_rule(current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    finalValue.min_depth = 7

    @depthcontrol
    def withStatement(self, parent=None):
        current = UnparserRule(name='withStatement', parent=parent)
        self.enter_rule(current)
        self.WITH(parent=current)
        self.recordVariableList(parent=current)
        self.DO(parent=current)
        self.statement(parent=current)
        self.exit_rule(current)
        return current
    withStatement.min_depth = 4

    @depthcontrol
    def recordVariableList(self, parent=None):
        current = UnparserRule(name='recordVariableList', parent=parent)
        self.enter_rule(current)
        self.variable(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.COMMA(parent=current)
                self.variable(parent=current)
        self.exit_rule(current)
        return current
    recordVariableList.min_depth = 3

    @depthcontrol
    def A(self, parent=None):
        current = UnlexerRule(name='A', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='a', parent=current)
        elif choice == 1:
            UnlexerRule(src='A', parent=current)
        self.exit_rule(current)
        return current
    A.min_depth = 0

    @depthcontrol
    def B(self, parent=None):
        current = UnlexerRule(name='B', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='b', parent=current)
        elif choice == 1:
            UnlexerRule(src='B', parent=current)
        self.exit_rule(current)
        return current
    B.min_depth = 0

    @depthcontrol
    def C(self, parent=None):
        current = UnlexerRule(name='C', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='c', parent=current)
        elif choice == 1:
            UnlexerRule(src='C', parent=current)
        self.exit_rule(current)
        return current
    C.min_depth = 0

    @depthcontrol
    def D(self, parent=None):
        current = UnlexerRule(name='D', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='d', parent=current)
        elif choice == 1:
            UnlexerRule(src='D', parent=current)
        self.exit_rule(current)
        return current
    D.min_depth = 0

    @depthcontrol
    def E(self, parent=None):
        current = UnlexerRule(name='E', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='e', parent=current)
        elif choice == 1:
            UnlexerRule(src='E', parent=current)
        self.exit_rule(current)
        return current
    E.min_depth = 0

    @depthcontrol
    def F(self, parent=None):
        current = UnlexerRule(name='F', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='f', parent=current)
        elif choice == 1:
            UnlexerRule(src='F', parent=current)
        self.exit_rule(current)
        return current
    F.min_depth = 0

    @depthcontrol
    def G(self, parent=None):
        current = UnlexerRule(name='G', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='g', parent=current)
        elif choice == 1:
            UnlexerRule(src='G', parent=current)
        self.exit_rule(current)
        return current
    G.min_depth = 0

    @depthcontrol
    def H(self, parent=None):
        current = UnlexerRule(name='H', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='h', parent=current)
        elif choice == 1:
            UnlexerRule(src='H', parent=current)
        self.exit_rule(current)
        return current
    H.min_depth = 0

    @depthcontrol
    def I(self, parent=None):
        current = UnlexerRule(name='I', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='i', parent=current)
        elif choice == 1:
            UnlexerRule(src='I', parent=current)
        self.exit_rule(current)
        return current
    I.min_depth = 0

    @depthcontrol
    def J(self, parent=None):
        current = UnlexerRule(name='J', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='j', parent=current)
        elif choice == 1:
            UnlexerRule(src='J', parent=current)
        self.exit_rule(current)
        return current
    J.min_depth = 0

    @depthcontrol
    def K(self, parent=None):
        current = UnlexerRule(name='K', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='k', parent=current)
        elif choice == 1:
            UnlexerRule(src='K', parent=current)
        self.exit_rule(current)
        return current
    K.min_depth = 0

    @depthcontrol
    def L(self, parent=None):
        current = UnlexerRule(name='L', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='l', parent=current)
        elif choice == 1:
            UnlexerRule(src='L', parent=current)
        self.exit_rule(current)
        return current
    L.min_depth = 0

    @depthcontrol
    def M(self, parent=None):
        current = UnlexerRule(name='M', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='m', parent=current)
        elif choice == 1:
            UnlexerRule(src='M', parent=current)
        self.exit_rule(current)
        return current
    M.min_depth = 0

    @depthcontrol
    def N(self, parent=None):
        current = UnlexerRule(name='N', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='n', parent=current)
        elif choice == 1:
            UnlexerRule(src='N', parent=current)
        self.exit_rule(current)
        return current
    N.min_depth = 0

    @depthcontrol
    def O(self, parent=None):
        current = UnlexerRule(name='O', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='o', parent=current)
        elif choice == 1:
            UnlexerRule(src='O', parent=current)
        self.exit_rule(current)
        return current
    O.min_depth = 0

    @depthcontrol
    def P(self, parent=None):
        current = UnlexerRule(name='P', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='p', parent=current)
        elif choice == 1:
            UnlexerRule(src='P', parent=current)
        self.exit_rule(current)
        return current
    P.min_depth = 0

    @depthcontrol
    def Q(self, parent=None):
        current = UnlexerRule(name='Q', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='q', parent=current)
        elif choice == 1:
            UnlexerRule(src='Q', parent=current)
        self.exit_rule(current)
        return current
    Q.min_depth = 0

    @depthcontrol
    def R(self, parent=None):
        current = UnlexerRule(name='R', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='r', parent=current)
        elif choice == 1:
            UnlexerRule(src='R', parent=current)
        self.exit_rule(current)
        return current
    R.min_depth = 0

    @depthcontrol
    def S(self, parent=None):
        current = UnlexerRule(name='S', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='s', parent=current)
        elif choice == 1:
            UnlexerRule(src='S', parent=current)
        self.exit_rule(current)
        return current
    S.min_depth = 0

    @depthcontrol
    def T(self, parent=None):
        current = UnlexerRule(name='T', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='t', parent=current)
        elif choice == 1:
            UnlexerRule(src='T', parent=current)
        self.exit_rule(current)
        return current
    T.min_depth = 0

    @depthcontrol
    def U(self, parent=None):
        current = UnlexerRule(name='U', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='u', parent=current)
        elif choice == 1:
            UnlexerRule(src='U', parent=current)
        self.exit_rule(current)
        return current
    U.min_depth = 0

    @depthcontrol
    def V(self, parent=None):
        current = UnlexerRule(name='V', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='v', parent=current)
        elif choice == 1:
            UnlexerRule(src='V', parent=current)
        self.exit_rule(current)
        return current
    V.min_depth = 0

    @depthcontrol
    def W(self, parent=None):
        current = UnlexerRule(name='W', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='w', parent=current)
        elif choice == 1:
            UnlexerRule(src='W', parent=current)
        self.exit_rule(current)
        return current
    W.min_depth = 0

    @depthcontrol
    def X(self, parent=None):
        current = UnlexerRule(name='X', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='x', parent=current)
        elif choice == 1:
            UnlexerRule(src='X', parent=current)
        self.exit_rule(current)
        return current
    X.min_depth = 0

    @depthcontrol
    def Y(self, parent=None):
        current = UnlexerRule(name='Y', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='y', parent=current)
        elif choice == 1:
            UnlexerRule(src='Y', parent=current)
        self.exit_rule(current)
        return current
    Y.min_depth = 0

    @depthcontrol
    def Z(self, parent=None):
        current = UnlexerRule(name='Z', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='z', parent=current)
        elif choice == 1:
            UnlexerRule(src='Z', parent=current)
        self.exit_rule(current)
        return current
    Z.min_depth = 0

    @depthcontrol
    def AND(self, parent=None):
        current = UnlexerRule(name='AND', parent=parent)
        self.enter_rule(current)
        self.A(parent=current)
        self.N(parent=current)
        self.D(parent=current)
        self.exit_rule(current)
        return current
    AND.min_depth = 1

    @depthcontrol
    def ARRAY(self, parent=None):
        current = UnlexerRule(name='ARRAY', parent=parent)
        self.enter_rule(current)
        self.A(parent=current)
        self.R(parent=current)
        self.R(parent=current)
        self.A(parent=current)
        self.Y(parent=current)
        self.exit_rule(current)
        return current
    ARRAY.min_depth = 1

    @depthcontrol
    def BEGIN(self, parent=None):
        current = UnlexerRule(name='BEGIN', parent=parent)
        self.enter_rule(current)
        self.B(parent=current)
        self.E(parent=current)
        self.G(parent=current)
        self.I(parent=current)
        self.N(parent=current)
        self.exit_rule(current)
        return current
    BEGIN.min_depth = 1

    @depthcontrol
    def BOOLEAN(self, parent=None):
        current = UnlexerRule(name='BOOLEAN', parent=parent)
        self.enter_rule(current)
        self.B(parent=current)
        self.O(parent=current)
        self.O(parent=current)
        self.L(parent=current)
        self.E(parent=current)
        self.A(parent=current)
        self.N(parent=current)
        self.exit_rule(current)
        return current
    BOOLEAN.min_depth = 1

    @depthcontrol
    def CASE(self, parent=None):
        current = UnlexerRule(name='CASE', parent=parent)
        self.enter_rule(current)
        self.C(parent=current)
        self.A(parent=current)
        self.S(parent=current)
        self.E(parent=current)
        self.exit_rule(current)
        return current
    CASE.min_depth = 1

    @depthcontrol
    def CHAR(self, parent=None):
        current = UnlexerRule(name='CHAR', parent=parent)
        self.enter_rule(current)
        self.C(parent=current)
        self.H(parent=current)
        self.A(parent=current)
        self.R(parent=current)
        self.exit_rule(current)
        return current
    CHAR.min_depth = 1

    @depthcontrol
    def CHR(self, parent=None):
        current = UnlexerRule(name='CHR', parent=parent)
        self.enter_rule(current)
        self.C(parent=current)
        self.H(parent=current)
        self.R(parent=current)
        self.exit_rule(current)
        return current
    CHR.min_depth = 1

    @depthcontrol
    def CONST(self, parent=None):
        current = UnlexerRule(name='CONST', parent=parent)
        self.enter_rule(current)
        self.C(parent=current)
        self.O(parent=current)
        self.N(parent=current)
        self.S(parent=current)
        self.T(parent=current)
        self.exit_rule(current)
        return current
    CONST.min_depth = 1

    @depthcontrol
    def DIV(self, parent=None):
        current = UnlexerRule(name='DIV', parent=parent)
        self.enter_rule(current)
        self.D(parent=current)
        self.I(parent=current)
        self.V(parent=current)
        self.exit_rule(current)
        return current
    DIV.min_depth = 1

    @depthcontrol
    def DO(self, parent=None):
        current = UnlexerRule(name='DO', parent=parent)
        self.enter_rule(current)
        self.D(parent=current)
        self.O(parent=current)
        self.exit_rule(current)
        return current
    DO.min_depth = 1

    @depthcontrol
    def DOWNTO(self, parent=None):
        current = UnlexerRule(name='DOWNTO', parent=parent)
        self.enter_rule(current)
        self.D(parent=current)
        self.O(parent=current)
        self.W(parent=current)
        self.N(parent=current)
        self.T(parent=current)
        self.O(parent=current)
        self.exit_rule(current)
        return current
    DOWNTO.min_depth = 1

    @depthcontrol
    def ELSE(self, parent=None):
        current = UnlexerRule(name='ELSE', parent=parent)
        self.enter_rule(current)
        self.E(parent=current)
        self.L(parent=current)
        self.S(parent=current)
        self.E(parent=current)
        self.exit_rule(current)
        return current
    ELSE.min_depth = 1

    @depthcontrol
    def END(self, parent=None):
        current = UnlexerRule(name='END', parent=parent)
        self.enter_rule(current)
        self.E(parent=current)
        self.N(parent=current)
        self.D(parent=current)
        self.exit_rule(current)
        return current
    END.min_depth = 1

    @depthcontrol
    def FILE(self, parent=None):
        current = UnlexerRule(name='FILE', parent=parent)
        self.enter_rule(current)
        self.F(parent=current)
        self.I(parent=current)
        self.L(parent=current)
        self.E(parent=current)
        self.exit_rule(current)
        return current
    FILE.min_depth = 1

    @depthcontrol
    def FOR(self, parent=None):
        current = UnlexerRule(name='FOR', parent=parent)
        self.enter_rule(current)
        self.F(parent=current)
        self.O(parent=current)
        self.R(parent=current)
        self.exit_rule(current)
        return current
    FOR.min_depth = 1

    @depthcontrol
    def FUNCTION(self, parent=None):
        current = UnlexerRule(name='FUNCTION', parent=parent)
        self.enter_rule(current)
        self.F(parent=current)
        self.U(parent=current)
        self.N(parent=current)
        self.C(parent=current)
        self.T(parent=current)
        self.I(parent=current)
        self.O(parent=current)
        self.N(parent=current)
        self.exit_rule(current)
        return current
    FUNCTION.min_depth = 1

    @depthcontrol
    def GOTO(self, parent=None):
        current = UnlexerRule(name='GOTO', parent=parent)
        self.enter_rule(current)
        self.G(parent=current)
        self.O(parent=current)
        self.T(parent=current)
        self.O(parent=current)
        self.exit_rule(current)
        return current
    GOTO.min_depth = 1

    @depthcontrol
    def IF(self, parent=None):
        current = UnlexerRule(name='IF', parent=parent)
        self.enter_rule(current)
        self.I(parent=current)
        self.F(parent=current)
        self.exit_rule(current)
        return current
    IF.min_depth = 1

    @depthcontrol
    def IN(self, parent=None):
        current = UnlexerRule(name='IN', parent=parent)
        self.enter_rule(current)
        self.I(parent=current)
        self.N(parent=current)
        self.exit_rule(current)
        return current
    IN.min_depth = 1

    @depthcontrol
    def INTEGER(self, parent=None):
        current = UnlexerRule(name='INTEGER', parent=parent)
        self.enter_rule(current)
        self.I(parent=current)
        self.N(parent=current)
        self.T(parent=current)
        self.E(parent=current)
        self.G(parent=current)
        self.E(parent=current)
        self.R(parent=current)
        self.exit_rule(current)
        return current
    INTEGER.min_depth = 1

    @depthcontrol
    def LABEL(self, parent=None):
        current = UnlexerRule(name='LABEL', parent=parent)
        self.enter_rule(current)
        self.L(parent=current)
        self.A(parent=current)
        self.B(parent=current)
        self.E(parent=current)
        self.L(parent=current)
        self.exit_rule(current)
        return current
    LABEL.min_depth = 1

    @depthcontrol
    def MOD(self, parent=None):
        current = UnlexerRule(name='MOD', parent=parent)
        self.enter_rule(current)
        self.M(parent=current)
        self.O(parent=current)
        self.D(parent=current)
        self.exit_rule(current)
        return current
    MOD.min_depth = 1

    @depthcontrol
    def NIL(self, parent=None):
        current = UnlexerRule(name='NIL', parent=parent)
        self.enter_rule(current)
        self.N(parent=current)
        self.I(parent=current)
        self.L(parent=current)
        self.exit_rule(current)
        return current
    NIL.min_depth = 1

    @depthcontrol
    def NOT(self, parent=None):
        current = UnlexerRule(name='NOT', parent=parent)
        self.enter_rule(current)
        self.N(parent=current)
        self.O(parent=current)
        self.T(parent=current)
        self.exit_rule(current)
        return current
    NOT.min_depth = 1

    @depthcontrol
    def OF(self, parent=None):
        current = UnlexerRule(name='OF', parent=parent)
        self.enter_rule(current)
        self.O(parent=current)
        self.F(parent=current)
        self.exit_rule(current)
        return current
    OF.min_depth = 1

    @depthcontrol
    def OR(self, parent=None):
        current = UnlexerRule(name='OR', parent=parent)
        self.enter_rule(current)
        self.O(parent=current)
        self.R(parent=current)
        self.exit_rule(current)
        return current
    OR.min_depth = 1

    @depthcontrol
    def PACKED(self, parent=None):
        current = UnlexerRule(name='PACKED', parent=parent)
        self.enter_rule(current)
        self.P(parent=current)
        self.A(parent=current)
        self.C(parent=current)
        self.K(parent=current)
        self.E(parent=current)
        self.D(parent=current)
        self.exit_rule(current)
        return current
    PACKED.min_depth = 1

    @depthcontrol
    def PROCEDURE(self, parent=None):
        current = UnlexerRule(name='PROCEDURE', parent=parent)
        self.enter_rule(current)
        self.P(parent=current)
        self.R(parent=current)
        self.O(parent=current)
        self.C(parent=current)
        self.E(parent=current)
        self.D(parent=current)
        self.U(parent=current)
        self.R(parent=current)
        self.E(parent=current)
        self.exit_rule(current)
        return current
    PROCEDURE.min_depth = 1

    @depthcontrol
    def PROGRAM(self, parent=None):
        current = UnlexerRule(name='PROGRAM', parent=parent)
        self.enter_rule(current)
        self.P(parent=current)
        self.R(parent=current)
        self.O(parent=current)
        self.G(parent=current)
        self.R(parent=current)
        self.A(parent=current)
        self.M(parent=current)
        self.exit_rule(current)
        return current
    PROGRAM.min_depth = 1

    @depthcontrol
    def REAL(self, parent=None):
        current = UnlexerRule(name='REAL', parent=parent)
        self.enter_rule(current)
        self.R(parent=current)
        self.E(parent=current)
        self.A(parent=current)
        self.L(parent=current)
        self.exit_rule(current)
        return current
    REAL.min_depth = 1

    @depthcontrol
    def RECORD(self, parent=None):
        current = UnlexerRule(name='RECORD', parent=parent)
        self.enter_rule(current)
        self.R(parent=current)
        self.E(parent=current)
        self.C(parent=current)
        self.O(parent=current)
        self.R(parent=current)
        self.D(parent=current)
        self.exit_rule(current)
        return current
    RECORD.min_depth = 1

    @depthcontrol
    def REPEAT(self, parent=None):
        current = UnlexerRule(name='REPEAT', parent=parent)
        self.enter_rule(current)
        self.R(parent=current)
        self.E(parent=current)
        self.P(parent=current)
        self.E(parent=current)
        self.A(parent=current)
        self.T(parent=current)
        self.exit_rule(current)
        return current
    REPEAT.min_depth = 1

    @depthcontrol
    def SET(self, parent=None):
        current = UnlexerRule(name='SET', parent=parent)
        self.enter_rule(current)
        self.S(parent=current)
        self.E(parent=current)
        self.T(parent=current)
        self.exit_rule(current)
        return current
    SET.min_depth = 1

    @depthcontrol
    def THEN(self, parent=None):
        current = UnlexerRule(name='THEN', parent=parent)
        self.enter_rule(current)
        self.T(parent=current)
        self.H(parent=current)
        self.E(parent=current)
        self.N(parent=current)
        self.exit_rule(current)
        return current
    THEN.min_depth = 1

    @depthcontrol
    def TO(self, parent=None):
        current = UnlexerRule(name='TO', parent=parent)
        self.enter_rule(current)
        self.T(parent=current)
        self.O(parent=current)
        self.exit_rule(current)
        return current
    TO.min_depth = 1

    @depthcontrol
    def TYPE(self, parent=None):
        current = UnlexerRule(name='TYPE', parent=parent)
        self.enter_rule(current)
        self.T(parent=current)
        self.Y(parent=current)
        self.P(parent=current)
        self.E(parent=current)
        self.exit_rule(current)
        return current
    TYPE.min_depth = 1

    @depthcontrol
    def UNTIL(self, parent=None):
        current = UnlexerRule(name='UNTIL', parent=parent)
        self.enter_rule(current)
        self.U(parent=current)
        self.N(parent=current)
        self.T(parent=current)
        self.I(parent=current)
        self.L(parent=current)
        self.exit_rule(current)
        return current
    UNTIL.min_depth = 1

    @depthcontrol
    def VAR(self, parent=None):
        current = UnlexerRule(name='VAR', parent=parent)
        self.enter_rule(current)
        self.V(parent=current)
        self.A(parent=current)
        self.R(parent=current)
        self.exit_rule(current)
        return current
    VAR.min_depth = 1

    @depthcontrol
    def WHILE(self, parent=None):
        current = UnlexerRule(name='WHILE', parent=parent)
        self.enter_rule(current)
        self.W(parent=current)
        self.H(parent=current)
        self.I(parent=current)
        self.L(parent=current)
        self.E(parent=current)
        self.exit_rule(current)
        return current
    WHILE.min_depth = 1

    @depthcontrol
    def WITH(self, parent=None):
        current = UnlexerRule(name='WITH', parent=parent)
        self.enter_rule(current)
        self.W(parent=current)
        self.I(parent=current)
        self.T(parent=current)
        self.H(parent=current)
        self.exit_rule(current)
        return current
    WITH.min_depth = 1

    @depthcontrol
    def PLUS(self, parent=None):
        current = UnlexerRule(name='PLUS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='+', parent=current)
        self.exit_rule(current)
        return current
    PLUS.min_depth = 0

    @depthcontrol
    def MINUS(self, parent=None):
        current = UnlexerRule(name='MINUS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='-', parent=current)
        self.exit_rule(current)
        return current
    MINUS.min_depth = 0

    @depthcontrol
    def STAR(self, parent=None):
        current = UnlexerRule(name='STAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='*', parent=current)
        self.exit_rule(current)
        return current
    STAR.min_depth = 0

    @depthcontrol
    def SLASH(self, parent=None):
        current = UnlexerRule(name='SLASH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='/', parent=current)
        self.exit_rule(current)
        return current
    SLASH.min_depth = 0

    @depthcontrol
    def ASSIGN(self, parent=None):
        current = UnlexerRule(name='ASSIGN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=':=', parent=current)
        self.exit_rule(current)
        return current
    ASSIGN.min_depth = 0

    @depthcontrol
    def COMMA(self, parent=None):
        current = UnlexerRule(name='COMMA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=',', parent=current)
        self.exit_rule(current)
        return current
    COMMA.min_depth = 0

    @depthcontrol
    def SEMI(self, parent=None):
        current = UnlexerRule(name='SEMI', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=';', parent=current)
        self.exit_rule(current)
        return current
    SEMI.min_depth = 0

    @depthcontrol
    def COLON(self, parent=None):
        current = UnlexerRule(name='COLON', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=':', parent=current)
        self.exit_rule(current)
        return current
    COLON.min_depth = 0

    @depthcontrol
    def EQUAL(self, parent=None):
        current = UnlexerRule(name='EQUAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='=', parent=current)
        self.exit_rule(current)
        return current
    EQUAL.min_depth = 0

    @depthcontrol
    def NOT_EQUAL(self, parent=None):
        current = UnlexerRule(name='NOT_EQUAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<>', parent=current)
        self.exit_rule(current)
        return current
    NOT_EQUAL.min_depth = 0

    @depthcontrol
    def LT(self, parent=None):
        current = UnlexerRule(name='LT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<', parent=current)
        self.exit_rule(current)
        return current
    LT.min_depth = 0

    @depthcontrol
    def LE(self, parent=None):
        current = UnlexerRule(name='LE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<=', parent=current)
        self.exit_rule(current)
        return current
    LE.min_depth = 0

    @depthcontrol
    def GE(self, parent=None):
        current = UnlexerRule(name='GE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='>=', parent=current)
        self.exit_rule(current)
        return current
    GE.min_depth = 0

    @depthcontrol
    def GT(self, parent=None):
        current = UnlexerRule(name='GT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='>', parent=current)
        self.exit_rule(current)
        return current
    GT.min_depth = 0

    @depthcontrol
    def LPAREN(self, parent=None):
        current = UnlexerRule(name='LPAREN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.exit_rule(current)
        return current
    LPAREN.min_depth = 0

    @depthcontrol
    def RPAREN(self, parent=None):
        current = UnlexerRule(name='RPAREN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    RPAREN.min_depth = 0

    @depthcontrol
    def LBRACK(self, parent=None):
        current = UnlexerRule(name='LBRACK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='[', parent=current)
        self.exit_rule(current)
        return current
    LBRACK.min_depth = 0

    @depthcontrol
    def LBRACK2(self, parent=None):
        current = UnlexerRule(name='LBRACK2', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(.', parent=current)
        self.exit_rule(current)
        return current
    LBRACK2.min_depth = 0

    @depthcontrol
    def RBRACK(self, parent=None):
        current = UnlexerRule(name='RBRACK', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=']', parent=current)
        self.exit_rule(current)
        return current
    RBRACK.min_depth = 0

    @depthcontrol
    def RBRACK2(self, parent=None):
        current = UnlexerRule(name='RBRACK2', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='.)', parent=current)
        self.exit_rule(current)
        return current
    RBRACK2.min_depth = 0

    @depthcontrol
    def POINTER(self, parent=None):
        current = UnlexerRule(name='POINTER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='^', parent=current)
        self.exit_rule(current)
        return current
    POINTER.min_depth = 0

    @depthcontrol
    def AT(self, parent=None):
        current = UnlexerRule(name='AT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='@', parent=current)
        self.exit_rule(current)
        return current
    AT.min_depth = 0

    @depthcontrol
    def DOT(self, parent=None):
        current = UnlexerRule(name='DOT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='.', parent=current)
        self.exit_rule(current)
        return current
    DOT.min_depth = 0

    @depthcontrol
    def DOTDOT(self, parent=None):
        current = UnlexerRule(name='DOTDOT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='..', parent=current)
        self.exit_rule(current)
        return current
    DOTDOT.min_depth = 0

    @depthcontrol
    def LCURLY(self, parent=None):
        current = UnlexerRule(name='LCURLY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='{', parent=current)
        self.exit_rule(current)
        return current
    LCURLY.min_depth = 0

    @depthcontrol
    def RCURLY(self, parent=None):
        current = UnlexerRule(name='RCURLY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='}', parent=current)
        self.exit_rule(current)
        return current
    RCURLY.min_depth = 0

    @depthcontrol
    def SPACE(self, parent=None):
        current = UnlexerRule(name='SPACE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=' ', parent=current)
        self.exit_rule(current)
        return current
    SPACE.min_depth = 0

    @depthcontrol
    def UNIT(self, parent=None):
        current = UnlexerRule(name='UNIT', parent=parent)
        self.enter_rule(current)
        self.U(parent=current)
        self.N(parent=current)
        self.I(parent=current)
        self.T(parent=current)
        self.exit_rule(current)
        return current
    UNIT.min_depth = 1

    @depthcontrol
    def INTERFACE(self, parent=None):
        current = UnlexerRule(name='INTERFACE', parent=parent)
        self.enter_rule(current)
        self.I(parent=current)
        self.N(parent=current)
        self.T(parent=current)
        self.E(parent=current)
        self.R(parent=current)
        self.F(parent=current)
        self.A(parent=current)
        self.C(parent=current)
        self.E(parent=current)
        self.exit_rule(current)
        return current
    INTERFACE.min_depth = 1

    @depthcontrol
    def USES(self, parent=None):
        current = UnlexerRule(name='USES', parent=parent)
        self.enter_rule(current)
        self.U(parent=current)
        self.S(parent=current)
        self.E(parent=current)
        self.S(parent=current)
        self.exit_rule(current)
        return current
    USES.min_depth = 1

    @depthcontrol
    def STRING(self, parent=None):
        current = UnlexerRule(name='STRING', parent=parent)
        self.enter_rule(current)
        self.S(parent=current)
        self.T(parent=current)
        self.R(parent=current)
        self.I(parent=current)
        self.N(parent=current)
        self.G(parent=current)
        self.exit_rule(current)
        return current
    STRING.min_depth = 1

    @depthcontrol
    def IMPLEMENTATION(self, parent=None):
        current = UnlexerRule(name='IMPLEMENTATION', parent=parent)
        self.enter_rule(current)
        self.I(parent=current)
        self.M(parent=current)
        self.P(parent=current)
        self.L(parent=current)
        self.E(parent=current)
        self.M(parent=current)
        self.E(parent=current)
        self.N(parent=current)
        self.T(parent=current)
        self.A(parent=current)
        self.T(parent=current)
        self.I(parent=current)
        self.O(parent=current)
        self.N(parent=current)
        self.exit_rule(current)
        return current
    IMPLEMENTATION.min_depth = 1

    @depthcontrol
    def TRUE(self, parent=None):
        current = UnlexerRule(name='TRUE', parent=parent)
        self.enter_rule(current)
        self.T(parent=current)
        self.R(parent=current)
        self.U(parent=current)
        self.E(parent=current)
        self.exit_rule(current)
        return current
    TRUE.min_depth = 1

    @depthcontrol
    def FALSE(self, parent=None):
        current = UnlexerRule(name='FALSE', parent=parent)
        self.enter_rule(current)
        self.F(parent=current)
        self.A(parent=current)
        self.L(parent=current)
        self.S(parent=current)
        self.E(parent=current)
        self.exit_rule(current)
        return current
    FALSE.min_depth = 1

    @depthcontrol
    def WS(self, parent=None):
        current = UnlexerRule(name='WS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[1]), parent=current)
        self.exit_rule(current)
        return current
    WS.min_depth = 0

    @depthcontrol
    def COMMENT_1(self, parent=None):
        current = UnlexerRule(name='COMMENT_1', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(*', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[0]), parent=current)
        UnlexerRule(src='*)', parent=current)
        self.exit_rule(current)
        return current
    COMMENT_1.min_depth = 0

    @depthcontrol
    def COMMENT_2(self, parent=None):
        current = UnlexerRule(name='COMMENT_2', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='{', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[0]), parent=current)
        UnlexerRule(src='}', parent=current)
        self.exit_rule(current)
        return current
    COMMENT_2.min_depth = 0

    @depthcontrol
    def IDENT(self, parent=None):
        current = UnlexerRule(name='IDENT', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src=self.model.charset(current, 0, self._charsets[2]), parent=current)
        elif choice == 1:
            UnlexerRule(src=self.model.charset(current, 1, self._charsets[3]), parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 1, [0 if [0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
                if choice == 0:
                    UnlexerRule(src=self.model.charset(current, 2, self._charsets[4]), parent=current)
                elif choice == 1:
                    UnlexerRule(src=self.model.charset(current, 3, self._charsets[5]), parent=current)
                elif choice == 2:
                    UnlexerRule(src=self.model.charset(current, 4, self._charsets[6]), parent=current)
                elif choice == 3:
                    UnlexerRule(src='_', parent=current)
        self.exit_rule(current)
        return current
    IDENT.min_depth = 0

    @depthcontrol
    def STRING_LITERAL(self, parent=None):
        current = UnlexerRule(name='STRING_LITERAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='\'', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='\'\'', parent=current)
                elif choice == 1:
                    UnlexerRule(src=self.model.charset(current, 0, self._charsets[7]), parent=current)
        UnlexerRule(src='\'', parent=current)
        self.exit_rule(current)
        return current
    STRING_LITERAL.min_depth = 0

    @depthcontrol
    def NUM_INT(self, parent=None):
        current = UnlexerRule(name='NUM_INT', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[8]), parent=current)
        self.exit_rule(current)
        return current
    NUM_INT.min_depth = 0

    @depthcontrol
    def NUM_REAL(self, parent=None):
        current = UnlexerRule(name='NUM_REAL', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[9]), parent=current)
        choice = self.model.choice(current, 0, [0 if [0, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    UnlexerRule(src='.', parent=current)
                    if self.max_depth >= 0:
                        for _ in self.model.quantify(current, 2, min=1, max=inf):
                            UnlexerRule(src=self.model.charset(current, 1, self._charsets[10]), parent=current)
                    if self.max_depth >= 1:
                        for _ in self.model.quantify(current, 3, min=0, max=1):
                            self.EXPONENT(parent=current)
        elif choice == 1:
            self.EXPONENT(parent=current)
        self.exit_rule(current)
        return current
    NUM_REAL.min_depth = 0

    @depthcontrol
    def EXPONENT(self, parent=None):
        current = UnlexerRule(name='EXPONENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='e', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='+', parent=current)
                elif choice == 1:
                    UnlexerRule(src='-', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[11]), parent=current)
        self.exit_rule(current)
        return current
    EXPONENT.min_depth = 0

    default_rule = program

    _charsets = {
        0: list(chain.from_iterable([range(32, 127)])),
        1: list(chain.from_iterable([range(9, 10), range(10, 11), range(13, 14), range(32, 33)])),
        2: list(chain.from_iterable([range(97, 123)])),
        3: list(chain.from_iterable([range(65, 91)])),
        4: list(chain.from_iterable([range(97, 123)])),
        5: list(chain.from_iterable([range(65, 91)])),
        6: list(chain.from_iterable([range(48, 58)])),
        7: list(chain.from_iterable([range(32, 92), range(93, 127)])),
        8: list(chain.from_iterable([range(48, 58)])),
        9: list(chain.from_iterable([range(48, 58)])),
        10: list(chain.from_iterable([range(48, 58)])),
        11: list(chain.from_iterable([range(48, 58)])),
    }

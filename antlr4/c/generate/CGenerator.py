# Generated by Grammarinator 0.0.0

from itertools import chain
from math import inf
from grammarinator.runtime import *

class CGenerator(Generator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)


    @depthcontrol
    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    @depthcontrol
    def primaryExpression(self, parent=None):
        current = UnparserRule(name='primaryExpression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3, 1, 4, 6, 1, 4, 4][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.Identifier(parent=current)
        elif choice == 1:
            self.Constant(parent=current)
        elif choice == 2:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=1, max=inf):
                    self.StringLiteral(parent=current)
        elif choice == 3:
            UnlexerRule(src='(', parent=current)
            self.expression(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 4:
            self.genericSelection(parent=current)
        elif choice == 5:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    UnlexerRule(src='__extension__', parent=current)
            UnlexerRule(src='(', parent=current)
            self.compoundStatement(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 6:
            UnlexerRule(src='__builtin_va_arg', parent=current)
            UnlexerRule(src='(', parent=current)
            self.unaryExpression(parent=current)
            UnlexerRule(src=',', parent=current)
            self.typeName(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 7:
            UnlexerRule(src='__builtin_offsetof', parent=current)
            UnlexerRule(src='(', parent=current)
            self.typeName(parent=current)
            UnlexerRule(src=',', parent=current)
            self.unaryExpression(parent=current)
            UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    primaryExpression.min_depth = 1

    @depthcontrol
    def genericSelection(self, parent=None):
        current = UnparserRule(name='genericSelection', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='_Generic', parent=current)
        UnlexerRule(src='(', parent=current)
        self.assignmentExpression(parent=current)
        UnlexerRule(src=',', parent=current)
        self.genericAssocList(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    genericSelection.min_depth = 5

    @depthcontrol
    def genericAssocList(self, parent=None):
        current = UnparserRule(name='genericAssocList', parent=parent)
        self.enter_rule(current)
        self.genericAssociation(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.genericAssociation(parent=current)
        self.exit_rule(current)
        return current
    genericAssocList.min_depth = 4

    @depthcontrol
    def genericAssociation(self, parent=None):
        current = UnparserRule(name='genericAssociation', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.typeName(parent=current)
        elif choice == 1:
            UnlexerRule(src='default', parent=current)
        UnlexerRule(src=':', parent=current)
        self.assignmentExpression(parent=current)
        self.exit_rule(current)
        return current
    genericAssociation.min_depth = 3

    @depthcontrol
    def postfixExpression(self, parent=None):
        current = UnparserRule(name='postfixExpression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 5][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.primaryExpression(parent=current)
        elif choice == 1:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src='__extension__', parent=current)
            UnlexerRule(src='(', parent=current)
            self.typeName(parent=current)
            UnlexerRule(src=')', parent=current)
            UnlexerRule(src='{', parent=current)
            self.initializerList(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    UnlexerRule(src=',', parent=current)
            UnlexerRule(src='}', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 2, min=0, max=inf):
                choice = self.model.choice(current, 1, [0 if [4, 0, 3, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
                if choice == 0:
                    UnlexerRule(src='[', parent=current)
                    self.expression(parent=current)
                    UnlexerRule(src=']', parent=current)
                elif choice == 1:
                    UnlexerRule(src='(', parent=current)
                    if self.max_depth >= 4:
                        for _ in self.model.quantify(current, 3, min=0, max=1):
                            self.argumentExpressionList(parent=current)
                    UnlexerRule(src=')', parent=current)
                elif choice == 2:
                    choice = self.model.choice(current, 2, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                    if choice == 0:
                        UnlexerRule(src='.', parent=current)
                    elif choice == 1:
                        UnlexerRule(src='->', parent=current)
                    self.Identifier(parent=current)
                elif choice == 3:
                    choice = self.model.choice(current, 3, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                    if choice == 0:
                        UnlexerRule(src='++', parent=current)
                    elif choice == 1:
                        UnlexerRule(src='--', parent=current)
        self.exit_rule(current)
        return current
    postfixExpression.min_depth = 2

    @depthcontrol
    def argumentExpressionList(self, parent=None):
        current = UnparserRule(name='argumentExpressionList', parent=parent)
        self.enter_rule(current)
        self.assignmentExpression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.assignmentExpression(parent=current)
        self.exit_rule(current)
        return current
    argumentExpressionList.min_depth = 3

    @depthcontrol
    def unaryExpression(self, parent=None):
        current = UnparserRule(name='unaryExpression', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    UnlexerRule(src='++', parent=current)
                elif choice == 1:
                    UnlexerRule(src='--', parent=current)
                elif choice == 2:
                    UnlexerRule(src='sizeof', parent=current)
        choice = self.model.choice(current, 1, [0 if [3, 3, 3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.postfixExpression(parent=current)
        elif choice == 1:
            self.unaryOperator(parent=current)
            self.castExpression(parent=current)
        elif choice == 2:
            choice = self.model.choice(current, 2, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                UnlexerRule(src='sizeof', parent=current)
            elif choice == 1:
                UnlexerRule(src='_Alignof', parent=current)
            UnlexerRule(src='(', parent=current)
            self.typeName(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 3:
            UnlexerRule(src='&&', parent=current)
            self.Identifier(parent=current)
        self.exit_rule(current)
        return current
    unaryExpression.min_depth = 3

    @depthcontrol
    def unaryOperator(self, parent=None):
        current = UnparserRule(name='unaryOperator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='&', parent=current)
        elif choice == 1:
            UnlexerRule(src='*', parent=current)
        elif choice == 2:
            UnlexerRule(src='+', parent=current)
        elif choice == 3:
            UnlexerRule(src='-', parent=current)
        elif choice == 4:
            UnlexerRule(src='~', parent=current)
        elif choice == 5:
            UnlexerRule(src='!', parent=current)
        self.exit_rule(current)
        return current
    unaryOperator.min_depth = 0

    @depthcontrol
    def castExpression(self, parent=None):
        current = UnparserRule(name='castExpression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 4, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src='__extension__', parent=current)
            UnlexerRule(src='(', parent=current)
            self.typeName(parent=current)
            UnlexerRule(src=')', parent=current)
            self.castExpression(parent=current)
        elif choice == 1:
            self.unaryExpression(parent=current)
        elif choice == 2:
            self.DigitSequence(parent=current)
        self.exit_rule(current)
        return current
    castExpression.min_depth = 2

    @depthcontrol
    def multiplicativeExpression(self, parent=None):
        current = UnparserRule(name='multiplicativeExpression', parent=parent)
        self.enter_rule(current)
        self.castExpression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    UnlexerRule(src='*', parent=current)
                elif choice == 1:
                    UnlexerRule(src='/', parent=current)
                elif choice == 2:
                    UnlexerRule(src='%', parent=current)
                self.castExpression(parent=current)
        self.exit_rule(current)
        return current
    multiplicativeExpression.min_depth = 3

    @depthcontrol
    def additiveExpression(self, parent=None):
        current = UnparserRule(name='additiveExpression', parent=parent)
        self.enter_rule(current)
        self.multiplicativeExpression(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='+', parent=current)
                elif choice == 1:
                    UnlexerRule(src='-', parent=current)
                self.multiplicativeExpression(parent=current)
        self.exit_rule(current)
        return current
    additiveExpression.min_depth = 4

    @depthcontrol
    def shiftExpression(self, parent=None):
        current = UnparserRule(name='shiftExpression', parent=parent)
        self.enter_rule(current)
        self.additiveExpression(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='<<', parent=current)
                elif choice == 1:
                    UnlexerRule(src='>>', parent=current)
                self.additiveExpression(parent=current)
        self.exit_rule(current)
        return current
    shiftExpression.min_depth = 5

    @depthcontrol
    def relationalExpression(self, parent=None):
        current = UnparserRule(name='relationalExpression', parent=parent)
        self.enter_rule(current)
        self.shiftExpression(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
                if choice == 0:
                    UnlexerRule(src='<', parent=current)
                elif choice == 1:
                    UnlexerRule(src='>', parent=current)
                elif choice == 2:
                    UnlexerRule(src='<=', parent=current)
                elif choice == 3:
                    UnlexerRule(src='>=', parent=current)
                self.shiftExpression(parent=current)
        self.exit_rule(current)
        return current
    relationalExpression.min_depth = 6

    @depthcontrol
    def equalityExpression(self, parent=None):
        current = UnparserRule(name='equalityExpression', parent=parent)
        self.enter_rule(current)
        self.relationalExpression(parent=current)
        if self.max_depth >= 7:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='==', parent=current)
                elif choice == 1:
                    UnlexerRule(src='!=', parent=current)
                self.relationalExpression(parent=current)
        self.exit_rule(current)
        return current
    equalityExpression.min_depth = 7

    @depthcontrol
    def andExpression(self, parent=None):
        current = UnparserRule(name='andExpression', parent=parent)
        self.enter_rule(current)
        self.equalityExpression(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src='&', parent=current)
                self.equalityExpression(parent=current)
        self.exit_rule(current)
        return current
    andExpression.min_depth = 8

    @depthcontrol
    def exclusiveOrExpression(self, parent=None):
        current = UnparserRule(name='exclusiveOrExpression', parent=parent)
        self.enter_rule(current)
        self.andExpression(parent=current)
        if self.max_depth >= 9:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src='^', parent=current)
                self.andExpression(parent=current)
        self.exit_rule(current)
        return current
    exclusiveOrExpression.min_depth = 9

    @depthcontrol
    def inclusiveOrExpression(self, parent=None):
        current = UnparserRule(name='inclusiveOrExpression', parent=parent)
        self.enter_rule(current)
        self.exclusiveOrExpression(parent=current)
        if self.max_depth >= 10:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src='|', parent=current)
                self.exclusiveOrExpression(parent=current)
        self.exit_rule(current)
        return current
    inclusiveOrExpression.min_depth = 10

    @depthcontrol
    def logicalAndExpression(self, parent=None):
        current = UnparserRule(name='logicalAndExpression', parent=parent)
        self.enter_rule(current)
        self.inclusiveOrExpression(parent=current)
        if self.max_depth >= 11:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src='&&', parent=current)
                self.inclusiveOrExpression(parent=current)
        self.exit_rule(current)
        return current
    logicalAndExpression.min_depth = 11

    @depthcontrol
    def logicalOrExpression(self, parent=None):
        current = UnparserRule(name='logicalOrExpression', parent=parent)
        self.enter_rule(current)
        self.logicalAndExpression(parent=current)
        if self.max_depth >= 12:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src='||', parent=current)
                self.logicalAndExpression(parent=current)
        self.exit_rule(current)
        return current
    logicalOrExpression.min_depth = 12

    @depthcontrol
    def conditionalExpression(self, parent=None):
        current = UnparserRule(name='conditionalExpression', parent=parent)
        self.enter_rule(current)
        self.logicalOrExpression(parent=current)
        if self.max_depth >= 14:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='?', parent=current)
                self.expression(parent=current)
                UnlexerRule(src=':', parent=current)
                self.conditionalExpression(parent=current)
        self.exit_rule(current)
        return current
    conditionalExpression.min_depth = 13

    @depthcontrol
    def assignmentExpression(self, parent=None):
        current = UnparserRule(name='assignmentExpression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [14, 4, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.conditionalExpression(parent=current)
        elif choice == 1:
            self.unaryExpression(parent=current)
            self.assignmentOperator(parent=current)
            self.assignmentExpression(parent=current)
        elif choice == 2:
            self.DigitSequence(parent=current)
        self.exit_rule(current)
        return current
    assignmentExpression.min_depth = 2

    @depthcontrol
    def assignmentOperator(self, parent=None):
        current = UnparserRule(name='assignmentOperator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='=', parent=current)
        elif choice == 1:
            UnlexerRule(src='*=', parent=current)
        elif choice == 2:
            UnlexerRule(src='/=', parent=current)
        elif choice == 3:
            UnlexerRule(src='%=', parent=current)
        elif choice == 4:
            UnlexerRule(src='+=', parent=current)
        elif choice == 5:
            UnlexerRule(src='-=', parent=current)
        elif choice == 6:
            UnlexerRule(src='<<=', parent=current)
        elif choice == 7:
            UnlexerRule(src='>>=', parent=current)
        elif choice == 8:
            UnlexerRule(src='&=', parent=current)
        elif choice == 9:
            UnlexerRule(src='^=', parent=current)
        elif choice == 10:
            UnlexerRule(src='|=', parent=current)
        self.exit_rule(current)
        return current
    assignmentOperator.min_depth = 0

    @depthcontrol
    def expression(self, parent=None):
        current = UnparserRule(name='expression', parent=parent)
        self.enter_rule(current)
        self.assignmentExpression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.assignmentExpression(parent=current)
        self.exit_rule(current)
        return current
    expression.min_depth = 3

    @depthcontrol
    def constantExpression(self, parent=None):
        current = UnparserRule(name='constantExpression', parent=parent)
        self.enter_rule(current)
        self.conditionalExpression(parent=current)
        self.exit_rule(current)
        return current
    constantExpression.min_depth = 14

    @depthcontrol
    def declaration(self, parent=None):
        current = UnparserRule(name='declaration', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 16][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.declarationSpecifiers(parent=current)
            if self.max_depth >= 7:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.initDeclaratorList(parent=current)
            UnlexerRule(src=';', parent=current)
        elif choice == 1:
            self.staticAssertDeclaration(parent=current)
        self.exit_rule(current)
        return current
    declaration.min_depth = 3

    @depthcontrol
    def declarationSpecifiers(self, parent=None):
        current = UnparserRule(name='declarationSpecifiers', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.declarationSpecifier(parent=current)
        self.exit_rule(current)
        return current
    declarationSpecifiers.min_depth = 2

    @depthcontrol
    def declarationSpecifiers2(self, parent=None):
        current = UnparserRule(name='declarationSpecifiers2', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.declarationSpecifier(parent=current)
        self.exit_rule(current)
        return current
    declarationSpecifiers2.min_depth = 2

    @depthcontrol
    def declarationSpecifier(self, parent=None):
        current = UnparserRule(name='declarationSpecifier', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 4][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            self.storageClassSpecifier(parent=current)
        elif choice == 1:
            self.typeSpecifier(parent=current)
        elif choice == 2:
            self.typeQualifier(parent=current)
        elif choice == 3:
            self.functionSpecifier(parent=current)
        elif choice == 4:
            self.alignmentSpecifier(parent=current)
        self.exit_rule(current)
        return current
    declarationSpecifier.min_depth = 1

    @depthcontrol
    def initDeclaratorList(self, parent=None):
        current = UnparserRule(name='initDeclaratorList', parent=parent)
        self.enter_rule(current)
        self.initDeclarator(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.initDeclarator(parent=current)
        self.exit_rule(current)
        return current
    initDeclaratorList.min_depth = 6

    @depthcontrol
    def initDeclarator(self, parent=None):
        current = UnparserRule(name='initDeclarator', parent=parent)
        self.enter_rule(current)
        self.declarator(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
                self.initializer(parent=current)
        self.exit_rule(current)
        return current
    initDeclarator.min_depth = 5

    @depthcontrol
    def storageClassSpecifier(self, parent=None):
        current = UnparserRule(name='storageClassSpecifier', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='typedef', parent=current)
        elif choice == 1:
            UnlexerRule(src='extern', parent=current)
        elif choice == 2:
            UnlexerRule(src='static', parent=current)
        elif choice == 3:
            UnlexerRule(src='_Thread_local', parent=current)
        elif choice == 4:
            UnlexerRule(src='auto', parent=current)
        elif choice == 5:
            UnlexerRule(src='register', parent=current)
        self.exit_rule(current)
        return current
    storageClassSpecifier.min_depth = 0

    @depthcontrol
    def typeSpecifier(self, parent=None):
        current = UnparserRule(name='typeSpecifier', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 4, 4, 4, 4, 15, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            choice = self.model.choice(current, 1, [0 if [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
            if choice == 0:
                UnlexerRule(src='void', parent=current)
            elif choice == 1:
                UnlexerRule(src='char', parent=current)
            elif choice == 2:
                UnlexerRule(src='short', parent=current)
            elif choice == 3:
                UnlexerRule(src='int', parent=current)
            elif choice == 4:
                UnlexerRule(src='long', parent=current)
            elif choice == 5:
                UnlexerRule(src='float', parent=current)
            elif choice == 6:
                UnlexerRule(src='double', parent=current)
            elif choice == 7:
                UnlexerRule(src='signed', parent=current)
            elif choice == 8:
                UnlexerRule(src='unsigned', parent=current)
            elif choice == 9:
                UnlexerRule(src='_Bool', parent=current)
            elif choice == 10:
                UnlexerRule(src='_Complex', parent=current)
            elif choice == 11:
                UnlexerRule(src='__m128', parent=current)
            elif choice == 12:
                UnlexerRule(src='__m128d', parent=current)
            elif choice == 13:
                UnlexerRule(src='__m128i', parent=current)
        elif choice == 1:
            UnlexerRule(src='__extension__', parent=current)
            UnlexerRule(src='(', parent=current)
            choice = self.model.choice(current, 2, [0 if [0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
            if choice == 0:
                UnlexerRule(src='__m128', parent=current)
            elif choice == 1:
                UnlexerRule(src='__m128d', parent=current)
            elif choice == 2:
                UnlexerRule(src='__m128i', parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 2:
            self.atomicTypeSpecifier(parent=current)
        elif choice == 3:
            self.structOrUnionSpecifier(parent=current)
        elif choice == 4:
            self.enumSpecifier(parent=current)
        elif choice == 5:
            self.typedefName(parent=current)
        elif choice == 6:
            UnlexerRule(src='__typeof__', parent=current)
            UnlexerRule(src='(', parent=current)
            self.constantExpression(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 7:
            self.typeSpecifier(parent=current)
            self.pointer(parent=current)
        self.exit_rule(current)
        return current
    typeSpecifier.min_depth = 0

    @depthcontrol
    def structOrUnionSpecifier(self, parent=None):
        current = UnparserRule(name='structOrUnionSpecifier', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.structOrUnion(parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.Identifier(parent=current)
            UnlexerRule(src='{', parent=current)
            self.structDeclarationList(parent=current)
            UnlexerRule(src='}', parent=current)
        elif choice == 1:
            self.structOrUnion(parent=current)
            self.Identifier(parent=current)
        self.exit_rule(current)
        return current
    structOrUnionSpecifier.min_depth = 3

    @depthcontrol
    def structOrUnion(self, parent=None):
        current = UnparserRule(name='structOrUnion', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='struct', parent=current)
        elif choice == 1:
            UnlexerRule(src='union', parent=current)
        self.exit_rule(current)
        return current
    structOrUnion.min_depth = 0

    @depthcontrol
    def structDeclarationList(self, parent=None):
        current = UnparserRule(name='structDeclarationList', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.structDeclaration(parent=current)
        self.exit_rule(current)
        return current
    structDeclarationList.min_depth = 3

    @depthcontrol
    def structDeclaration(self, parent=None):
        current = UnparserRule(name='structDeclaration', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 16][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.specifierQualifierList(parent=current)
            if self.max_depth >= 7:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.structDeclaratorList(parent=current)
            UnlexerRule(src=';', parent=current)
        elif choice == 1:
            self.staticAssertDeclaration(parent=current)
        self.exit_rule(current)
        return current
    structDeclaration.min_depth = 2

    @depthcontrol
    def specifierQualifierList(self, parent=None):
        current = UnparserRule(name='specifierQualifierList', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.typeSpecifier(parent=current)
        elif choice == 1:
            self.typeQualifier(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.specifierQualifierList(parent=current)
        self.exit_rule(current)
        return current
    specifierQualifierList.min_depth = 1

    @depthcontrol
    def structDeclaratorList(self, parent=None):
        current = UnparserRule(name='structDeclaratorList', parent=parent)
        self.enter_rule(current)
        self.structDeclarator(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.structDeclarator(parent=current)
        self.exit_rule(current)
        return current
    structDeclaratorList.min_depth = 6

    @depthcontrol
    def structDeclarator(self, parent=None):
        current = UnparserRule(name='structDeclarator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 15][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.declarator(parent=current)
        elif choice == 1:
            if self.max_depth >= 5:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.declarator(parent=current)
            UnlexerRule(src=':', parent=current)
            self.constantExpression(parent=current)
        self.exit_rule(current)
        return current
    structDeclarator.min_depth = 5

    @depthcontrol
    def enumSpecifier(self, parent=None):
        current = UnparserRule(name='enumSpecifier', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [6, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='enum', parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.Identifier(parent=current)
            UnlexerRule(src='{', parent=current)
            self.enumeratorList(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    UnlexerRule(src=',', parent=current)
            UnlexerRule(src='}', parent=current)
        elif choice == 1:
            UnlexerRule(src='enum', parent=current)
            self.Identifier(parent=current)
        self.exit_rule(current)
        return current
    enumSpecifier.min_depth = 3

    @depthcontrol
    def enumeratorList(self, parent=None):
        current = UnparserRule(name='enumeratorList', parent=parent)
        self.enter_rule(current)
        self.enumerator(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.enumerator(parent=current)
        self.exit_rule(current)
        return current
    enumeratorList.min_depth = 5

    @depthcontrol
    def enumerator(self, parent=None):
        current = UnparserRule(name='enumerator', parent=parent)
        self.enter_rule(current)
        self.enumerationConstant(parent=current)
        if self.max_depth >= 15:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='=', parent=current)
                self.constantExpression(parent=current)
        self.exit_rule(current)
        return current
    enumerator.min_depth = 4

    @depthcontrol
    def enumerationConstant(self, parent=None):
        current = UnparserRule(name='enumerationConstant', parent=parent)
        self.enter_rule(current)
        self.Identifier(parent=current)
        self.exit_rule(current)
        return current
    enumerationConstant.min_depth = 3

    @depthcontrol
    def atomicTypeSpecifier(self, parent=None):
        current = UnparserRule(name='atomicTypeSpecifier', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='_Atomic', parent=current)
        UnlexerRule(src='(', parent=current)
        self.typeName(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    atomicTypeSpecifier.min_depth = 3

    @depthcontrol
    def typeQualifier(self, parent=None):
        current = UnparserRule(name='typeQualifier', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='const', parent=current)
        elif choice == 1:
            UnlexerRule(src='restrict', parent=current)
        elif choice == 2:
            UnlexerRule(src='volatile', parent=current)
        elif choice == 3:
            UnlexerRule(src='_Atomic', parent=current)
        self.exit_rule(current)
        return current
    typeQualifier.min_depth = 0

    @depthcontrol
    def functionSpecifier(self, parent=None):
        current = UnparserRule(name='functionSpecifier', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            choice = self.model.choice(current, 1, [0 if [0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
            if choice == 0:
                UnlexerRule(src='inline', parent=current)
            elif choice == 1:
                UnlexerRule(src='_Noreturn', parent=current)
            elif choice == 2:
                UnlexerRule(src='__inline__', parent=current)
            elif choice == 3:
                UnlexerRule(src='__stdcall', parent=current)
        elif choice == 1:
            self.gccAttributeSpecifier(parent=current)
        elif choice == 2:
            UnlexerRule(src='__declspec', parent=current)
            UnlexerRule(src='(', parent=current)
            self.Identifier(parent=current)
            UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    functionSpecifier.min_depth = 0

    @depthcontrol
    def alignmentSpecifier(self, parent=None):
        current = UnparserRule(name='alignmentSpecifier', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='_Alignas', parent=current)
        UnlexerRule(src='(', parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 15][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.typeName(parent=current)
        elif choice == 1:
            self.constantExpression(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    alignmentSpecifier.min_depth = 3

    @depthcontrol
    def declarator(self, parent=None):
        current = UnparserRule(name='declarator', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.pointer(parent=current)
        self.directDeclarator(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                self.gccDeclaratorExtension(parent=current)
        self.exit_rule(current)
        return current
    declarator.min_depth = 4

    @depthcontrol
    def directDeclarator(self, parent=None):
        current = UnparserRule(name='directDeclarator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 5, 4, 4, 4, 4, 6, 4, 3, 4][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.Identifier(parent=current)
        elif choice == 1:
            UnlexerRule(src='(', parent=current)
            self.declarator(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 2:
            self.directDeclarator(parent=current)
            UnlexerRule(src='[', parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.typeQualifierList(parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    self.assignmentExpression(parent=current)
            UnlexerRule(src=']', parent=current)
        elif choice == 3:
            self.directDeclarator(parent=current)
            UnlexerRule(src='[', parent=current)
            UnlexerRule(src='static', parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    self.typeQualifierList(parent=current)
            self.assignmentExpression(parent=current)
            UnlexerRule(src=']', parent=current)
        elif choice == 4:
            self.directDeclarator(parent=current)
            UnlexerRule(src='[', parent=current)
            self.typeQualifierList(parent=current)
            UnlexerRule(src='static', parent=current)
            self.assignmentExpression(parent=current)
            UnlexerRule(src=']', parent=current)
        elif choice == 5:
            self.directDeclarator(parent=current)
            UnlexerRule(src='[', parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 3, min=0, max=1):
                    self.typeQualifierList(parent=current)
            UnlexerRule(src='*', parent=current)
            UnlexerRule(src=']', parent=current)
        elif choice == 6:
            self.directDeclarator(parent=current)
            UnlexerRule(src='(', parent=current)
            self.parameterTypeList(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 7:
            self.directDeclarator(parent=current)
            UnlexerRule(src='(', parent=current)
            if self.max_depth >= 4:
                for _ in self.model.quantify(current, 4, min=0, max=1):
                    self.identifierList(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 8:
            self.Identifier(parent=current)
            UnlexerRule(src=':', parent=current)
            self.DigitSequence(parent=current)
        elif choice == 9:
            UnlexerRule(src='(', parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 5, min=0, max=1):
                    self.typeSpecifier(parent=current)
            self.pointer(parent=current)
            self.directDeclarator(parent=current)
            UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    directDeclarator.min_depth = 3

    @depthcontrol
    def gccDeclaratorExtension(self, parent=None):
        current = UnparserRule(name='gccDeclaratorExtension', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='__asm', parent=current)
            UnlexerRule(src='(', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=1, max=inf):
                    self.StringLiteral(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 1:
            self.gccAttributeSpecifier(parent=current)
        self.exit_rule(current)
        return current
    gccDeclaratorExtension.min_depth = 1

    @depthcontrol
    def gccAttributeSpecifier(self, parent=None):
        current = UnparserRule(name='gccAttributeSpecifier', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='__attribute__', parent=current)
        UnlexerRule(src='(', parent=current)
        UnlexerRule(src='(', parent=current)
        self.gccAttributeList(parent=current)
        UnlexerRule(src=')', parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    gccAttributeSpecifier.min_depth = 1

    @depthcontrol
    def gccAttributeList(self, parent=None):
        current = UnparserRule(name='gccAttributeList', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.gccAttribute(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                if self.max_depth >= 1:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        self.gccAttribute(parent=current)
        self.exit_rule(current)
        return current
    gccAttributeList.min_depth = 0

    @depthcontrol
    def gccAttribute(self, parent=None):
        current = UnparserRule(name='gccAttribute', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[1]), parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='(', parent=current)
                if self.max_depth >= 4:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.argumentExpressionList(parent=current)
                UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    gccAttribute.min_depth = 0

    @depthcontrol
    def nestedParenthesesBlock(self, parent=None):
        current = UnparserRule(name='nestedParenthesesBlock', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src=self.model.charset(current, 0, self._charsets[2]), parent=current)
                elif choice == 1:
                    UnlexerRule(src='(', parent=current)
                    self.nestedParenthesesBlock(parent=current)
                    UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    nestedParenthesesBlock.min_depth = 0

    @depthcontrol
    def pointer(self, parent=None):
        current = UnparserRule(name='pointer', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='*', parent=current)
                elif choice == 1:
                    UnlexerRule(src='^', parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.typeQualifierList(parent=current)
        self.exit_rule(current)
        return current
    pointer.min_depth = 0

    @depthcontrol
    def typeQualifierList(self, parent=None):
        current = UnparserRule(name='typeQualifierList', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.typeQualifier(parent=current)
        self.exit_rule(current)
        return current
    typeQualifierList.min_depth = 1

    @depthcontrol
    def parameterTypeList(self, parent=None):
        current = UnparserRule(name='parameterTypeList', parent=parent)
        self.enter_rule(current)
        self.parameterList(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src=',', parent=current)
                UnlexerRule(src='...', parent=current)
        self.exit_rule(current)
        return current
    parameterTypeList.min_depth = 5

    @depthcontrol
    def parameterList(self, parent=None):
        current = UnparserRule(name='parameterList', parent=parent)
        self.enter_rule(current)
        self.parameterDeclaration(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.parameterDeclaration(parent=current)
        self.exit_rule(current)
        return current
    parameterList.min_depth = 4

    @depthcontrol
    def parameterDeclaration(self, parent=None):
        current = UnparserRule(name='parameterDeclaration', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.declarationSpecifiers(parent=current)
            self.declarator(parent=current)
        elif choice == 1:
            self.declarationSpecifiers2(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.abstractDeclarator(parent=current)
        self.exit_rule(current)
        return current
    parameterDeclaration.min_depth = 3

    @depthcontrol
    def identifierList(self, parent=None):
        current = UnparserRule(name='identifierList', parent=parent)
        self.enter_rule(current)
        self.Identifier(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.Identifier(parent=current)
        self.exit_rule(current)
        return current
    identifierList.min_depth = 3

    @depthcontrol
    def typeName(self, parent=None):
        current = UnparserRule(name='typeName', parent=parent)
        self.enter_rule(current)
        self.specifierQualifierList(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.abstractDeclarator(parent=current)
        self.exit_rule(current)
        return current
    typeName.min_depth = 2

    @depthcontrol
    def abstractDeclarator(self, parent=None):
        current = UnparserRule(name='abstractDeclarator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.pointer(parent=current)
        elif choice == 1:
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.pointer(parent=current)
            self.directAbstractDeclarator(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 1, min=0, max=inf):
                    self.gccDeclaratorExtension(parent=current)
        self.exit_rule(current)
        return current
    abstractDeclarator.min_depth = 1

    @depthcontrol
    def directAbstractDeclarator(self, parent=None):
        current = UnparserRule(name='directAbstractDeclarator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 0, 3, 3, 0, 0, 1, 3, 3, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='(', parent=current)
            self.abstractDeclarator(parent=current)
            UnlexerRule(src=')', parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    self.gccDeclaratorExtension(parent=current)
        elif choice == 1:
            UnlexerRule(src='[', parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    self.typeQualifierList(parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    self.assignmentExpression(parent=current)
            UnlexerRule(src=']', parent=current)
        elif choice == 2:
            UnlexerRule(src='[', parent=current)
            UnlexerRule(src='static', parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 3, min=0, max=1):
                    self.typeQualifierList(parent=current)
            self.assignmentExpression(parent=current)
            UnlexerRule(src=']', parent=current)
        elif choice == 3:
            UnlexerRule(src='[', parent=current)
            self.typeQualifierList(parent=current)
            UnlexerRule(src='static', parent=current)
            self.assignmentExpression(parent=current)
            UnlexerRule(src=']', parent=current)
        elif choice == 4:
            UnlexerRule(src='[', parent=current)
            UnlexerRule(src='*', parent=current)
            UnlexerRule(src=']', parent=current)
        elif choice == 5:
            UnlexerRule(src='(', parent=current)
            if self.max_depth >= 6:
                for _ in self.model.quantify(current, 4, min=0, max=1):
                    self.parameterTypeList(parent=current)
            UnlexerRule(src=')', parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 5, min=0, max=inf):
                    self.gccDeclaratorExtension(parent=current)
        elif choice == 6:
            self.directAbstractDeclarator(parent=current)
            UnlexerRule(src='[', parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 6, min=0, max=1):
                    self.typeQualifierList(parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 7, min=0, max=1):
                    self.assignmentExpression(parent=current)
            UnlexerRule(src=']', parent=current)
        elif choice == 7:
            self.directAbstractDeclarator(parent=current)
            UnlexerRule(src='[', parent=current)
            UnlexerRule(src='static', parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 8, min=0, max=1):
                    self.typeQualifierList(parent=current)
            self.assignmentExpression(parent=current)
            UnlexerRule(src=']', parent=current)
        elif choice == 8:
            self.directAbstractDeclarator(parent=current)
            UnlexerRule(src='[', parent=current)
            self.typeQualifierList(parent=current)
            UnlexerRule(src='static', parent=current)
            self.assignmentExpression(parent=current)
            UnlexerRule(src=']', parent=current)
        elif choice == 9:
            self.directAbstractDeclarator(parent=current)
            UnlexerRule(src='[', parent=current)
            UnlexerRule(src='*', parent=current)
            UnlexerRule(src=']', parent=current)
        elif choice == 10:
            self.directAbstractDeclarator(parent=current)
            UnlexerRule(src='(', parent=current)
            if self.max_depth >= 6:
                for _ in self.model.quantify(current, 9, min=0, max=1):
                    self.parameterTypeList(parent=current)
            UnlexerRule(src=')', parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 10, min=0, max=inf):
                    self.gccDeclaratorExtension(parent=current)
        self.exit_rule(current)
        return current
    directAbstractDeclarator.min_depth = 0

    @depthcontrol
    def typedefName(self, parent=None):
        current = UnparserRule(name='typedefName', parent=parent)
        self.enter_rule(current)
        self.Identifier(parent=current)
        self.exit_rule(current)
        return current
    typedefName.min_depth = 3

    @depthcontrol
    def initializer(self, parent=None):
        current = UnparserRule(name='initializer', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 5][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.assignmentExpression(parent=current)
        elif choice == 1:
            UnlexerRule(src='{', parent=current)
            self.initializerList(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src=',', parent=current)
            UnlexerRule(src='}', parent=current)
        self.exit_rule(current)
        return current
    initializer.min_depth = 3

    @depthcontrol
    def initializerList(self, parent=None):
        current = UnparserRule(name='initializerList', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.designation(parent=current)
        self.initializer(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                if self.max_depth >= 6:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        self.designation(parent=current)
                self.initializer(parent=current)
        self.exit_rule(current)
        return current
    initializerList.min_depth = 4

    @depthcontrol
    def designation(self, parent=None):
        current = UnparserRule(name='designation', parent=parent)
        self.enter_rule(current)
        self.designatorList(parent=current)
        UnlexerRule(src='=', parent=current)
        self.exit_rule(current)
        return current
    designation.min_depth = 5

    @depthcontrol
    def designatorList(self, parent=None):
        current = UnparserRule(name='designatorList', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.designator(parent=current)
        self.exit_rule(current)
        return current
    designatorList.min_depth = 4

    @depthcontrol
    def designator(self, parent=None):
        current = UnparserRule(name='designator', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [15, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='[', parent=current)
            self.constantExpression(parent=current)
            UnlexerRule(src=']', parent=current)
        elif choice == 1:
            UnlexerRule(src='.', parent=current)
            self.Identifier(parent=current)
        self.exit_rule(current)
        return current
    designator.min_depth = 3

    @depthcontrol
    def staticAssertDeclaration(self, parent=None):
        current = UnparserRule(name='staticAssertDeclaration', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='_Static_assert', parent=current)
        UnlexerRule(src='(', parent=current)
        self.constantExpression(parent=current)
        UnlexerRule(src=',', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.StringLiteral(parent=current)
        UnlexerRule(src=')', parent=current)
        UnlexerRule(src=';', parent=current)
        self.exit_rule(current)
        return current
    staticAssertDeclaration.min_depth = 15

    @depthcontrol
    def statement(self, parent=None):
        current = UnparserRule(name='statement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 1, 1, 5, 2, 1, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.labeledStatement(parent=current)
        elif choice == 1:
            self.compoundStatement(parent=current)
        elif choice == 2:
            self.expressionStatement(parent=current)
        elif choice == 3:
            self.selectionStatement(parent=current)
        elif choice == 4:
            self.iterationStatement(parent=current)
        elif choice == 5:
            self.jumpStatement(parent=current)
        elif choice == 6:
            choice = self.model.choice(current, 1, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                UnlexerRule(src='__asm', parent=current)
            elif choice == 1:
                UnlexerRule(src='__asm__', parent=current)
            choice = self.model.choice(current, 2, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                UnlexerRule(src='volatile', parent=current)
            elif choice == 1:
                UnlexerRule(src='__volatile__', parent=current)
            UnlexerRule(src='(', parent=current)
            if self.max_depth >= 13:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.logicalOrExpression(parent=current)
                    if self.max_depth >= 13:
                        for _ in self.model.quantify(current, 1, min=0, max=inf):
                            UnlexerRule(src=',', parent=current)
                            self.logicalOrExpression(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 2, min=0, max=inf):
                    UnlexerRule(src=':', parent=current)
                    if self.max_depth >= 13:
                        for _ in self.model.quantify(current, 3, min=0, max=1):
                            self.logicalOrExpression(parent=current)
                            if self.max_depth >= 13:
                                for _ in self.model.quantify(current, 4, min=0, max=inf):
                                    UnlexerRule(src=',', parent=current)
                                    self.logicalOrExpression(parent=current)
            UnlexerRule(src=')', parent=current)
            UnlexerRule(src=';', parent=current)
        self.exit_rule(current)
        return current
    statement.min_depth = 0

    @depthcontrol
    def labeledStatement(self, parent=None):
        current = UnparserRule(name='labeledStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 15, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.Identifier(parent=current)
            UnlexerRule(src=':', parent=current)
            self.statement(parent=current)
        elif choice == 1:
            UnlexerRule(src='case', parent=current)
            self.constantExpression(parent=current)
            UnlexerRule(src=':', parent=current)
            self.statement(parent=current)
        elif choice == 2:
            UnlexerRule(src='default', parent=current)
            UnlexerRule(src=':', parent=current)
            self.statement(parent=current)
        self.exit_rule(current)
        return current
    labeledStatement.min_depth = 1

    @depthcontrol
    def compoundStatement(self, parent=None):
        current = UnparserRule(name='compoundStatement', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='{', parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.blockItemList(parent=current)
        UnlexerRule(src='}', parent=current)
        self.exit_rule(current)
        return current
    compoundStatement.min_depth = 0

    @depthcontrol
    def blockItemList(self, parent=None):
        current = UnparserRule(name='blockItemList', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.blockItem(parent=current)
        self.exit_rule(current)
        return current
    blockItemList.min_depth = 2

    @depthcontrol
    def blockItem(self, parent=None):
        current = UnparserRule(name='blockItem', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.statement(parent=current)
        elif choice == 1:
            self.declaration(parent=current)
        self.exit_rule(current)
        return current
    blockItem.min_depth = 1

    @depthcontrol
    def expressionStatement(self, parent=None):
        current = UnparserRule(name='expressionStatement', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.expression(parent=current)
        UnlexerRule(src=';', parent=current)
        self.exit_rule(current)
        return current
    expressionStatement.min_depth = 0

    @depthcontrol
    def selectionStatement(self, parent=None):
        current = UnparserRule(name='selectionStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='if', parent=current)
            UnlexerRule(src='(', parent=current)
            self.expression(parent=current)
            UnlexerRule(src=')', parent=current)
            self.statement(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src='else', parent=current)
                    self.statement(parent=current)
        elif choice == 1:
            UnlexerRule(src='switch', parent=current)
            UnlexerRule(src='(', parent=current)
            self.expression(parent=current)
            UnlexerRule(src=')', parent=current)
            self.statement(parent=current)
        self.exit_rule(current)
        return current
    selectionStatement.min_depth = 4

    @depthcontrol
    def iterationStatement(self, parent=None):
        current = UnparserRule(name='iterationStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 4, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.While(parent=current)
            UnlexerRule(src='(', parent=current)
            self.expression(parent=current)
            UnlexerRule(src=')', parent=current)
            self.statement(parent=current)
        elif choice == 1:
            self.Do(parent=current)
            self.statement(parent=current)
            self.While(parent=current)
            UnlexerRule(src='(', parent=current)
            self.expression(parent=current)
            UnlexerRule(src=')', parent=current)
            UnlexerRule(src=';', parent=current)
        elif choice == 2:
            self.For(parent=current)
            UnlexerRule(src='(', parent=current)
            self.forCondition(parent=current)
            UnlexerRule(src=')', parent=current)
            self.statement(parent=current)
        self.exit_rule(current)
        return current
    iterationStatement.min_depth = 1

    @depthcontrol
    def forCondition(self, parent=None):
        current = UnparserRule(name='forCondition', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.forDeclaration(parent=current)
        elif choice == 1:
            if self.max_depth >= 4:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.expression(parent=current)
        UnlexerRule(src=';', parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.forExpression(parent=current)
        UnlexerRule(src=';', parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.forExpression(parent=current)
        self.exit_rule(current)
        return current
    forCondition.min_depth = 0

    @depthcontrol
    def forDeclaration(self, parent=None):
        current = UnparserRule(name='forDeclaration', parent=parent)
        self.enter_rule(current)
        self.declarationSpecifiers(parent=current)
        if self.max_depth >= 7:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.initDeclaratorList(parent=current)
        self.exit_rule(current)
        return current
    forDeclaration.min_depth = 3

    @depthcontrol
    def forExpression(self, parent=None):
        current = UnparserRule(name='forExpression', parent=parent)
        self.enter_rule(current)
        self.assignmentExpression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.assignmentExpression(parent=current)
        self.exit_rule(current)
        return current
    forExpression.min_depth = 3

    @depthcontrol
    def jumpStatement(self, parent=None):
        current = UnparserRule(name='jumpStatement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 0, 0, 4][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='goto', parent=current)
            self.Identifier(parent=current)
        elif choice == 1:
            choice = self.model.choice(current, 1, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                UnlexerRule(src='continue', parent=current)
            elif choice == 1:
                UnlexerRule(src='break', parent=current)
        elif choice == 2:
            UnlexerRule(src='return', parent=current)
            if self.max_depth >= 4:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.expression(parent=current)
        elif choice == 3:
            UnlexerRule(src='goto', parent=current)
            self.unaryExpression(parent=current)
        UnlexerRule(src=';', parent=current)
        self.exit_rule(current)
        return current
    jumpStatement.min_depth = 0

    @depthcontrol
    def compilationUnit(self, parent=None):
        current = UnparserRule(name='compilationUnit', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.translationUnit(parent=current)
        self.EOF(parent=current)
        self.exit_rule(current)
        return current
    compilationUnit.min_depth = 1

    @depthcontrol
    def translationUnit(self, parent=None):
        current = UnparserRule(name='translationUnit', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.externalDeclaration(parent=current)
        self.exit_rule(current)
        return current
    translationUnit.min_depth = 1

    @depthcontrol
    def externalDeclaration(self, parent=None):
        current = UnparserRule(name='externalDeclaration', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [6, 4, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.functionDefinition(parent=current)
        elif choice == 1:
            self.declaration(parent=current)
        elif choice == 2:
            UnlexerRule(src=';', parent=current)
        self.exit_rule(current)
        return current
    externalDeclaration.min_depth = 0

    @depthcontrol
    def functionDefinition(self, parent=None):
        current = UnparserRule(name='functionDefinition', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.declarationSpecifiers(parent=current)
        self.declarator(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.declarationList(parent=current)
        self.compoundStatement(parent=current)
        self.exit_rule(current)
        return current
    functionDefinition.min_depth = 5

    @depthcontrol
    def declarationList(self, parent=None):
        current = UnparserRule(name='declarationList', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.declaration(parent=current)
        self.exit_rule(current)
        return current
    declarationList.min_depth = 4

    @depthcontrol
    def Auto(self, parent=None):
        current = UnlexerRule(name='Auto', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='auto', parent=current)
        self.exit_rule(current)
        return current
    Auto.min_depth = 0

    @depthcontrol
    def Break(self, parent=None):
        current = UnlexerRule(name='Break', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='break', parent=current)
        self.exit_rule(current)
        return current
    Break.min_depth = 0

    @depthcontrol
    def Case(self, parent=None):
        current = UnlexerRule(name='Case', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='case', parent=current)
        self.exit_rule(current)
        return current
    Case.min_depth = 0

    @depthcontrol
    def Char(self, parent=None):
        current = UnlexerRule(name='Char', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='char', parent=current)
        self.exit_rule(current)
        return current
    Char.min_depth = 0

    @depthcontrol
    def Const(self, parent=None):
        current = UnlexerRule(name='Const', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='const', parent=current)
        self.exit_rule(current)
        return current
    Const.min_depth = 0

    @depthcontrol
    def Continue(self, parent=None):
        current = UnlexerRule(name='Continue', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='continue', parent=current)
        self.exit_rule(current)
        return current
    Continue.min_depth = 0

    @depthcontrol
    def Default(self, parent=None):
        current = UnlexerRule(name='Default', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='default', parent=current)
        self.exit_rule(current)
        return current
    Default.min_depth = 0

    @depthcontrol
    def Do(self, parent=None):
        current = UnlexerRule(name='Do', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='do', parent=current)
        self.exit_rule(current)
        return current
    Do.min_depth = 0

    @depthcontrol
    def Double(self, parent=None):
        current = UnlexerRule(name='Double', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='double', parent=current)
        self.exit_rule(current)
        return current
    Double.min_depth = 0

    @depthcontrol
    def Else(self, parent=None):
        current = UnlexerRule(name='Else', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='else', parent=current)
        self.exit_rule(current)
        return current
    Else.min_depth = 0

    @depthcontrol
    def Enum(self, parent=None):
        current = UnlexerRule(name='Enum', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='enum', parent=current)
        self.exit_rule(current)
        return current
    Enum.min_depth = 0

    @depthcontrol
    def Extern(self, parent=None):
        current = UnlexerRule(name='Extern', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='extern', parent=current)
        self.exit_rule(current)
        return current
    Extern.min_depth = 0

    @depthcontrol
    def Float(self, parent=None):
        current = UnlexerRule(name='Float', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='float', parent=current)
        self.exit_rule(current)
        return current
    Float.min_depth = 0

    @depthcontrol
    def For(self, parent=None):
        current = UnlexerRule(name='For', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='for', parent=current)
        self.exit_rule(current)
        return current
    For.min_depth = 0

    @depthcontrol
    def Goto(self, parent=None):
        current = UnlexerRule(name='Goto', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='goto', parent=current)
        self.exit_rule(current)
        return current
    Goto.min_depth = 0

    @depthcontrol
    def If(self, parent=None):
        current = UnlexerRule(name='If', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='if', parent=current)
        self.exit_rule(current)
        return current
    If.min_depth = 0

    @depthcontrol
    def Inline(self, parent=None):
        current = UnlexerRule(name='Inline', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='inline', parent=current)
        self.exit_rule(current)
        return current
    Inline.min_depth = 0

    @depthcontrol
    def Int(self, parent=None):
        current = UnlexerRule(name='Int', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='int', parent=current)
        self.exit_rule(current)
        return current
    Int.min_depth = 0

    @depthcontrol
    def Long(self, parent=None):
        current = UnlexerRule(name='Long', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='long', parent=current)
        self.exit_rule(current)
        return current
    Long.min_depth = 0

    @depthcontrol
    def Register(self, parent=None):
        current = UnlexerRule(name='Register', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='register', parent=current)
        self.exit_rule(current)
        return current
    Register.min_depth = 0

    @depthcontrol
    def Restrict(self, parent=None):
        current = UnlexerRule(name='Restrict', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='restrict', parent=current)
        self.exit_rule(current)
        return current
    Restrict.min_depth = 0

    @depthcontrol
    def Return(self, parent=None):
        current = UnlexerRule(name='Return', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='return', parent=current)
        self.exit_rule(current)
        return current
    Return.min_depth = 0

    @depthcontrol
    def Short(self, parent=None):
        current = UnlexerRule(name='Short', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='short', parent=current)
        self.exit_rule(current)
        return current
    Short.min_depth = 0

    @depthcontrol
    def Signed(self, parent=None):
        current = UnlexerRule(name='Signed', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='signed', parent=current)
        self.exit_rule(current)
        return current
    Signed.min_depth = 0

    @depthcontrol
    def Sizeof(self, parent=None):
        current = UnlexerRule(name='Sizeof', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='sizeof', parent=current)
        self.exit_rule(current)
        return current
    Sizeof.min_depth = 0

    @depthcontrol
    def Static(self, parent=None):
        current = UnlexerRule(name='Static', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='static', parent=current)
        self.exit_rule(current)
        return current
    Static.min_depth = 0

    @depthcontrol
    def Struct(self, parent=None):
        current = UnlexerRule(name='Struct', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='struct', parent=current)
        self.exit_rule(current)
        return current
    Struct.min_depth = 0

    @depthcontrol
    def Switch(self, parent=None):
        current = UnlexerRule(name='Switch', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='switch', parent=current)
        self.exit_rule(current)
        return current
    Switch.min_depth = 0

    @depthcontrol
    def Typedef(self, parent=None):
        current = UnlexerRule(name='Typedef', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='typedef', parent=current)
        self.exit_rule(current)
        return current
    Typedef.min_depth = 0

    @depthcontrol
    def Union(self, parent=None):
        current = UnlexerRule(name='Union', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='union', parent=current)
        self.exit_rule(current)
        return current
    Union.min_depth = 0

    @depthcontrol
    def Unsigned(self, parent=None):
        current = UnlexerRule(name='Unsigned', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='unsigned', parent=current)
        self.exit_rule(current)
        return current
    Unsigned.min_depth = 0

    @depthcontrol
    def Void(self, parent=None):
        current = UnlexerRule(name='Void', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='void', parent=current)
        self.exit_rule(current)
        return current
    Void.min_depth = 0

    @depthcontrol
    def Volatile(self, parent=None):
        current = UnlexerRule(name='Volatile', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='volatile', parent=current)
        self.exit_rule(current)
        return current
    Volatile.min_depth = 0

    @depthcontrol
    def While(self, parent=None):
        current = UnlexerRule(name='While', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='while', parent=current)
        self.exit_rule(current)
        return current
    While.min_depth = 0

    @depthcontrol
    def Alignas(self, parent=None):
        current = UnlexerRule(name='Alignas', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='_Alignas', parent=current)
        self.exit_rule(current)
        return current
    Alignas.min_depth = 0

    @depthcontrol
    def Alignof(self, parent=None):
        current = UnlexerRule(name='Alignof', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='_Alignof', parent=current)
        self.exit_rule(current)
        return current
    Alignof.min_depth = 0

    @depthcontrol
    def Atomic(self, parent=None):
        current = UnlexerRule(name='Atomic', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='_Atomic', parent=current)
        self.exit_rule(current)
        return current
    Atomic.min_depth = 0

    @depthcontrol
    def Bool(self, parent=None):
        current = UnlexerRule(name='Bool', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='_Bool', parent=current)
        self.exit_rule(current)
        return current
    Bool.min_depth = 0

    @depthcontrol
    def Complex(self, parent=None):
        current = UnlexerRule(name='Complex', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='_Complex', parent=current)
        self.exit_rule(current)
        return current
    Complex.min_depth = 0

    @depthcontrol
    def Generic(self, parent=None):
        current = UnlexerRule(name='Generic', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='_Generic', parent=current)
        self.exit_rule(current)
        return current
    Generic.min_depth = 0

    @depthcontrol
    def Imaginary(self, parent=None):
        current = UnlexerRule(name='Imaginary', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='_Imaginary', parent=current)
        self.exit_rule(current)
        return current
    Imaginary.min_depth = 0

    @depthcontrol
    def Noreturn(self, parent=None):
        current = UnlexerRule(name='Noreturn', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='_Noreturn', parent=current)
        self.exit_rule(current)
        return current
    Noreturn.min_depth = 0

    @depthcontrol
    def StaticAssert(self, parent=None):
        current = UnlexerRule(name='StaticAssert', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='_Static_assert', parent=current)
        self.exit_rule(current)
        return current
    StaticAssert.min_depth = 0

    @depthcontrol
    def ThreadLocal(self, parent=None):
        current = UnlexerRule(name='ThreadLocal', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='_Thread_local', parent=current)
        self.exit_rule(current)
        return current
    ThreadLocal.min_depth = 0

    @depthcontrol
    def LeftParen(self, parent=None):
        current = UnlexerRule(name='LeftParen', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.exit_rule(current)
        return current
    LeftParen.min_depth = 0

    @depthcontrol
    def RightParen(self, parent=None):
        current = UnlexerRule(name='RightParen', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    RightParen.min_depth = 0

    @depthcontrol
    def LeftBracket(self, parent=None):
        current = UnlexerRule(name='LeftBracket', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='[', parent=current)
        self.exit_rule(current)
        return current
    LeftBracket.min_depth = 0

    @depthcontrol
    def RightBracket(self, parent=None):
        current = UnlexerRule(name='RightBracket', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=']', parent=current)
        self.exit_rule(current)
        return current
    RightBracket.min_depth = 0

    @depthcontrol
    def LeftBrace(self, parent=None):
        current = UnlexerRule(name='LeftBrace', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='{', parent=current)
        self.exit_rule(current)
        return current
    LeftBrace.min_depth = 0

    @depthcontrol
    def RightBrace(self, parent=None):
        current = UnlexerRule(name='RightBrace', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='}', parent=current)
        self.exit_rule(current)
        return current
    RightBrace.min_depth = 0

    @depthcontrol
    def Less(self, parent=None):
        current = UnlexerRule(name='Less', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<', parent=current)
        self.exit_rule(current)
        return current
    Less.min_depth = 0

    @depthcontrol
    def LessEqual(self, parent=None):
        current = UnlexerRule(name='LessEqual', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<=', parent=current)
        self.exit_rule(current)
        return current
    LessEqual.min_depth = 0

    @depthcontrol
    def Greater(self, parent=None):
        current = UnlexerRule(name='Greater', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='>', parent=current)
        self.exit_rule(current)
        return current
    Greater.min_depth = 0

    @depthcontrol
    def GreaterEqual(self, parent=None):
        current = UnlexerRule(name='GreaterEqual', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='>=', parent=current)
        self.exit_rule(current)
        return current
    GreaterEqual.min_depth = 0

    @depthcontrol
    def LeftShift(self, parent=None):
        current = UnlexerRule(name='LeftShift', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<<', parent=current)
        self.exit_rule(current)
        return current
    LeftShift.min_depth = 0

    @depthcontrol
    def RightShift(self, parent=None):
        current = UnlexerRule(name='RightShift', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='>>', parent=current)
        self.exit_rule(current)
        return current
    RightShift.min_depth = 0

    @depthcontrol
    def Plus(self, parent=None):
        current = UnlexerRule(name='Plus', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='+', parent=current)
        self.exit_rule(current)
        return current
    Plus.min_depth = 0

    @depthcontrol
    def PlusPlus(self, parent=None):
        current = UnlexerRule(name='PlusPlus', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='++', parent=current)
        self.exit_rule(current)
        return current
    PlusPlus.min_depth = 0

    @depthcontrol
    def Minus(self, parent=None):
        current = UnlexerRule(name='Minus', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='-', parent=current)
        self.exit_rule(current)
        return current
    Minus.min_depth = 0

    @depthcontrol
    def MinusMinus(self, parent=None):
        current = UnlexerRule(name='MinusMinus', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='--', parent=current)
        self.exit_rule(current)
        return current
    MinusMinus.min_depth = 0

    @depthcontrol
    def Star(self, parent=None):
        current = UnlexerRule(name='Star', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='*', parent=current)
        self.exit_rule(current)
        return current
    Star.min_depth = 0

    @depthcontrol
    def Div(self, parent=None):
        current = UnlexerRule(name='Div', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='/', parent=current)
        self.exit_rule(current)
        return current
    Div.min_depth = 0

    @depthcontrol
    def Mod(self, parent=None):
        current = UnlexerRule(name='Mod', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='%', parent=current)
        self.exit_rule(current)
        return current
    Mod.min_depth = 0

    @depthcontrol
    def And(self, parent=None):
        current = UnlexerRule(name='And', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='&', parent=current)
        self.exit_rule(current)
        return current
    And.min_depth = 0

    @depthcontrol
    def Or(self, parent=None):
        current = UnlexerRule(name='Or', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='|', parent=current)
        self.exit_rule(current)
        return current
    Or.min_depth = 0

    @depthcontrol
    def AndAnd(self, parent=None):
        current = UnlexerRule(name='AndAnd', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='&&', parent=current)
        self.exit_rule(current)
        return current
    AndAnd.min_depth = 0

    @depthcontrol
    def OrOr(self, parent=None):
        current = UnlexerRule(name='OrOr', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='||', parent=current)
        self.exit_rule(current)
        return current
    OrOr.min_depth = 0

    @depthcontrol
    def Caret(self, parent=None):
        current = UnlexerRule(name='Caret', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='^', parent=current)
        self.exit_rule(current)
        return current
    Caret.min_depth = 0

    @depthcontrol
    def Not(self, parent=None):
        current = UnlexerRule(name='Not', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='!', parent=current)
        self.exit_rule(current)
        return current
    Not.min_depth = 0

    @depthcontrol
    def Tilde(self, parent=None):
        current = UnlexerRule(name='Tilde', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='~', parent=current)
        self.exit_rule(current)
        return current
    Tilde.min_depth = 0

    @depthcontrol
    def Question(self, parent=None):
        current = UnlexerRule(name='Question', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='?', parent=current)
        self.exit_rule(current)
        return current
    Question.min_depth = 0

    @depthcontrol
    def Colon(self, parent=None):
        current = UnlexerRule(name='Colon', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=':', parent=current)
        self.exit_rule(current)
        return current
    Colon.min_depth = 0

    @depthcontrol
    def Semi(self, parent=None):
        current = UnlexerRule(name='Semi', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=';', parent=current)
        self.exit_rule(current)
        return current
    Semi.min_depth = 0

    @depthcontrol
    def Comma(self, parent=None):
        current = UnlexerRule(name='Comma', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=',', parent=current)
        self.exit_rule(current)
        return current
    Comma.min_depth = 0

    @depthcontrol
    def Assign(self, parent=None):
        current = UnlexerRule(name='Assign', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='=', parent=current)
        self.exit_rule(current)
        return current
    Assign.min_depth = 0

    @depthcontrol
    def StarAssign(self, parent=None):
        current = UnlexerRule(name='StarAssign', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='*=', parent=current)
        self.exit_rule(current)
        return current
    StarAssign.min_depth = 0

    @depthcontrol
    def DivAssign(self, parent=None):
        current = UnlexerRule(name='DivAssign', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='/=', parent=current)
        self.exit_rule(current)
        return current
    DivAssign.min_depth = 0

    @depthcontrol
    def ModAssign(self, parent=None):
        current = UnlexerRule(name='ModAssign', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='%=', parent=current)
        self.exit_rule(current)
        return current
    ModAssign.min_depth = 0

    @depthcontrol
    def PlusAssign(self, parent=None):
        current = UnlexerRule(name='PlusAssign', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='+=', parent=current)
        self.exit_rule(current)
        return current
    PlusAssign.min_depth = 0

    @depthcontrol
    def MinusAssign(self, parent=None):
        current = UnlexerRule(name='MinusAssign', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='-=', parent=current)
        self.exit_rule(current)
        return current
    MinusAssign.min_depth = 0

    @depthcontrol
    def LeftShiftAssign(self, parent=None):
        current = UnlexerRule(name='LeftShiftAssign', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<<=', parent=current)
        self.exit_rule(current)
        return current
    LeftShiftAssign.min_depth = 0

    @depthcontrol
    def RightShiftAssign(self, parent=None):
        current = UnlexerRule(name='RightShiftAssign', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='>>=', parent=current)
        self.exit_rule(current)
        return current
    RightShiftAssign.min_depth = 0

    @depthcontrol
    def AndAssign(self, parent=None):
        current = UnlexerRule(name='AndAssign', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='&=', parent=current)
        self.exit_rule(current)
        return current
    AndAssign.min_depth = 0

    @depthcontrol
    def XorAssign(self, parent=None):
        current = UnlexerRule(name='XorAssign', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='^=', parent=current)
        self.exit_rule(current)
        return current
    XorAssign.min_depth = 0

    @depthcontrol
    def OrAssign(self, parent=None):
        current = UnlexerRule(name='OrAssign', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='|=', parent=current)
        self.exit_rule(current)
        return current
    OrAssign.min_depth = 0

    @depthcontrol
    def Equal(self, parent=None):
        current = UnlexerRule(name='Equal', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='==', parent=current)
        self.exit_rule(current)
        return current
    Equal.min_depth = 0

    @depthcontrol
    def NotEqual(self, parent=None):
        current = UnlexerRule(name='NotEqual', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='!=', parent=current)
        self.exit_rule(current)
        return current
    NotEqual.min_depth = 0

    @depthcontrol
    def Arrow(self, parent=None):
        current = UnlexerRule(name='Arrow', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='->', parent=current)
        self.exit_rule(current)
        return current
    Arrow.min_depth = 0

    @depthcontrol
    def Dot(self, parent=None):
        current = UnlexerRule(name='Dot', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='.', parent=current)
        self.exit_rule(current)
        return current
    Dot.min_depth = 0

    @depthcontrol
    def Ellipsis(self, parent=None):
        current = UnlexerRule(name='Ellipsis', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='...', parent=current)
        self.exit_rule(current)
        return current
    Ellipsis.min_depth = 0

    @depthcontrol
    def Identifier(self, parent=None):
        current = UnlexerRule(name='Identifier', parent=parent)
        self.enter_rule(current)
        self.IdentifierNondigit(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.IdentifierNondigit(parent=current)
                elif choice == 1:
                    self.Digit(parent=current)
        self.exit_rule(current)
        return current
    Identifier.min_depth = 2

    @depthcontrol
    def IdentifierNondigit(self, parent=None):
        current = UnlexerRule(name='IdentifierNondigit', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.Nondigit(parent=current)
        elif choice == 1:
            self.UniversalCharacterName(parent=current)
        self.exit_rule(current)
        return current
    IdentifierNondigit.min_depth = 1

    @depthcontrol
    def Nondigit(self, parent=None):
        current = UnlexerRule(name='Nondigit', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[3]), parent=current)
        self.exit_rule(current)
        return current
    Nondigit.min_depth = 0

    @depthcontrol
    def Digit(self, parent=None):
        current = UnlexerRule(name='Digit', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[4]), parent=current)
        self.exit_rule(current)
        return current
    Digit.min_depth = 0

    @depthcontrol
    def UniversalCharacterName(self, parent=None):
        current = UnlexerRule(name='UniversalCharacterName', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='\\u', parent=current)
            self.HexQuad(parent=current)
        elif choice == 1:
            UnlexerRule(src='\\U', parent=current)
            self.HexQuad(parent=current)
            self.HexQuad(parent=current)
        self.exit_rule(current)
        return current
    UniversalCharacterName.min_depth = 2

    @depthcontrol
    def HexQuad(self, parent=None):
        current = UnlexerRule(name='HexQuad', parent=parent)
        self.enter_rule(current)
        self.HexadecimalDigit(parent=current)
        self.HexadecimalDigit(parent=current)
        self.HexadecimalDigit(parent=current)
        self.HexadecimalDigit(parent=current)
        self.exit_rule(current)
        return current
    HexQuad.min_depth = 1

    @depthcontrol
    def Constant(self, parent=None):
        current = UnlexerRule(name='Constant', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 5, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.IntegerConstant(parent=current)
        elif choice == 1:
            self.FloatingConstant(parent=current)
        elif choice == 2:
            self.CharacterConstant(parent=current)
        self.exit_rule(current)
        return current
    Constant.min_depth = 2

    @depthcontrol
    def IntegerConstant(self, parent=None):
        current = UnlexerRule(name='IntegerConstant', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 1, 2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.DecimalConstant(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.IntegerSuffix(parent=current)
        elif choice == 1:
            self.OctalConstant(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    self.IntegerSuffix(parent=current)
        elif choice == 2:
            self.HexadecimalConstant(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    self.IntegerSuffix(parent=current)
        elif choice == 3:
            self.BinaryConstant(parent=current)
        self.exit_rule(current)
        return current
    IntegerConstant.min_depth = 1

    @depthcontrol
    def BinaryConstant(self, parent=None):
        current = UnlexerRule(name='BinaryConstant', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='0', parent=current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[5]), parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 1, self._charsets[6]), parent=current)
        self.exit_rule(current)
        return current
    BinaryConstant.min_depth = 0

    @depthcontrol
    def DecimalConstant(self, parent=None):
        current = UnlexerRule(name='DecimalConstant', parent=parent)
        self.enter_rule(current)
        self.NonzeroDigit(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.Digit(parent=current)
        self.exit_rule(current)
        return current
    DecimalConstant.min_depth = 1

    @depthcontrol
    def OctalConstant(self, parent=None):
        current = UnlexerRule(name='OctalConstant', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='0', parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.OctalDigit(parent=current)
        self.exit_rule(current)
        return current
    OctalConstant.min_depth = 0

    @depthcontrol
    def HexadecimalConstant(self, parent=None):
        current = UnlexerRule(name='HexadecimalConstant', parent=parent)
        self.enter_rule(current)
        self.HexadecimalPrefix(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.HexadecimalDigit(parent=current)
        self.exit_rule(current)
        return current
    HexadecimalConstant.min_depth = 1

    @depthcontrol
    def HexadecimalPrefix(self, parent=None):
        current = UnlexerRule(name='HexadecimalPrefix', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='0', parent=current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[7]), parent=current)
        self.exit_rule(current)
        return current
    HexadecimalPrefix.min_depth = 0

    @depthcontrol
    def NonzeroDigit(self, parent=None):
        current = UnlexerRule(name='NonzeroDigit', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[8]), parent=current)
        self.exit_rule(current)
        return current
    NonzeroDigit.min_depth = 0

    @depthcontrol
    def OctalDigit(self, parent=None):
        current = UnlexerRule(name='OctalDigit', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[9]), parent=current)
        self.exit_rule(current)
        return current
    OctalDigit.min_depth = 0

    @depthcontrol
    def HexadecimalDigit(self, parent=None):
        current = UnlexerRule(name='HexadecimalDigit', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[10]), parent=current)
        self.exit_rule(current)
        return current
    HexadecimalDigit.min_depth = 0

    @depthcontrol
    def IntegerSuffix(self, parent=None):
        current = UnlexerRule(name='IntegerSuffix', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.UnsignedSuffix(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.LongSuffix(parent=current)
        elif choice == 1:
            self.UnsignedSuffix(parent=current)
            self.LongLongSuffix(parent=current)
        elif choice == 2:
            self.LongSuffix(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    self.UnsignedSuffix(parent=current)
        elif choice == 3:
            self.LongLongSuffix(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    self.UnsignedSuffix(parent=current)
        self.exit_rule(current)
        return current
    IntegerSuffix.min_depth = 1

    @depthcontrol
    def UnsignedSuffix(self, parent=None):
        current = UnlexerRule(name='UnsignedSuffix', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[11]), parent=current)
        self.exit_rule(current)
        return current
    UnsignedSuffix.min_depth = 0

    @depthcontrol
    def LongSuffix(self, parent=None):
        current = UnlexerRule(name='LongSuffix', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[12]), parent=current)
        self.exit_rule(current)
        return current
    LongSuffix.min_depth = 0

    @depthcontrol
    def LongLongSuffix(self, parent=None):
        current = UnlexerRule(name='LongLongSuffix', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='ll', parent=current)
        elif choice == 1:
            UnlexerRule(src='LL', parent=current)
        self.exit_rule(current)
        return current
    LongLongSuffix.min_depth = 0

    @depthcontrol
    def FloatingConstant(self, parent=None):
        current = UnlexerRule(name='FloatingConstant', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.DecimalFloatingConstant(parent=current)
        elif choice == 1:
            self.HexadecimalFloatingConstant(parent=current)
        self.exit_rule(current)
        return current
    FloatingConstant.min_depth = 4

    @depthcontrol
    def DecimalFloatingConstant(self, parent=None):
        current = UnlexerRule(name='DecimalFloatingConstant', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.FractionalConstant(parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.ExponentPart(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    self.FloatingSuffix(parent=current)
        elif choice == 1:
            self.DigitSequence(parent=current)
            self.ExponentPart(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    self.FloatingSuffix(parent=current)
        self.exit_rule(current)
        return current
    DecimalFloatingConstant.min_depth = 3

    @depthcontrol
    def HexadecimalFloatingConstant(self, parent=None):
        current = UnlexerRule(name='HexadecimalFloatingConstant', parent=parent)
        self.enter_rule(current)
        self.HexadecimalPrefix(parent=current)
        choice = self.model.choice(current, 0, [0 if [3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.HexadecimalFractionalConstant(parent=current)
        elif choice == 1:
            self.HexadecimalDigitSequence(parent=current)
        self.BinaryExponentPart(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.FloatingSuffix(parent=current)
        self.exit_rule(current)
        return current
    HexadecimalFloatingConstant.min_depth = 3

    @depthcontrol
    def FractionalConstant(self, parent=None):
        current = UnlexerRule(name='FractionalConstant', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.DigitSequence(parent=current)
            UnlexerRule(src='.', parent=current)
            self.DigitSequence(parent=current)
        elif choice == 1:
            self.DigitSequence(parent=current)
            UnlexerRule(src='.', parent=current)
        self.exit_rule(current)
        return current
    FractionalConstant.min_depth = 2

    @depthcontrol
    def ExponentPart(self, parent=None):
        current = UnlexerRule(name='ExponentPart', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[13]), parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.Sign(parent=current)
        self.DigitSequence(parent=current)
        self.exit_rule(current)
        return current
    ExponentPart.min_depth = 2

    @depthcontrol
    def Sign(self, parent=None):
        current = UnlexerRule(name='Sign', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[14]), parent=current)
        self.exit_rule(current)
        return current
    Sign.min_depth = 0

    @depthcontrol
    def DigitSequence(self, parent=None):
        current = UnlexerRule(name='DigitSequence', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.Digit(parent=current)
        self.exit_rule(current)
        return current
    DigitSequence.min_depth = 1

    @depthcontrol
    def HexadecimalFractionalConstant(self, parent=None):
        current = UnlexerRule(name='HexadecimalFractionalConstant', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.HexadecimalDigitSequence(parent=current)
            UnlexerRule(src='.', parent=current)
            self.HexadecimalDigitSequence(parent=current)
        elif choice == 1:
            self.HexadecimalDigitSequence(parent=current)
            UnlexerRule(src='.', parent=current)
        self.exit_rule(current)
        return current
    HexadecimalFractionalConstant.min_depth = 2

    @depthcontrol
    def BinaryExponentPart(self, parent=None):
        current = UnlexerRule(name='BinaryExponentPart', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[15]), parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.Sign(parent=current)
        self.DigitSequence(parent=current)
        self.exit_rule(current)
        return current
    BinaryExponentPart.min_depth = 2

    @depthcontrol
    def HexadecimalDigitSequence(self, parent=None):
        current = UnlexerRule(name='HexadecimalDigitSequence', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.HexadecimalDigit(parent=current)
        self.exit_rule(current)
        return current
    HexadecimalDigitSequence.min_depth = 1

    @depthcontrol
    def FloatingSuffix(self, parent=None):
        current = UnlexerRule(name='FloatingSuffix', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[16]), parent=current)
        self.exit_rule(current)
        return current
    FloatingSuffix.min_depth = 0

    @depthcontrol
    def CharacterConstant(self, parent=None):
        current = UnlexerRule(name='CharacterConstant', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='\'', parent=current)
            self.CCharSequence(parent=current)
            UnlexerRule(src='\'', parent=current)
        elif choice == 1:
            UnlexerRule(src='L\'', parent=current)
            self.CCharSequence(parent=current)
            UnlexerRule(src='\'', parent=current)
        elif choice == 2:
            UnlexerRule(src='u\'', parent=current)
            self.CCharSequence(parent=current)
            UnlexerRule(src='\'', parent=current)
        elif choice == 3:
            UnlexerRule(src='U\'', parent=current)
            self.CCharSequence(parent=current)
            UnlexerRule(src='\'', parent=current)
        self.exit_rule(current)
        return current
    CharacterConstant.min_depth = 2

    @depthcontrol
    def CCharSequence(self, parent=None):
        current = UnlexerRule(name='CCharSequence', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.CChar(parent=current)
        self.exit_rule(current)
        return current
    CCharSequence.min_depth = 1

    @depthcontrol
    def CChar(self, parent=None):
        current = UnlexerRule(name='CChar', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src=self.model.charset(current, 0, self._charsets[17]), parent=current)
        elif choice == 1:
            self.EscapeSequence(parent=current)
        self.exit_rule(current)
        return current
    CChar.min_depth = 0

    @depthcontrol
    def EscapeSequence(self, parent=None):
        current = UnlexerRule(name='EscapeSequence', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 2, 2, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.SimpleEscapeSequence(parent=current)
        elif choice == 1:
            self.OctalEscapeSequence(parent=current)
        elif choice == 2:
            self.HexadecimalEscapeSequence(parent=current)
        elif choice == 3:
            self.UniversalCharacterName(parent=current)
        self.exit_rule(current)
        return current
    EscapeSequence.min_depth = 1

    @depthcontrol
    def SimpleEscapeSequence(self, parent=None):
        current = UnlexerRule(name='SimpleEscapeSequence', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='\\', parent=current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[18]), parent=current)
        self.exit_rule(current)
        return current
    SimpleEscapeSequence.min_depth = 0

    @depthcontrol
    def OctalEscapeSequence(self, parent=None):
        current = UnlexerRule(name='OctalEscapeSequence', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='\\', parent=current)
        self.OctalDigit(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.OctalDigit(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.OctalDigit(parent=current)
        self.exit_rule(current)
        return current
    OctalEscapeSequence.min_depth = 1

    @depthcontrol
    def HexadecimalEscapeSequence(self, parent=None):
        current = UnlexerRule(name='HexadecimalEscapeSequence', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='\\x', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.HexadecimalDigit(parent=current)
        self.exit_rule(current)
        return current
    HexadecimalEscapeSequence.min_depth = 1

    @depthcontrol
    def StringLiteral(self, parent=None):
        current = UnlexerRule(name='StringLiteral', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.EncodingPrefix(parent=current)
        UnlexerRule(src='"', parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.SCharSequence(parent=current)
        UnlexerRule(src='"', parent=current)
        self.exit_rule(current)
        return current
    StringLiteral.min_depth = 0

    @depthcontrol
    def EncodingPrefix(self, parent=None):
        current = UnlexerRule(name='EncodingPrefix', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='u8', parent=current)
        elif choice == 1:
            UnlexerRule(src='u', parent=current)
        elif choice == 2:
            UnlexerRule(src='U', parent=current)
        elif choice == 3:
            UnlexerRule(src='L', parent=current)
        self.exit_rule(current)
        return current
    EncodingPrefix.min_depth = 0

    @depthcontrol
    def SCharSequence(self, parent=None):
        current = UnlexerRule(name='SCharSequence', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.SChar(parent=current)
        self.exit_rule(current)
        return current
    SCharSequence.min_depth = 1

    @depthcontrol
    def SChar(self, parent=None):
        current = UnlexerRule(name='SChar', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 2, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src=self.model.charset(current, 0, self._charsets[19]), parent=current)
        elif choice == 1:
            self.EscapeSequence(parent=current)
        elif choice == 2:
            UnlexerRule(src='\\\n', parent=current)
        elif choice == 3:
            UnlexerRule(src='\\\r\n', parent=current)
        self.exit_rule(current)
        return current
    SChar.min_depth = 0

    @depthcontrol
    def ComplexDefine(self, parent=None):
        current = UnlexerRule(name='ComplexDefine', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='#', parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.Whitespace(parent=current)
        UnlexerRule(src='define', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[20]), parent=current)
        self.exit_rule(current)
        return current
    ComplexDefine.min_depth = 0

    @depthcontrol
    def IncludeDirective(self, parent=None):
        current = UnlexerRule(name='IncludeDirective', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='#', parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.Whitespace(parent=current)
        UnlexerRule(src='include', parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.Whitespace(parent=current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='"', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 2, min=0, max=inf):
                    UnlexerRule(src=self.model.charset(current, 0, self._charsets[21]), parent=current)
            UnlexerRule(src='"', parent=current)
        elif choice == 1:
            UnlexerRule(src='<', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 3, min=0, max=inf):
                    UnlexerRule(src=self.model.charset(current, 1, self._charsets[22]), parent=current)
            UnlexerRule(src='>', parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 4, min=0, max=1):
                self.Whitespace(parent=current)
        self.Newline(parent=current)
        self.exit_rule(current)
        return current
    IncludeDirective.min_depth = 1

    @depthcontrol
    def AsmBlock(self, parent=None):
        current = UnlexerRule(name='AsmBlock', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='asm', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[23]), parent=current)
        UnlexerRule(src='{', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 1, self._charsets[24]), parent=current)
        UnlexerRule(src='}', parent=current)
        self.exit_rule(current)
        return current
    AsmBlock.min_depth = 0

    @depthcontrol
    def LineAfterPreprocessing(self, parent=None):
        current = UnlexerRule(name='LineAfterPreprocessing', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='#line', parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.Whitespace(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[25]), parent=current)
        self.exit_rule(current)
        return current
    LineAfterPreprocessing.min_depth = 0

    @depthcontrol
    def LineDirective(self, parent=None):
        current = UnlexerRule(name='LineDirective', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='#', parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.Whitespace(parent=current)
        self.DecimalConstant(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.Whitespace(parent=current)
        self.StringLiteral(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 2, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[26]), parent=current)
        self.exit_rule(current)
        return current
    LineDirective.min_depth = 2

    @depthcontrol
    def PragmaDirective(self, parent=None):
        current = UnlexerRule(name='PragmaDirective', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='#', parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.Whitespace(parent=current)
        UnlexerRule(src='pragma', parent=current)
        self.Whitespace(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[27]), parent=current)
        self.exit_rule(current)
        return current
    PragmaDirective.min_depth = 1

    @depthcontrol
    def Whitespace(self, parent=None):
        current = UnlexerRule(name='Whitespace', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[28]), parent=current)
        self.exit_rule(current)
        return current
    Whitespace.min_depth = 0

    @depthcontrol
    def Newline(self, parent=None):
        current = UnlexerRule(name='Newline', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='\r', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src='\n', parent=current)
        elif choice == 1:
            UnlexerRule(src='\n', parent=current)
        self.exit_rule(current)
        return current
    Newline.min_depth = 0

    @depthcontrol
    def BlockComment(self, parent=None):
        current = UnlexerRule(name='BlockComment', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='/*', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[0]), parent=current)
        UnlexerRule(src='*/', parent=current)
        self.exit_rule(current)
        return current
    BlockComment.min_depth = 0

    @depthcontrol
    def LineComment(self, parent=None):
        current = UnlexerRule(name='LineComment', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='//', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[29]), parent=current)
        self.exit_rule(current)
        return current
    LineComment.min_depth = 0

    default_rule = primaryExpression

    _charsets = {
        0: list(chain.from_iterable([range(32, 127)])),
        1: list(chain.from_iterable([range(32, 40), range(41, 41), range(42, 44), range(45, 127)])),
        2: list(chain.from_iterable([range(32, 40), range(41, 41), range(42, 127)])),
        3: list(chain.from_iterable([range(65, 91), range(95, 96), range(97, 123)])),
        4: list(chain.from_iterable([range(48, 58)])),
        5: list(chain.from_iterable([range(66, 67), range(98, 99)])),
        6: list(chain.from_iterable([range(48, 50)])),
        7: list(chain.from_iterable([range(88, 89), range(120, 121)])),
        8: list(chain.from_iterable([range(49, 58)])),
        9: list(chain.from_iterable([range(48, 56)])),
        10: list(chain.from_iterable([range(48, 58), range(65, 71), range(97, 103)])),
        11: list(chain.from_iterable([range(85, 86), range(117, 118)])),
        12: list(chain.from_iterable([range(76, 77), range(108, 109)])),
        13: list(chain.from_iterable([range(69, 70), range(101, 102)])),
        14: list(chain.from_iterable([range(43, 44), range(45, 46)])),
        15: list(chain.from_iterable([range(80, 81), range(112, 113)])),
        16: list(chain.from_iterable([range(70, 71), range(76, 77), range(102, 103), range(108, 109)])),
        17: list(chain.from_iterable([range(32, 39), range(40, 92), range(93, 127)])),
        18: list(chain.from_iterable([range(34, 35), range(39, 40), range(63, 64), range(92, 93), range(97, 98), range(98, 99), range(102, 103), range(110, 111), range(114, 115), range(116, 117), range(118, 119)])),
        19: list(chain.from_iterable([range(32, 34), range(35, 92), range(93, 127)])),
        20: list(chain.from_iterable([range(32, 35), range(36, 127)])),
        21: list(chain.from_iterable([range(32, 127)])),
        22: list(chain.from_iterable([range(32, 127)])),
        23: list(chain.from_iterable([range(32, 123), range(124, 127)])),
        24: list(chain.from_iterable([range(32, 125), range(126, 127)])),
        25: list(chain.from_iterable([range(32, 127)])),
        26: list(chain.from_iterable([range(32, 127)])),
        27: list(chain.from_iterable([range(32, 127)])),
        28: list(chain.from_iterable([range(9, 10), range(32, 33)])),
        29: list(chain.from_iterable([range(32, 127)])),
    }

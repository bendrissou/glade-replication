# Generated by Grammarinator 0.0.0

from itertools import chain
from math import inf
from grammarinator.runtime import *

class tinycGenerator(Generator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)


    @depthcontrol
    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    @depthcontrol
    def program(self, parent=None):
        current = UnparserRule(name='program', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.statement(parent=current)
        self.exit_rule(current)
        return current
    program.min_depth = 1

    @depthcontrol
    def statement(self, parent=None):
        current = UnparserRule(name='statement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [7, 7, 7, 7, 0, 6, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='if', parent=current)
            self.paren_expr(parent=current)
            self.statement(parent=current)
        elif choice == 1:
            UnlexerRule(src='if', parent=current)
            self.paren_expr(parent=current)
            self.statement(parent=current)
            UnlexerRule(src='else', parent=current)
            self.statement(parent=current)
        elif choice == 2:
            UnlexerRule(src='while', parent=current)
            self.paren_expr(parent=current)
            self.statement(parent=current)
        elif choice == 3:
            UnlexerRule(src='do', parent=current)
            self.statement(parent=current)
            UnlexerRule(src='while', parent=current)
            self.paren_expr(parent=current)
            UnlexerRule(src=';', parent=current)
        elif choice == 4:
            UnlexerRule(src='{', parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    self.statement(parent=current)
            UnlexerRule(src='}', parent=current)
        elif choice == 5:
            self.expr(parent=current)
            UnlexerRule(src=';', parent=current)
        elif choice == 6:
            UnlexerRule(src=';', parent=current)
        self.exit_rule(current)
        return current
    statement.min_depth = 0

    @depthcontrol
    def paren_expr(self, parent=None):
        current = UnparserRule(name='paren_expr', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.expr(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    paren_expr.min_depth = 6

    @depthcontrol
    def expr(self, parent=None):
        current = UnparserRule(name='expr', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 6][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.test(parent=current)
        elif choice == 1:
            self.id_(parent=current)
            UnlexerRule(src='=', parent=current)
            self.expr(parent=current)
        self.exit_rule(current)
        return current
    expr.min_depth = 5

    @depthcontrol
    def test(self, parent=None):
        current = UnparserRule(name='test', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.sum_(parent=current)
        elif choice == 1:
            self.sum_(parent=current)
            UnlexerRule(src='<', parent=current)
            self.sum_(parent=current)
        self.exit_rule(current)
        return current
    test.min_depth = 4

    @depthcontrol
    def sum_(self, parent=None):
        current = UnparserRule(name='sum_', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 4, 4][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.term(parent=current)
        elif choice == 1:
            self.sum_(parent=current)
            UnlexerRule(src='+', parent=current)
            self.term(parent=current)
        elif choice == 2:
            self.sum_(parent=current)
            UnlexerRule(src='-', parent=current)
            self.term(parent=current)
        self.exit_rule(current)
        return current
    sum_.min_depth = 3

    @depthcontrol
    def term(self, parent=None):
        current = UnparserRule(name='term', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2, 7][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.id_(parent=current)
        elif choice == 1:
            self.integer(parent=current)
        elif choice == 2:
            self.paren_expr(parent=current)
        self.exit_rule(current)
        return current
    term.min_depth = 2

    @depthcontrol
    def id_(self, parent=None):
        current = UnparserRule(name='id_', parent=parent)
        self.enter_rule(current)
        self.STRING(parent=current)
        self.exit_rule(current)
        return current
    id_.min_depth = 1

    @depthcontrol
    def integer(self, parent=None):
        current = UnparserRule(name='integer', parent=parent)
        self.enter_rule(current)
        self.INT(parent=current)
        self.exit_rule(current)
        return current
    integer.min_depth = 1

    @depthcontrol
    def STRING(self, parent=None):
        current = UnlexerRule(name='STRING', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[1]), parent=current)
        self.exit_rule(current)
        return current
    STRING.min_depth = 0

    @depthcontrol
    def INT(self, parent=None):
        current = UnlexerRule(name='INT', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[2]), parent=current)
        self.exit_rule(current)
        return current
    INT.min_depth = 0

    @depthcontrol
    def WS(self, parent=None):
        current = UnlexerRule(name='WS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[3]), parent=current)
        self.exit_rule(current)
        return current
    WS.min_depth = 0

    default_rule = program

    _charsets = {
        0: list(chain.from_iterable([range(32, 127)])),
        1: list(chain.from_iterable([range(97, 123)])),
        2: list(chain.from_iterable([range(48, 58)])),
        3: list(chain.from_iterable([range(9, 10), range(10, 11), range(13, 14), range(32, 33)])),
    }

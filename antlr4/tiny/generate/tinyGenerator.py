# Generated by Grammarinator 0.0.0

from itertools import chain
from math import inf
from grammarinator.runtime import *

class tinyGenerator(Generator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)


    @depthcontrol
    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    @depthcontrol
    def program(self, parent=None):
        current = UnparserRule(name='program', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='BEGIN', parent=current)
        self.stmt_list(parent=current)
        UnlexerRule(src='END', parent=current)
        self.exit_rule(current)
        return current
    program.min_depth = 6

    @depthcontrol
    def stmt_list(self, parent=None):
        current = UnparserRule(name='stmt_list', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [6, 5][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.stmt_list(parent=current)
            self.stmt(parent=current)
        elif choice == 1:
            self.stmt(parent=current)
        self.exit_rule(current)
        return current
    stmt_list.min_depth = 5

    @depthcontrol
    def stmt(self, parent=None):
        current = UnparserRule(name='stmt', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 4, 6][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.assign_stmt(parent=current)
        elif choice == 1:
            self.read_stmt(parent=current)
        elif choice == 2:
            self.write_stmt(parent=current)
        self.exit_rule(current)
        return current
    stmt.min_depth = 4

    @depthcontrol
    def assign_stmt(self, parent=None):
        current = UnparserRule(name='assign_stmt', parent=parent)
        self.enter_rule(current)
        self.ident(parent=current)
        UnlexerRule(src=':=', parent=current)
        self.expr(parent=current)
        self.exit_rule(current)
        return current
    assign_stmt.min_depth = 4

    @depthcontrol
    def read_stmt(self, parent=None):
        current = UnparserRule(name='read_stmt', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='READ', parent=current)
        self.id_list(parent=current)
        self.exit_rule(current)
        return current
    read_stmt.min_depth = 3

    @depthcontrol
    def write_stmt(self, parent=None):
        current = UnparserRule(name='write_stmt', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='WRITE', parent=current)
        self.expr_list(parent=current)
        self.exit_rule(current)
        return current
    write_stmt.min_depth = 5

    @depthcontrol
    def id_list(self, parent=None):
        current = UnparserRule(name='id_list', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.id_list(parent=current)
            UnlexerRule(src=',', parent=current)
            self.ident(parent=current)
        elif choice == 1:
            self.ident(parent=current)
        self.exit_rule(current)
        return current
    id_list.min_depth = 2

    @depthcontrol
    def expr_list(self, parent=None):
        current = UnparserRule(name='expr_list', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [5, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.expr_list(parent=current)
            UnlexerRule(src=',', parent=current)
            self.expr(parent=current)
        elif choice == 1:
            self.expr(parent=current)
        self.exit_rule(current)
        return current
    expr_list.min_depth = 4

    @depthcontrol
    def expr(self, parent=None):
        current = UnparserRule(name='expr', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.expr(parent=current)
            self.op(parent=current)
            self.factor(parent=current)
        elif choice == 1:
            self.factor(parent=current)
        self.exit_rule(current)
        return current
    expr.min_depth = 3

    @depthcontrol
    def factor(self, parent=None):
        current = UnparserRule(name='factor', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.ident(parent=current)
        elif choice == 1:
            self.integer(parent=current)
        self.exit_rule(current)
        return current
    factor.min_depth = 2

    @depthcontrol
    def integer(self, parent=None):
        current = UnparserRule(name='integer', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='-', parent=current)
        self.NUMBER(parent=current)
        self.exit_rule(current)
        return current
    integer.min_depth = 1

    @depthcontrol
    def op(self, parent=None):
        current = UnparserRule(name='op', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='+', parent=current)
        elif choice == 1:
            UnlexerRule(src='-', parent=current)
        self.exit_rule(current)
        return current
    op.min_depth = 0

    @depthcontrol
    def ident(self, parent=None):
        current = UnparserRule(name='ident', parent=parent)
        self.enter_rule(current)
        self.ID(parent=current)
        self.exit_rule(current)
        return current
    ident.min_depth = 1

    @depthcontrol
    def ID(self, parent=None):
        current = UnlexerRule(name='ID', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src=self.model.charset(current, 0, self._charsets[1]), parent=current)
                elif choice == 1:
                    UnlexerRule(src=self.model.charset(current, 1, self._charsets[2]), parent=current)
        self.exit_rule(current)
        return current
    ID.min_depth = 0

    @depthcontrol
    def NUMBER(self, parent=None):
        current = UnlexerRule(name='NUMBER', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[3]), parent=current)
        self.exit_rule(current)
        return current
    NUMBER.min_depth = 0

    @depthcontrol
    def WS(self, parent=None):
        current = UnlexerRule(name='WS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[4]), parent=current)
        self.exit_rule(current)
        return current
    WS.min_depth = 0

    default_rule = program

    _charsets = {
        0: list(chain.from_iterable([range(32, 127)])),
        1: list(chain.from_iterable([range(97, 123)])),
        2: list(chain.from_iterable([range(65, 91)])),
        3: list(chain.from_iterable([range(48, 58)])),
        4: list(chain.from_iterable([range(10, 11), range(13, 14), range(32, 33)])),
    }

# Generated by Grammarinator 0.0.0

from itertools import chain
from math import inf
from grammarinator.runtime import *

class LuaGenerator(Generator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)


    @depthcontrol
    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    @depthcontrol
    def chunk(self, parent=None):
        current = UnparserRule(name='chunk', parent=parent)
        self.enter_rule(current)
        self.block(parent=current)
        self.EOF(parent=current)
        self.exit_rule(current)
        return current
    chunk.min_depth = 1

    @depthcontrol
    def block(self, parent=None):
        current = UnparserRule(name='block', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.stat(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.retstat(parent=current)
        self.exit_rule(current)
        return current
    block.min_depth = 0

    @depthcontrol
    def stat(self, parent=None):
        current = UnparserRule(name='stat', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 3, 3, 2, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src=';', parent=current)
        elif choice == 1:
            self.varlist(parent=current)
            UnlexerRule(src='=', parent=current)
            self.explist(parent=current)
        elif choice == 2:
            self.functioncall(parent=current)
        elif choice == 3:
            self.label(parent=current)
        elif choice == 4:
            UnlexerRule(src='break', parent=current)
        elif choice == 5:
            UnlexerRule(src='goto', parent=current)
            self.NAME(parent=current)
        elif choice == 6:
            UnlexerRule(src='do', parent=current)
            self.block(parent=current)
            UnlexerRule(src='end', parent=current)
        elif choice == 7:
            UnlexerRule(src='while', parent=current)
            self.exp(parent=current)
            UnlexerRule(src='do', parent=current)
            self.block(parent=current)
            UnlexerRule(src='end', parent=current)
        elif choice == 8:
            UnlexerRule(src='repeat', parent=current)
            self.block(parent=current)
            UnlexerRule(src='until', parent=current)
            self.exp(parent=current)
        elif choice == 9:
            UnlexerRule(src='if', parent=current)
            self.exp(parent=current)
            UnlexerRule(src='then', parent=current)
            self.block(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src='elseif', parent=current)
                    self.exp(parent=current)
                    UnlexerRule(src='then', parent=current)
                    self.block(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    UnlexerRule(src='else', parent=current)
                    self.block(parent=current)
            UnlexerRule(src='end', parent=current)
        elif choice == 10:
            UnlexerRule(src='for', parent=current)
            self.NAME(parent=current)
            UnlexerRule(src='=', parent=current)
            self.exp(parent=current)
            UnlexerRule(src=',', parent=current)
            self.exp(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    UnlexerRule(src=',', parent=current)
                    self.exp(parent=current)
            UnlexerRule(src='do', parent=current)
            self.block(parent=current)
            UnlexerRule(src='end', parent=current)
        elif choice == 11:
            UnlexerRule(src='for', parent=current)
            self.namelist(parent=current)
            UnlexerRule(src='in', parent=current)
            self.explist(parent=current)
            UnlexerRule(src='do', parent=current)
            self.block(parent=current)
            UnlexerRule(src='end', parent=current)
        elif choice == 12:
            UnlexerRule(src='function', parent=current)
            self.funcname(parent=current)
            self.funcbody(parent=current)
        elif choice == 13:
            UnlexerRule(src='local', parent=current)
            UnlexerRule(src='function', parent=current)
            self.NAME(parent=current)
            self.funcbody(parent=current)
        elif choice == 14:
            UnlexerRule(src='local', parent=current)
            self.attnamelist(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 3, min=0, max=1):
                    UnlexerRule(src='=', parent=current)
                    self.explist(parent=current)
        self.exit_rule(current)
        return current
    stat.min_depth = 0

    @depthcontrol
    def attnamelist(self, parent=None):
        current = UnparserRule(name='attnamelist', parent=parent)
        self.enter_rule(current)
        self.NAME(parent=current)
        self.attrib(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.NAME(parent=current)
                self.attrib(parent=current)
        self.exit_rule(current)
        return current
    attnamelist.min_depth = 1

    @depthcontrol
    def attrib(self, parent=None):
        current = UnparserRule(name='attrib', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src='<', parent=current)
                self.NAME(parent=current)
                UnlexerRule(src='>', parent=current)
        self.exit_rule(current)
        return current
    attrib.min_depth = 0

    @depthcontrol
    def retstat(self, parent=None):
        current = UnparserRule(name='retstat', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='return', parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.explist(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                UnlexerRule(src=';', parent=current)
        self.exit_rule(current)
        return current
    retstat.min_depth = 0

    @depthcontrol
    def label(self, parent=None):
        current = UnparserRule(name='label', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='::', parent=current)
        self.NAME(parent=current)
        UnlexerRule(src='::', parent=current)
        self.exit_rule(current)
        return current
    label.min_depth = 1

    @depthcontrol
    def funcname(self, parent=None):
        current = UnparserRule(name='funcname', parent=parent)
        self.enter_rule(current)
        self.NAME(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src='.', parent=current)
                self.NAME(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                UnlexerRule(src=':', parent=current)
                self.NAME(parent=current)
        self.exit_rule(current)
        return current
    funcname.min_depth = 1

    @depthcontrol
    def varlist(self, parent=None):
        current = UnparserRule(name='varlist', parent=parent)
        self.enter_rule(current)
        self.var_(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.var_(parent=current)
        self.exit_rule(current)
        return current
    varlist.min_depth = 2

    @depthcontrol
    def namelist(self, parent=None):
        current = UnparserRule(name='namelist', parent=parent)
        self.enter_rule(current)
        self.NAME(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.NAME(parent=current)
        self.exit_rule(current)
        return current
    namelist.min_depth = 1

    @depthcontrol
    def explist(self, parent=None):
        current = UnparserRule(name='explist', parent=parent)
        self.enter_rule(current)
        self.exp(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.exp(parent=current)
        self.exit_rule(current)
        return current
    explist.min_depth = 1

    @depthcontrol
    def exp(self, parent=None):
        current = UnparserRule(name='exp', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 3, 2, 0, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='nil', parent=current)
        elif choice == 1:
            UnlexerRule(src='false', parent=current)
        elif choice == 2:
            UnlexerRule(src='true', parent=current)
        elif choice == 3:
            self.number(parent=current)
        elif choice == 4:
            self.string(parent=current)
        elif choice == 5:
            UnlexerRule(src='...', parent=current)
        elif choice == 6:
            self.functiondef(parent=current)
        elif choice == 7:
            self.prefixexp(parent=current)
        elif choice == 8:
            self.tableconstructor(parent=current)
        elif choice == 9:
            self.exp(parent=current)
            self.operatorPower(parent=current)
            self.exp(parent=current)
        elif choice == 10:
            self.operatorUnary(parent=current)
            self.exp(parent=current)
        elif choice == 11:
            self.exp(parent=current)
            self.operatorMulDivMod(parent=current)
            self.exp(parent=current)
        elif choice == 12:
            self.exp(parent=current)
            self.operatorAddSub(parent=current)
            self.exp(parent=current)
        elif choice == 13:
            self.exp(parent=current)
            self.operatorStrcat(parent=current)
            self.exp(parent=current)
        elif choice == 14:
            self.exp(parent=current)
            self.operatorComparison(parent=current)
            self.exp(parent=current)
        elif choice == 15:
            self.exp(parent=current)
            self.operatorAnd(parent=current)
            self.exp(parent=current)
        elif choice == 16:
            self.exp(parent=current)
            self.operatorOr(parent=current)
            self.exp(parent=current)
        elif choice == 17:
            self.exp(parent=current)
            self.operatorBitwise(parent=current)
            self.exp(parent=current)
        self.exit_rule(current)
        return current
    exp.min_depth = 0

    @depthcontrol
    def prefixexp(self, parent=None):
        current = UnparserRule(name='prefixexp', parent=parent)
        self.enter_rule(current)
        self.varOrExp(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.nameAndArgs(parent=current)
        self.exit_rule(current)
        return current
    prefixexp.min_depth = 2

    @depthcontrol
    def functioncall(self, parent=None):
        current = UnparserRule(name='functioncall', parent=parent)
        self.enter_rule(current)
        self.varOrExp(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.nameAndArgs(parent=current)
        self.exit_rule(current)
        return current
    functioncall.min_depth = 2

    @depthcontrol
    def varOrExp(self, parent=None):
        current = UnparserRule(name='varOrExp', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.var_(parent=current)
        elif choice == 1:
            UnlexerRule(src='(', parent=current)
            self.exp(parent=current)
            UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    varOrExp.min_depth = 1

    @depthcontrol
    def var_(self, parent=None):
        current = UnparserRule(name='var_', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.NAME(parent=current)
        elif choice == 1:
            UnlexerRule(src='(', parent=current)
            self.exp(parent=current)
            UnlexerRule(src=')', parent=current)
            self.varSuffix(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.varSuffix(parent=current)
        self.exit_rule(current)
        return current
    var_.min_depth = 1

    @depthcontrol
    def varSuffix(self, parent=None):
        current = UnparserRule(name='varSuffix', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.nameAndArgs(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='[', parent=current)
            self.exp(parent=current)
            UnlexerRule(src=']', parent=current)
        elif choice == 1:
            UnlexerRule(src='.', parent=current)
            self.NAME(parent=current)
        self.exit_rule(current)
        return current
    varSuffix.min_depth = 1

    @depthcontrol
    def nameAndArgs(self, parent=None):
        current = UnparserRule(name='nameAndArgs', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src=':', parent=current)
                self.NAME(parent=current)
        self.args(parent=current)
        self.exit_rule(current)
        return current
    nameAndArgs.min_depth = 1

    @depthcontrol
    def args(self, parent=None):
        current = UnparserRule(name='args', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='(', parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.explist(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 1:
            self.tableconstructor(parent=current)
        elif choice == 2:
            self.string(parent=current)
        self.exit_rule(current)
        return current
    args.min_depth = 0

    @depthcontrol
    def functiondef(self, parent=None):
        current = UnparserRule(name='functiondef', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='function', parent=current)
        self.funcbody(parent=current)
        self.exit_rule(current)
        return current
    functiondef.min_depth = 2

    @depthcontrol
    def funcbody(self, parent=None):
        current = UnparserRule(name='funcbody', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.parlist(parent=current)
        UnlexerRule(src=')', parent=current)
        self.block(parent=current)
        UnlexerRule(src='end', parent=current)
        self.exit_rule(current)
        return current
    funcbody.min_depth = 1

    @depthcontrol
    def parlist(self, parent=None):
        current = UnparserRule(name='parlist', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.namelist(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src=',', parent=current)
                    UnlexerRule(src='...', parent=current)
        elif choice == 1:
            UnlexerRule(src='...', parent=current)
        self.exit_rule(current)
        return current
    parlist.min_depth = 0

    @depthcontrol
    def tableconstructor(self, parent=None):
        current = UnparserRule(name='tableconstructor', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='{', parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.fieldlist(parent=current)
        UnlexerRule(src='}', parent=current)
        self.exit_rule(current)
        return current
    tableconstructor.min_depth = 0

    @depthcontrol
    def fieldlist(self, parent=None):
        current = UnparserRule(name='fieldlist', parent=parent)
        self.enter_rule(current)
        self.field(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.fieldsep(parent=current)
                self.field(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.fieldsep(parent=current)
        self.exit_rule(current)
        return current
    fieldlist.min_depth = 2

    @depthcontrol
    def field(self, parent=None):
        current = UnparserRule(name='field', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='[', parent=current)
            self.exp(parent=current)
            UnlexerRule(src=']', parent=current)
            UnlexerRule(src='=', parent=current)
            self.exp(parent=current)
        elif choice == 1:
            self.NAME(parent=current)
            UnlexerRule(src='=', parent=current)
            self.exp(parent=current)
        elif choice == 2:
            self.exp(parent=current)
        self.exit_rule(current)
        return current
    field.min_depth = 1

    @depthcontrol
    def fieldsep(self, parent=None):
        current = UnparserRule(name='fieldsep', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src=',', parent=current)
        elif choice == 1:
            UnlexerRule(src=';', parent=current)
        self.exit_rule(current)
        return current
    fieldsep.min_depth = 0

    @depthcontrol
    def operatorOr(self, parent=None):
        current = UnparserRule(name='operatorOr', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='or', parent=current)
        self.exit_rule(current)
        return current
    operatorOr.min_depth = 0

    @depthcontrol
    def operatorAnd(self, parent=None):
        current = UnparserRule(name='operatorAnd', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='and', parent=current)
        self.exit_rule(current)
        return current
    operatorAnd.min_depth = 0

    @depthcontrol
    def operatorComparison(self, parent=None):
        current = UnparserRule(name='operatorComparison', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='<', parent=current)
        elif choice == 1:
            UnlexerRule(src='>', parent=current)
        elif choice == 2:
            UnlexerRule(src='<=', parent=current)
        elif choice == 3:
            UnlexerRule(src='>=', parent=current)
        elif choice == 4:
            UnlexerRule(src='~=', parent=current)
        elif choice == 5:
            UnlexerRule(src='==', parent=current)
        self.exit_rule(current)
        return current
    operatorComparison.min_depth = 0

    @depthcontrol
    def operatorStrcat(self, parent=None):
        current = UnparserRule(name='operatorStrcat', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='..', parent=current)
        self.exit_rule(current)
        return current
    operatorStrcat.min_depth = 0

    @depthcontrol
    def operatorAddSub(self, parent=None):
        current = UnparserRule(name='operatorAddSub', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='+', parent=current)
        elif choice == 1:
            UnlexerRule(src='-', parent=current)
        self.exit_rule(current)
        return current
    operatorAddSub.min_depth = 0

    @depthcontrol
    def operatorMulDivMod(self, parent=None):
        current = UnparserRule(name='operatorMulDivMod', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='*', parent=current)
        elif choice == 1:
            UnlexerRule(src='/', parent=current)
        elif choice == 2:
            UnlexerRule(src='%', parent=current)
        elif choice == 3:
            UnlexerRule(src='//', parent=current)
        self.exit_rule(current)
        return current
    operatorMulDivMod.min_depth = 0

    @depthcontrol
    def operatorBitwise(self, parent=None):
        current = UnparserRule(name='operatorBitwise', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='&', parent=current)
        elif choice == 1:
            UnlexerRule(src='|', parent=current)
        elif choice == 2:
            UnlexerRule(src='~', parent=current)
        elif choice == 3:
            UnlexerRule(src='<<', parent=current)
        elif choice == 4:
            UnlexerRule(src='>>', parent=current)
        self.exit_rule(current)
        return current
    operatorBitwise.min_depth = 0

    @depthcontrol
    def operatorUnary(self, parent=None):
        current = UnparserRule(name='operatorUnary', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='not', parent=current)
        elif choice == 1:
            UnlexerRule(src='#', parent=current)
        elif choice == 2:
            UnlexerRule(src='-', parent=current)
        elif choice == 3:
            UnlexerRule(src='~', parent=current)
        self.exit_rule(current)
        return current
    operatorUnary.min_depth = 0

    @depthcontrol
    def operatorPower(self, parent=None):
        current = UnparserRule(name='operatorPower', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='^', parent=current)
        self.exit_rule(current)
        return current
    operatorPower.min_depth = 0

    @depthcontrol
    def number(self, parent=None):
        current = UnparserRule(name='number', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.INT(parent=current)
        elif choice == 1:
            self.HEX(parent=current)
        elif choice == 2:
            self.FLOAT(parent=current)
        elif choice == 3:
            self.HEX_FLOAT(parent=current)
        self.exit_rule(current)
        return current
    number.min_depth = 2

    @depthcontrol
    def string(self, parent=None):
        current = UnparserRule(name='string', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.NORMALSTRING(parent=current)
        elif choice == 1:
            self.CHARSTRING(parent=current)
        elif choice == 2:
            self.LONGSTRING(parent=current)
        self.exit_rule(current)
        return current
    string.min_depth = 1

    @depthcontrol
    def NAME(self, parent=None):
        current = UnlexerRule(name='NAME', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[1]), parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 1, self._charsets[2]), parent=current)
        self.exit_rule(current)
        return current
    NAME.min_depth = 0

    @depthcontrol
    def NORMALSTRING(self, parent=None):
        current = UnlexerRule(name='NORMALSTRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='"', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [1, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.EscapeSequence(parent=current)
                elif choice == 1:
                    UnlexerRule(src=self.model.charset(current, 0, self._charsets[3]), parent=current)
        UnlexerRule(src='"', parent=current)
        self.exit_rule(current)
        return current
    NORMALSTRING.min_depth = 0

    @depthcontrol
    def CHARSTRING(self, parent=None):
        current = UnlexerRule(name='CHARSTRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='\'', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [1, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.EscapeSequence(parent=current)
                elif choice == 1:
                    UnlexerRule(src=self.model.charset(current, 0, self._charsets[4]), parent=current)
        UnlexerRule(src='\'', parent=current)
        self.exit_rule(current)
        return current
    CHARSTRING.min_depth = 0

    @depthcontrol
    def LONGSTRING(self, parent=None):
        current = UnlexerRule(name='LONGSTRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='[', parent=current)
        self.NESTED_STR(parent=current)
        UnlexerRule(src=']', parent=current)
        self.exit_rule(current)
        return current
    LONGSTRING.min_depth = 1

    @depthcontrol
    def NESTED_STR(self, parent=None):
        current = UnlexerRule(name='NESTED_STR', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='=', parent=current)
            self.NESTED_STR(parent=current)
            UnlexerRule(src='=', parent=current)
        elif choice == 1:
            UnlexerRule(src='[', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=self.model.charset(current, 0, self._charsets[0]), parent=current)
            UnlexerRule(src=']', parent=current)
        self.exit_rule(current)
        return current
    NESTED_STR.min_depth = 0

    @depthcontrol
    def INT(self, parent=None):
        current = UnlexerRule(name='INT', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.Digit(parent=current)
        self.exit_rule(current)
        return current
    INT.min_depth = 1

    @depthcontrol
    def HEX(self, parent=None):
        current = UnlexerRule(name='HEX', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='0', parent=current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[5]), parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.HexDigit(parent=current)
        self.exit_rule(current)
        return current
    HEX.min_depth = 1

    @depthcontrol
    def FLOAT(self, parent=None):
        current = UnlexerRule(name='FLOAT', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=1, max=inf):
                    self.Digit(parent=current)
            UnlexerRule(src='.', parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 1, min=0, max=inf):
                    self.Digit(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    self.ExponentPart(parent=current)
        elif choice == 1:
            UnlexerRule(src='.', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 3, min=1, max=inf):
                    self.Digit(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 4, min=0, max=1):
                    self.ExponentPart(parent=current)
        elif choice == 2:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 5, min=1, max=inf):
                    self.Digit(parent=current)
            self.ExponentPart(parent=current)
        self.exit_rule(current)
        return current
    FLOAT.min_depth = 1

    @depthcontrol
    def HEX_FLOAT(self, parent=None):
        current = UnlexerRule(name='HEX_FLOAT', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='0', parent=current)
            UnlexerRule(src=self.model.charset(current, 0, self._charsets[6]), parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=1, max=inf):
                    self.HexDigit(parent=current)
            UnlexerRule(src='.', parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 1, min=0, max=inf):
                    self.HexDigit(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    self.HexExponentPart(parent=current)
        elif choice == 1:
            UnlexerRule(src='0', parent=current)
            UnlexerRule(src=self.model.charset(current, 1, self._charsets[7]), parent=current)
            UnlexerRule(src='.', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 3, min=1, max=inf):
                    self.HexDigit(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 4, min=0, max=1):
                    self.HexExponentPart(parent=current)
        elif choice == 2:
            UnlexerRule(src='0', parent=current)
            UnlexerRule(src=self.model.charset(current, 2, self._charsets[8]), parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 5, min=1, max=inf):
                    self.HexDigit(parent=current)
            self.HexExponentPart(parent=current)
        self.exit_rule(current)
        return current
    HEX_FLOAT.min_depth = 1

    @depthcontrol
    def ExponentPart(self, parent=None):
        current = UnlexerRule(name='ExponentPart', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[9]), parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src=self.model.charset(current, 1, self._charsets[10]), parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=1, max=inf):
                self.Digit(parent=current)
        self.exit_rule(current)
        return current
    ExponentPart.min_depth = 1

    @depthcontrol
    def HexExponentPart(self, parent=None):
        current = UnlexerRule(name='HexExponentPart', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[11]), parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src=self.model.charset(current, 1, self._charsets[12]), parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=1, max=inf):
                self.Digit(parent=current)
        self.exit_rule(current)
        return current
    HexExponentPart.min_depth = 1

    @depthcontrol
    def EscapeSequence(self, parent=None):
        current = UnlexerRule(name='EscapeSequence', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='\\', parent=current)
            UnlexerRule(src=self.model.charset(current, 0, self._charsets[13]), parent=current)
        elif choice == 1:
            UnlexerRule(src='\\', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src='\r', parent=current)
            UnlexerRule(src='\n', parent=current)
        elif choice == 2:
            self.DecimalEscape(parent=current)
        elif choice == 3:
            self.HexEscape(parent=current)
        elif choice == 4:
            self.UtfEscape(parent=current)
        self.exit_rule(current)
        return current
    EscapeSequence.min_depth = 0

    @depthcontrol
    def DecimalEscape(self, parent=None):
        current = UnlexerRule(name='DecimalEscape', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='\\', parent=current)
            self.Digit(parent=current)
        elif choice == 1:
            UnlexerRule(src='\\', parent=current)
            self.Digit(parent=current)
            self.Digit(parent=current)
        elif choice == 2:
            UnlexerRule(src='\\', parent=current)
            UnlexerRule(src=self.model.charset(current, 0, self._charsets[14]), parent=current)
            self.Digit(parent=current)
            self.Digit(parent=current)
        self.exit_rule(current)
        return current
    DecimalEscape.min_depth = 1

    @depthcontrol
    def HexEscape(self, parent=None):
        current = UnlexerRule(name='HexEscape', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='\\', parent=current)
        UnlexerRule(src='x', parent=current)
        self.HexDigit(parent=current)
        self.HexDigit(parent=current)
        self.exit_rule(current)
        return current
    HexEscape.min_depth = 1

    @depthcontrol
    def UtfEscape(self, parent=None):
        current = UnlexerRule(name='UtfEscape', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='\\', parent=current)
        UnlexerRule(src='u{', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.HexDigit(parent=current)
        UnlexerRule(src='}', parent=current)
        self.exit_rule(current)
        return current
    UtfEscape.min_depth = 1

    @depthcontrol
    def Digit(self, parent=None):
        current = UnlexerRule(name='Digit', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[15]), parent=current)
        self.exit_rule(current)
        return current
    Digit.min_depth = 0

    @depthcontrol
    def HexDigit(self, parent=None):
        current = UnlexerRule(name='HexDigit', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(current, 0, self._charsets[16]), parent=current)
        self.exit_rule(current)
        return current
    HexDigit.min_depth = 0

    @depthcontrol
    def COMMENT(self, parent=None):
        current = UnlexerRule(name='COMMENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='--[', parent=current)
        self.NESTED_STR(parent=current)
        UnlexerRule(src=']', parent=current)
        self.exit_rule(current)
        return current
    COMMENT.min_depth = 1

    @depthcontrol
    def LINE_COMMENT(self, parent=None):
        current = UnlexerRule(name='LINE_COMMENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='--', parent=current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            pass
        elif choice == 1:
            UnlexerRule(src='[', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src='=', parent=current)
        elif choice == 2:
            UnlexerRule(src='[', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 1, min=0, max=inf):
                    UnlexerRule(src='=', parent=current)
            UnlexerRule(src=self.model.charset(current, 0, self._charsets[17]), parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 2, min=0, max=inf):
                    UnlexerRule(src=self.model.charset(current, 1, self._charsets[18]), parent=current)
        elif choice == 3:
            UnlexerRule(src=self.model.charset(current, 2, self._charsets[19]), parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 3, min=0, max=inf):
                    UnlexerRule(src=self.model.charset(current, 3, self._charsets[20]), parent=current)
        choice = self.model.choice(current, 1, [0 if [0, 0, 0, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='\r\n', parent=current)
        elif choice == 1:
            UnlexerRule(src='\r', parent=current)
        elif choice == 2:
            UnlexerRule(src='\n', parent=current)
        elif choice == 3:
            self.EOF(parent=current)
        self.exit_rule(current)
        return current
    LINE_COMMENT.min_depth = 0

    @depthcontrol
    def WS(self, parent=None):
        current = UnlexerRule(name='WS', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[21]), parent=current)
        self.exit_rule(current)
        return current
    WS.min_depth = 0

    @depthcontrol
    def SHEBANG(self, parent=None):
        current = UnlexerRule(name='SHEBANG', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='#', parent=current)
        UnlexerRule(src='!', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[22]), parent=current)
        self.exit_rule(current)
        return current
    SHEBANG.min_depth = 0

    default_rule = chunk

    _charsets = {
        0: list(chain.from_iterable([range(32, 127)])),
        1: list(chain.from_iterable([range(65, 91), range(95, 96), range(97, 123)])),
        2: list(chain.from_iterable([range(48, 58), range(65, 91), range(95, 96), range(97, 123)])),
        3: list(chain.from_iterable([range(32, 34), range(35, 92), range(93, 127)])),
        4: list(chain.from_iterable([range(32, 92), range(93, 127)])),
        5: list(chain.from_iterable([range(88, 89), range(120, 121)])),
        6: list(chain.from_iterable([range(88, 89), range(120, 121)])),
        7: list(chain.from_iterable([range(88, 89), range(120, 121)])),
        8: list(chain.from_iterable([range(88, 89), range(120, 121)])),
        9: list(chain.from_iterable([range(69, 70), range(101, 102)])),
        10: list(chain.from_iterable([range(43, 44), range(45, 46)])),
        11: list(chain.from_iterable([range(80, 81), range(112, 113)])),
        12: list(chain.from_iterable([range(43, 44), range(45, 46)])),
        13: list(chain.from_iterable([range(34, 35), range(39, 40), range(92, 93), range(97, 98), range(98, 99), range(102, 103), range(110, 111), range(114, 115), range(116, 117), range(118, 119), range(122, 123)])),
        14: list(chain.from_iterable([range(48, 51)])),
        15: list(chain.from_iterable([range(48, 58)])),
        16: list(chain.from_iterable([range(48, 58), range(65, 71), range(97, 103)])),
        17: list(chain.from_iterable([range(32, 61), range(62, 91), range(92, 92), range(93, 127)])),
        18: list(chain.from_iterable([range(32, 92), range(93, 127)])),
        19: list(chain.from_iterable([range(32, 91), range(92, 92), range(93, 127)])),
        20: list(chain.from_iterable([range(32, 92), range(93, 127)])),
        21: list(chain.from_iterable([range(9, 10), range(10, 11), range(12, 13), range(13, 14), range(32, 33)])),
        22: list(chain.from_iterable([range(32, 92), range(93, 127)])),
    }

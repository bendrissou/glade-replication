# Generated by Grammarinator 0.0.0

from itertools import chain
from math import inf
from grammarinator.runtime import *

class jvmBasicGenerator(Generator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)


    @depthcontrol
    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    @depthcontrol
    def prog(self, parent=None):
        current = UnparserRule(name='prog', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.line(parent=current)
        self.EOF(parent=current)
        self.exit_rule(current)
        return current
    prog.min_depth = 3

    @depthcontrol
    def line(self, parent=None):
        current = UnparserRule(name='line', parent=parent)
        self.enter_rule(current)
        self.linenumber(parent=current)
        choice = self.model.choice(current, 0, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.amprstmt(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    self.COLON(parent=current)
                    if self.max_depth >= 2:
                        for _ in self.model.quantify(current, 1, min=0, max=1):
                            self.amprstmt(parent=current)
        elif choice == 1:
            choice = self.model.choice(current, 1, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.COMMENT(parent=current)
            elif choice == 1:
                self.REM(parent=current)
        self.exit_rule(current)
        return current
    line.min_depth = 2

    @depthcontrol
    def amperoper(self, parent=None):
        current = UnparserRule(name='amperoper', parent=parent)
        self.enter_rule(current)
        self.AMPERSAND(parent=current)
        self.exit_rule(current)
        return current
    amperoper.min_depth = 1

    @depthcontrol
    def linenumber(self, parent=None):
        current = UnparserRule(name='linenumber', parent=parent)
        self.enter_rule(current)
        self.NUMBER(parent=current)
        self.exit_rule(current)
        return current
    linenumber.min_depth = 1

    @depthcontrol
    def amprstmt(self, parent=None):
        current = UnparserRule(name='amprstmt', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.amperoper(parent=current)
            self.statement(parent=current)
        elif choice == 1:
            choice = self.model.choice(current, 1, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.COMMENT(parent=current)
            elif choice == 1:
                self.REM(parent=current)
        self.exit_rule(current)
        return current
    amprstmt.min_depth = 1

    @depthcontrol
    def statement(self, parent=None):
        current = UnparserRule(name='statement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 2, 2, 2, 4, 2, 2, 5, 5, 5, 2, 2, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 5, 5, 6, 4, 6, 3, 4, 5, 6, 2, 2, 4, 4, 4, 3, 4, 4, 4, 6, 4][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            choice = self.model.choice(current, 1, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
            if choice == 0:
                self.CLS(parent=current)
            elif choice == 1:
                self.LOAD(parent=current)
            elif choice == 2:
                self.SAVE(parent=current)
            elif choice == 3:
                self.TRACE(parent=current)
            elif choice == 4:
                self.NOTRACE(parent=current)
            elif choice == 5:
                self.FLASH(parent=current)
            elif choice == 6:
                self.INVERSE(parent=current)
            elif choice == 7:
                self.GR(parent=current)
            elif choice == 8:
                self.NORMAL(parent=current)
            elif choice == 9:
                self.SHLOAD(parent=current)
            elif choice == 10:
                self.CLEAR(parent=current)
            elif choice == 11:
                self.RUN(parent=current)
            elif choice == 12:
                self.STOP(parent=current)
            elif choice == 13:
                self.TEXT(parent=current)
            elif choice == 14:
                self.HOME(parent=current)
            elif choice == 15:
                self.HGR(parent=current)
            elif choice == 16:
                self.HGR2(parent=current)
        elif choice == 1:
            self.endstmt(parent=current)
        elif choice == 2:
            self.returnstmt(parent=current)
        elif choice == 3:
            self.restorestmt(parent=current)
        elif choice == 4:
            self.amptstmt(parent=current)
        elif choice == 5:
            self.popstmt(parent=current)
        elif choice == 6:
            self.liststmt(parent=current)
        elif choice == 7:
            self.storestmt(parent=current)
        elif choice == 8:
            self.getstmt(parent=current)
        elif choice == 9:
            self.recallstmt(parent=current)
        elif choice == 10:
            self.nextstmt(parent=current)
        elif choice == 11:
            self.instmt(parent=current)
        elif choice == 12:
            self.prstmt(parent=current)
        elif choice == 13:
            self.onerrstmt(parent=current)
        elif choice == 14:
            self.hlinstmt(parent=current)
        elif choice == 15:
            self.vlinstmt(parent=current)
        elif choice == 16:
            self.colorstmt(parent=current)
        elif choice == 17:
            self.speedstmt(parent=current)
        elif choice == 18:
            self.scalestmt(parent=current)
        elif choice == 19:
            self.rotstmt(parent=current)
        elif choice == 20:
            self.hcolorstmt(parent=current)
        elif choice == 21:
            self.himemstmt(parent=current)
        elif choice == 22:
            self.lomemstmt(parent=current)
        elif choice == 23:
            self.printstmt1(parent=current)
        elif choice == 24:
            self.pokestmt(parent=current)
        elif choice == 25:
            self.plotstmt(parent=current)
        elif choice == 26:
            self.ongotostmt(parent=current)
        elif choice == 27:
            self.ongosubstmt(parent=current)
        elif choice == 28:
            self.ifstmt(parent=current)
        elif choice == 29:
            self.forstmt1(parent=current)
        elif choice == 30:
            self.forstmt2(parent=current)
        elif choice == 31:
            self.inputstmt(parent=current)
        elif choice == 32:
            self.tabstmt(parent=current)
        elif choice == 33:
            self.dimstmt(parent=current)
        elif choice == 34:
            self.gotostmt(parent=current)
        elif choice == 35:
            self.gosubstmt(parent=current)
        elif choice == 36:
            self.callstmt(parent=current)
        elif choice == 37:
            self.readstmt(parent=current)
        elif choice == 38:
            self.hplotstmt(parent=current)
        elif choice == 39:
            self.vplotstmt(parent=current)
        elif choice == 40:
            self.vtabstmnt(parent=current)
        elif choice == 41:
            self.htabstmnt(parent=current)
        elif choice == 42:
            self.waitstmt(parent=current)
        elif choice == 43:
            self.datastmt(parent=current)
        elif choice == 44:
            self.xdrawstmt(parent=current)
        elif choice == 45:
            self.drawstmt(parent=current)
        elif choice == 46:
            self.defstmt(parent=current)
        elif choice == 47:
            self.letstmt(parent=current)
        elif choice == 48:
            self.includestmt(parent=current)
        self.exit_rule(current)
        return current
    statement.min_depth = 1

    @depthcontrol
    def vardecl(self, parent=None):
        current = UnparserRule(name='vardecl', parent=parent)
        self.enter_rule(current)
        self.var_(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.LPAREN(parent=current)
                self.exprlist(parent=current)
                self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    vardecl.min_depth = 3

    @depthcontrol
    def printstmt1(self, parent=None):
        current = UnparserRule(name='printstmt1', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.PRINT(parent=current)
        elif choice == 1:
            self.QUESTION(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.printlist(parent=current)
        self.exit_rule(current)
        return current
    printstmt1.min_depth = 1

    @depthcontrol
    def printlist(self, parent=None):
        current = UnparserRule(name='printlist', parent=parent)
        self.enter_rule(current)
        self.expression(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.COMMA(parent=current)
                elif choice == 1:
                    self.SEMICOLON(parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.expression(parent=current)
        self.exit_rule(current)
        return current
    printlist.min_depth = 3

    @depthcontrol
    def getstmt(self, parent=None):
        current = UnparserRule(name='getstmt', parent=parent)
        self.enter_rule(current)
        self.GET(parent=current)
        self.exprlist(parent=current)
        self.exit_rule(current)
        return current
    getstmt.min_depth = 4

    @depthcontrol
    def letstmt(self, parent=None):
        current = UnparserRule(name='letstmt', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.LET(parent=current)
        self.variableassignment(parent=current)
        self.exit_rule(current)
        return current
    letstmt.min_depth = 5

    @depthcontrol
    def variableassignment(self, parent=None):
        current = UnparserRule(name='variableassignment', parent=parent)
        self.enter_rule(current)
        self.vardecl(parent=current)
        self.EQ(parent=current)
        self.exprlist(parent=current)
        self.exit_rule(current)
        return current
    variableassignment.min_depth = 4

    @depthcontrol
    def relop(self, parent=None):
        current = UnparserRule(name='relop', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 2, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.GTE(parent=current)
        elif choice == 1:
            self.GT(parent=current)
            self.EQ(parent=current)
        elif choice == 2:
            self.EQ(parent=current)
            self.GT(parent=current)
        elif choice == 3:
            self.LTE(parent=current)
        elif choice == 4:
            self.LT(parent=current)
            self.EQ(parent=current)
        elif choice == 5:
            self.EQ(parent=current)
            self.LT(parent=current)
        elif choice == 6:
            self.neq(parent=current)
        elif choice == 7:
            self.EQ(parent=current)
        elif choice == 8:
            self.GT(parent=current)
        elif choice == 9:
            self.LT(parent=current)
        self.exit_rule(current)
        return current
    relop.min_depth = 1

    @depthcontrol
    def neq(self, parent=None):
        current = UnparserRule(name='neq', parent=parent)
        self.enter_rule(current)
        self.LT(parent=current)
        self.GT(parent=current)
        self.exit_rule(current)
        return current
    neq.min_depth = 1

    @depthcontrol
    def ifstmt(self, parent=None):
        current = UnparserRule(name='ifstmt', parent=parent)
        self.enter_rule(current)
        self.IF(parent=current)
        self.expression(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.THEN(parent=current)
        choice = self.model.choice(current, 0, [0 if [2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.statement(parent=current)
        elif choice == 1:
            self.linenumber(parent=current)
        self.exit_rule(current)
        return current
    ifstmt.min_depth = 3

    @depthcontrol
    def forstmt1(self, parent=None):
        current = UnparserRule(name='forstmt1', parent=parent)
        self.enter_rule(current)
        self.FOR(parent=current)
        self.vardecl(parent=current)
        self.EQ(parent=current)
        self.expression(parent=current)
        self.TO(parent=current)
        self.expression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.STEP(parent=current)
                self.expression(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.statement(parent=current)
                self.NEXT(parent=current)
                if self.max_depth >= 4:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        self.vardecl(parent=current)
        self.exit_rule(current)
        return current
    forstmt1.min_depth = 4

    @depthcontrol
    def forstmt2(self, parent=None):
        current = UnparserRule(name='forstmt2', parent=parent)
        self.enter_rule(current)
        self.FOR(parent=current)
        self.vardecl(parent=current)
        self.EQ(parent=current)
        self.expression(parent=current)
        self.TO(parent=current)
        self.expression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.STEP(parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    forstmt2.min_depth = 4

    @depthcontrol
    def nextstmt(self, parent=None):
        current = UnparserRule(name='nextstmt', parent=parent)
        self.enter_rule(current)
        self.NEXT(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.vardecl(parent=current)
                if self.max_depth >= 4:
                    for _ in self.model.quantify(current, 1, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.vardecl(parent=current)
        self.exit_rule(current)
        return current
    nextstmt.min_depth = 1

    @depthcontrol
    def inputstmt(self, parent=None):
        current = UnparserRule(name='inputstmt', parent=parent)
        self.enter_rule(current)
        self.INPUT(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.STRINGLITERAL(parent=current)
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.COMMA(parent=current)
                elif choice == 1:
                    self.SEMICOLON(parent=current)
        self.varlist(parent=current)
        self.exit_rule(current)
        return current
    inputstmt.min_depth = 5

    @depthcontrol
    def readstmt(self, parent=None):
        current = UnparserRule(name='readstmt', parent=parent)
        self.enter_rule(current)
        self.READ(parent=current)
        self.varlist(parent=current)
        self.exit_rule(current)
        return current
    readstmt.min_depth = 5

    @depthcontrol
    def dimstmt(self, parent=None):
        current = UnparserRule(name='dimstmt', parent=parent)
        self.enter_rule(current)
        self.DIM(parent=current)
        self.varlist(parent=current)
        self.exit_rule(current)
        return current
    dimstmt.min_depth = 5

    @depthcontrol
    def gotostmt(self, parent=None):
        current = UnparserRule(name='gotostmt', parent=parent)
        self.enter_rule(current)
        self.GOTO(parent=current)
        self.linenumber(parent=current)
        self.exit_rule(current)
        return current
    gotostmt.min_depth = 2

    @depthcontrol
    def gosubstmt(self, parent=None):
        current = UnparserRule(name='gosubstmt', parent=parent)
        self.enter_rule(current)
        self.GOSUB(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    gosubstmt.min_depth = 3

    @depthcontrol
    def pokestmt(self, parent=None):
        current = UnparserRule(name='pokestmt', parent=parent)
        self.enter_rule(current)
        self.POKE(parent=current)
        self.expression(parent=current)
        self.COMMA(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    pokestmt.min_depth = 3

    @depthcontrol
    def callstmt(self, parent=None):
        current = UnparserRule(name='callstmt', parent=parent)
        self.enter_rule(current)
        self.CALL(parent=current)
        self.exprlist(parent=current)
        self.exit_rule(current)
        return current
    callstmt.min_depth = 4

    @depthcontrol
    def hplotstmt(self, parent=None):
        current = UnparserRule(name='hplotstmt', parent=parent)
        self.enter_rule(current)
        self.HPLOT(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.expression(parent=current)
                self.COMMA(parent=current)
                self.expression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                self.TO(parent=current)
                self.expression(parent=current)
                self.COMMA(parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    hplotstmt.min_depth = 1

    @depthcontrol
    def vplotstmt(self, parent=None):
        current = UnparserRule(name='vplotstmt', parent=parent)
        self.enter_rule(current)
        self.VPLOT(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.expression(parent=current)
                self.COMMA(parent=current)
                self.expression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                self.TO(parent=current)
                self.expression(parent=current)
                self.COMMA(parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    vplotstmt.min_depth = 1

    @depthcontrol
    def plotstmt(self, parent=None):
        current = UnparserRule(name='plotstmt', parent=parent)
        self.enter_rule(current)
        self.PLOT(parent=current)
        self.expression(parent=current)
        self.COMMA(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    plotstmt.min_depth = 3

    @depthcontrol
    def ongotostmt(self, parent=None):
        current = UnparserRule(name='ongotostmt', parent=parent)
        self.enter_rule(current)
        self.ON(parent=current)
        self.expression(parent=current)
        self.GOTO(parent=current)
        self.linenumber(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.COMMA(parent=current)
                self.linenumber(parent=current)
        self.exit_rule(current)
        return current
    ongotostmt.min_depth = 3

    @depthcontrol
    def ongosubstmt(self, parent=None):
        current = UnparserRule(name='ongosubstmt', parent=parent)
        self.enter_rule(current)
        self.ON(parent=current)
        self.expression(parent=current)
        self.GOSUB(parent=current)
        self.linenumber(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.COMMA(parent=current)
                self.linenumber(parent=current)
        self.exit_rule(current)
        return current
    ongosubstmt.min_depth = 3

    @depthcontrol
    def vtabstmnt(self, parent=None):
        current = UnparserRule(name='vtabstmnt', parent=parent)
        self.enter_rule(current)
        self.VTAB(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    vtabstmnt.min_depth = 3

    @depthcontrol
    def htabstmnt(self, parent=None):
        current = UnparserRule(name='htabstmnt', parent=parent)
        self.enter_rule(current)
        self.HTAB(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    htabstmnt.min_depth = 3

    @depthcontrol
    def himemstmt(self, parent=None):
        current = UnparserRule(name='himemstmt', parent=parent)
        self.enter_rule(current)
        self.HIMEM(parent=current)
        self.COLON(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    himemstmt.min_depth = 3

    @depthcontrol
    def lomemstmt(self, parent=None):
        current = UnparserRule(name='lomemstmt', parent=parent)
        self.enter_rule(current)
        self.LOMEM(parent=current)
        self.COLON(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    lomemstmt.min_depth = 3

    @depthcontrol
    def datastmt(self, parent=None):
        current = UnparserRule(name='datastmt', parent=parent)
        self.enter_rule(current)
        self.DATA(parent=current)
        self.datum(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.COMMA(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 1, min=0, max=1):
                        self.datum(parent=current)
        self.exit_rule(current)
        return current
    datastmt.min_depth = 2

    @depthcontrol
    def datum(self, parent=None):
        current = UnparserRule(name='datum', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.number(parent=current)
        elif choice == 1:
            self.STRINGLITERAL(parent=current)
        self.exit_rule(current)
        return current
    datum.min_depth = 1

    @depthcontrol
    def waitstmt(self, parent=None):
        current = UnparserRule(name='waitstmt', parent=parent)
        self.enter_rule(current)
        self.WAIT(parent=current)
        self.expression(parent=current)
        self.COMMA(parent=current)
        self.expression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.COMMA(parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    waitstmt.min_depth = 3

    @depthcontrol
    def xdrawstmt(self, parent=None):
        current = UnparserRule(name='xdrawstmt', parent=parent)
        self.enter_rule(current)
        self.XDRAW(parent=current)
        self.expression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.AT(parent=current)
                self.expression(parent=current)
                self.COMMA(parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    xdrawstmt.min_depth = 3

    @depthcontrol
    def drawstmt(self, parent=None):
        current = UnparserRule(name='drawstmt', parent=parent)
        self.enter_rule(current)
        self.DRAW(parent=current)
        self.expression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.AT(parent=current)
                self.expression(parent=current)
                self.COMMA(parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    drawstmt.min_depth = 3

    @depthcontrol
    def defstmt(self, parent=None):
        current = UnparserRule(name='defstmt', parent=parent)
        self.enter_rule(current)
        self.DEF(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.FN(parent=current)
        self.var_(parent=current)
        self.LPAREN(parent=current)
        self.var_(parent=current)
        self.RPAREN(parent=current)
        self.EQ(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    defstmt.min_depth = 3

    @depthcontrol
    def tabstmt(self, parent=None):
        current = UnparserRule(name='tabstmt', parent=parent)
        self.enter_rule(current)
        self.TAB(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    tabstmt.min_depth = 3

    @depthcontrol
    def speedstmt(self, parent=None):
        current = UnparserRule(name='speedstmt', parent=parent)
        self.enter_rule(current)
        self.SPEED(parent=current)
        self.EQ(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    speedstmt.min_depth = 3

    @depthcontrol
    def rotstmt(self, parent=None):
        current = UnparserRule(name='rotstmt', parent=parent)
        self.enter_rule(current)
        self.ROT(parent=current)
        self.EQ(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    rotstmt.min_depth = 3

    @depthcontrol
    def scalestmt(self, parent=None):
        current = UnparserRule(name='scalestmt', parent=parent)
        self.enter_rule(current)
        self.SCALE(parent=current)
        self.EQ(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    scalestmt.min_depth = 3

    @depthcontrol
    def colorstmt(self, parent=None):
        current = UnparserRule(name='colorstmt', parent=parent)
        self.enter_rule(current)
        self.COLOR(parent=current)
        self.EQ(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    colorstmt.min_depth = 3

    @depthcontrol
    def hcolorstmt(self, parent=None):
        current = UnparserRule(name='hcolorstmt', parent=parent)
        self.enter_rule(current)
        self.HCOLOR(parent=current)
        self.EQ(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    hcolorstmt.min_depth = 3

    @depthcontrol
    def hlinstmt(self, parent=None):
        current = UnparserRule(name='hlinstmt', parent=parent)
        self.enter_rule(current)
        self.HLIN(parent=current)
        self.expression(parent=current)
        self.COMMA(parent=current)
        self.expression(parent=current)
        self.AT(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    hlinstmt.min_depth = 3

    @depthcontrol
    def vlinstmt(self, parent=None):
        current = UnparserRule(name='vlinstmt', parent=parent)
        self.enter_rule(current)
        self.VLIN(parent=current)
        self.expression(parent=current)
        self.COMMA(parent=current)
        self.expression(parent=current)
        self.AT(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    vlinstmt.min_depth = 3

    @depthcontrol
    def onerrstmt(self, parent=None):
        current = UnparserRule(name='onerrstmt', parent=parent)
        self.enter_rule(current)
        self.ONERR(parent=current)
        self.GOTO(parent=current)
        self.linenumber(parent=current)
        self.exit_rule(current)
        return current
    onerrstmt.min_depth = 2

    @depthcontrol
    def prstmt(self, parent=None):
        current = UnparserRule(name='prstmt', parent=parent)
        self.enter_rule(current)
        self.PRNUMBER(parent=current)
        self.NUMBER(parent=current)
        self.exit_rule(current)
        return current
    prstmt.min_depth = 1

    @depthcontrol
    def instmt(self, parent=None):
        current = UnparserRule(name='instmt', parent=parent)
        self.enter_rule(current)
        self.INNUMBER(parent=current)
        self.NUMBER(parent=current)
        self.exit_rule(current)
        return current
    instmt.min_depth = 1

    @depthcontrol
    def storestmt(self, parent=None):
        current = UnparserRule(name='storestmt', parent=parent)
        self.enter_rule(current)
        self.STORE(parent=current)
        self.vardecl(parent=current)
        self.exit_rule(current)
        return current
    storestmt.min_depth = 4

    @depthcontrol
    def recallstmt(self, parent=None):
        current = UnparserRule(name='recallstmt', parent=parent)
        self.enter_rule(current)
        self.RECALL(parent=current)
        self.vardecl(parent=current)
        self.exit_rule(current)
        return current
    recallstmt.min_depth = 4

    @depthcontrol
    def liststmt(self, parent=None):
        current = UnparserRule(name='liststmt', parent=parent)
        self.enter_rule(current)
        self.LIST(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    liststmt.min_depth = 1

    @depthcontrol
    def popstmt(self, parent=None):
        current = UnparserRule(name='popstmt', parent=parent)
        self.enter_rule(current)
        self.POP(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.expression(parent=current)
                self.COMMA(parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    popstmt.min_depth = 1

    @depthcontrol
    def amptstmt(self, parent=None):
        current = UnparserRule(name='amptstmt', parent=parent)
        self.enter_rule(current)
        self.AMPERSAND(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    amptstmt.min_depth = 3

    @depthcontrol
    def includestmt(self, parent=None):
        current = UnparserRule(name='includestmt', parent=parent)
        self.enter_rule(current)
        self.INCLUDE(parent=current)
        self.expression(parent=current)
        self.exit_rule(current)
        return current
    includestmt.min_depth = 3

    @depthcontrol
    def endstmt(self, parent=None):
        current = UnparserRule(name='endstmt', parent=parent)
        self.enter_rule(current)
        self.END(parent=current)
        self.exit_rule(current)
        return current
    endstmt.min_depth = 1

    @depthcontrol
    def returnstmt(self, parent=None):
        current = UnparserRule(name='returnstmt', parent=parent)
        self.enter_rule(current)
        self.RETURN(parent=current)
        self.exit_rule(current)
        return current
    returnstmt.min_depth = 1

    @depthcontrol
    def restorestmt(self, parent=None):
        current = UnparserRule(name='restorestmt', parent=parent)
        self.enter_rule(current)
        self.RESTORE(parent=current)
        self.exit_rule(current)
        return current
    restorestmt.min_depth = 1

    @depthcontrol
    def number(self, parent=None):
        current = UnparserRule(name='number', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='+', parent=current)
                elif choice == 1:
                    UnlexerRule(src='-', parent=current)
        choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.NUMBER(parent=current)
        elif choice == 1:
            self.FLOAT(parent=current)
        self.exit_rule(current)
        return current
    number.min_depth = 1

    @depthcontrol
    def func_(self, parent=None):
        current = UnparserRule(name='func_', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.STRINGLITERAL(parent=current)
        elif choice == 1:
            self.number(parent=current)
        elif choice == 2:
            self.tabfunc(parent=current)
        elif choice == 3:
            self.vardecl(parent=current)
        elif choice == 4:
            self.chrfunc(parent=current)
        elif choice == 5:
            self.sqrfunc(parent=current)
        elif choice == 6:
            self.lenfunc(parent=current)
        elif choice == 7:
            self.strfunc(parent=current)
        elif choice == 8:
            self.ascfunc(parent=current)
        elif choice == 9:
            self.scrnfunc(parent=current)
        elif choice == 10:
            self.midfunc(parent=current)
        elif choice == 11:
            self.pdlfunc(parent=current)
        elif choice == 12:
            self.peekfunc(parent=current)
        elif choice == 13:
            self.intfunc(parent=current)
        elif choice == 14:
            self.spcfunc(parent=current)
        elif choice == 15:
            self.frefunc(parent=current)
        elif choice == 16:
            self.posfunc(parent=current)
        elif choice == 17:
            self.usrfunc(parent=current)
        elif choice == 18:
            self.leftfunc(parent=current)
        elif choice == 19:
            self.valfunc(parent=current)
        elif choice == 20:
            self.rightfunc(parent=current)
        elif choice == 21:
            self.fnfunc(parent=current)
        elif choice == 22:
            self.sinfunc(parent=current)
        elif choice == 23:
            self.cosfunc(parent=current)
        elif choice == 24:
            self.tanfunc(parent=current)
        elif choice == 25:
            self.atnfunc(parent=current)
        elif choice == 26:
            self.rndfunc(parent=current)
        elif choice == 27:
            self.sgnfunc(parent=current)
        elif choice == 28:
            self.expfunc(parent=current)
        elif choice == 29:
            self.logfunc(parent=current)
        elif choice == 30:
            self.absfunc(parent=current)
        elif choice == 31:
            self.LPAREN(parent=current)
            self.expression(parent=current)
            self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    func_.min_depth = 1

    @depthcontrol
    def signExpression(self, parent=None):
        current = UnparserRule(name='signExpression', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.NOT(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.PLUS(parent=current)
                elif choice == 1:
                    self.MINUS(parent=current)
        self.func_(parent=current)
        self.exit_rule(current)
        return current
    signExpression.min_depth = 2

    @depthcontrol
    def exponentExpression(self, parent=None):
        current = UnparserRule(name='exponentExpression', parent=parent)
        self.enter_rule(current)
        self.signExpression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.EXPONENT(parent=current)
                self.signExpression(parent=current)
        self.exit_rule(current)
        return current
    exponentExpression.min_depth = 3

    @depthcontrol
    def multiplyingExpression(self, parent=None):
        current = UnparserRule(name='multiplyingExpression', parent=parent)
        self.enter_rule(current)
        self.exponentExpression(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.TIMES(parent=current)
                elif choice == 1:
                    self.DIV(parent=current)
                self.exponentExpression(parent=current)
        self.exit_rule(current)
        return current
    multiplyingExpression.min_depth = 4

    @depthcontrol
    def addingExpression(self, parent=None):
        current = UnparserRule(name='addingExpression', parent=parent)
        self.enter_rule(current)
        self.multiplyingExpression(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.PLUS(parent=current)
                elif choice == 1:
                    self.MINUS(parent=current)
                self.multiplyingExpression(parent=current)
        self.exit_rule(current)
        return current
    addingExpression.min_depth = 5

    @depthcontrol
    def relationalExpression(self, parent=None):
        current = UnparserRule(name='relationalExpression', parent=parent)
        self.enter_rule(current)
        self.addingExpression(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.relop(parent=current)
                self.addingExpression(parent=current)
        self.exit_rule(current)
        return current
    relationalExpression.min_depth = 6

    @depthcontrol
    def expression(self, parent=None):
        current = UnparserRule(name='expression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 7][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.func_(parent=current)
        elif choice == 1:
            self.relationalExpression(parent=current)
            if self.max_depth >= 7:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    choice = self.model.choice(current, 1, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                    if choice == 0:
                        self.AND(parent=current)
                    elif choice == 1:
                        self.OR(parent=current)
                    self.relationalExpression(parent=current)
        self.exit_rule(current)
        return current
    expression.min_depth = 2

    @depthcontrol
    def var_(self, parent=None):
        current = UnparserRule(name='var_', parent=parent)
        self.enter_rule(current)
        self.varname(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.varsuffix(parent=current)
        self.exit_rule(current)
        return current
    var_.min_depth = 2

    @depthcontrol
    def varname(self, parent=None):
        current = UnparserRule(name='varname', parent=parent)
        self.enter_rule(current)
        self.LETTERS(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.LETTERS(parent=current)
                elif choice == 1:
                    self.NUMBER(parent=current)
        self.exit_rule(current)
        return current
    varname.min_depth = 1

    @depthcontrol
    def varsuffix(self, parent=None):
        current = UnparserRule(name='varsuffix', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.DOLLAR(parent=current)
        elif choice == 1:
            self.PERCENT(parent=current)
        self.exit_rule(current)
        return current
    varsuffix.min_depth = 1

    @depthcontrol
    def varlist(self, parent=None):
        current = UnparserRule(name='varlist', parent=parent)
        self.enter_rule(current)
        self.vardecl(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.COMMA(parent=current)
                self.vardecl(parent=current)
        self.exit_rule(current)
        return current
    varlist.min_depth = 4

    @depthcontrol
    def exprlist(self, parent=None):
        current = UnparserRule(name='exprlist', parent=parent)
        self.enter_rule(current)
        self.expression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.COMMA(parent=current)
                self.expression(parent=current)
        self.exit_rule(current)
        return current
    exprlist.min_depth = 3

    @depthcontrol
    def sqrfunc(self, parent=None):
        current = UnparserRule(name='sqrfunc', parent=parent)
        self.enter_rule(current)
        self.SQR(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    sqrfunc.min_depth = 3

    @depthcontrol
    def chrfunc(self, parent=None):
        current = UnparserRule(name='chrfunc', parent=parent)
        self.enter_rule(current)
        self.CHR(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    chrfunc.min_depth = 3

    @depthcontrol
    def lenfunc(self, parent=None):
        current = UnparserRule(name='lenfunc', parent=parent)
        self.enter_rule(current)
        self.LEN(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    lenfunc.min_depth = 3

    @depthcontrol
    def ascfunc(self, parent=None):
        current = UnparserRule(name='ascfunc', parent=parent)
        self.enter_rule(current)
        self.ASC(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    ascfunc.min_depth = 3

    @depthcontrol
    def midfunc(self, parent=None):
        current = UnparserRule(name='midfunc', parent=parent)
        self.enter_rule(current)
        self.MID(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.COMMA(parent=current)
        self.expression(parent=current)
        self.COMMA(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    midfunc.min_depth = 3

    @depthcontrol
    def pdlfunc(self, parent=None):
        current = UnparserRule(name='pdlfunc', parent=parent)
        self.enter_rule(current)
        self.PDL(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    pdlfunc.min_depth = 3

    @depthcontrol
    def peekfunc(self, parent=None):
        current = UnparserRule(name='peekfunc', parent=parent)
        self.enter_rule(current)
        self.PEEK(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    peekfunc.min_depth = 3

    @depthcontrol
    def intfunc(self, parent=None):
        current = UnparserRule(name='intfunc', parent=parent)
        self.enter_rule(current)
        self.INTF(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    intfunc.min_depth = 3

    @depthcontrol
    def spcfunc(self, parent=None):
        current = UnparserRule(name='spcfunc', parent=parent)
        self.enter_rule(current)
        self.SPC(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    spcfunc.min_depth = 3

    @depthcontrol
    def frefunc(self, parent=None):
        current = UnparserRule(name='frefunc', parent=parent)
        self.enter_rule(current)
        self.FRE(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    frefunc.min_depth = 3

    @depthcontrol
    def posfunc(self, parent=None):
        current = UnparserRule(name='posfunc', parent=parent)
        self.enter_rule(current)
        self.POS(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    posfunc.min_depth = 3

    @depthcontrol
    def usrfunc(self, parent=None):
        current = UnparserRule(name='usrfunc', parent=parent)
        self.enter_rule(current)
        self.USR(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    usrfunc.min_depth = 3

    @depthcontrol
    def leftfunc(self, parent=None):
        current = UnparserRule(name='leftfunc', parent=parent)
        self.enter_rule(current)
        self.LEFT(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.COMMA(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    leftfunc.min_depth = 3

    @depthcontrol
    def rightfunc(self, parent=None):
        current = UnparserRule(name='rightfunc', parent=parent)
        self.enter_rule(current)
        self.RIGHT(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.COMMA(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    rightfunc.min_depth = 3

    @depthcontrol
    def strfunc(self, parent=None):
        current = UnparserRule(name='strfunc', parent=parent)
        self.enter_rule(current)
        self.STR(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    strfunc.min_depth = 3

    @depthcontrol
    def fnfunc(self, parent=None):
        current = UnparserRule(name='fnfunc', parent=parent)
        self.enter_rule(current)
        self.FN(parent=current)
        self.var_(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    fnfunc.min_depth = 3

    @depthcontrol
    def valfunc(self, parent=None):
        current = UnparserRule(name='valfunc', parent=parent)
        self.enter_rule(current)
        self.VAL(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    valfunc.min_depth = 3

    @depthcontrol
    def scrnfunc(self, parent=None):
        current = UnparserRule(name='scrnfunc', parent=parent)
        self.enter_rule(current)
        self.SCRN(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.COMMA(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    scrnfunc.min_depth = 3

    @depthcontrol
    def sinfunc(self, parent=None):
        current = UnparserRule(name='sinfunc', parent=parent)
        self.enter_rule(current)
        self.SIN(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    sinfunc.min_depth = 3

    @depthcontrol
    def cosfunc(self, parent=None):
        current = UnparserRule(name='cosfunc', parent=parent)
        self.enter_rule(current)
        self.COS(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    cosfunc.min_depth = 3

    @depthcontrol
    def tanfunc(self, parent=None):
        current = UnparserRule(name='tanfunc', parent=parent)
        self.enter_rule(current)
        self.TAN(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    tanfunc.min_depth = 3

    @depthcontrol
    def atnfunc(self, parent=None):
        current = UnparserRule(name='atnfunc', parent=parent)
        self.enter_rule(current)
        self.ATN(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    atnfunc.min_depth = 3

    @depthcontrol
    def rndfunc(self, parent=None):
        current = UnparserRule(name='rndfunc', parent=parent)
        self.enter_rule(current)
        self.RND(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    rndfunc.min_depth = 3

    @depthcontrol
    def sgnfunc(self, parent=None):
        current = UnparserRule(name='sgnfunc', parent=parent)
        self.enter_rule(current)
        self.SGN(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    sgnfunc.min_depth = 3

    @depthcontrol
    def expfunc(self, parent=None):
        current = UnparserRule(name='expfunc', parent=parent)
        self.enter_rule(current)
        self.EXP(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    expfunc.min_depth = 3

    @depthcontrol
    def logfunc(self, parent=None):
        current = UnparserRule(name='logfunc', parent=parent)
        self.enter_rule(current)
        self.LOG(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    logfunc.min_depth = 3

    @depthcontrol
    def absfunc(self, parent=None):
        current = UnparserRule(name='absfunc', parent=parent)
        self.enter_rule(current)
        self.ABS(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    absfunc.min_depth = 3

    @depthcontrol
    def tabfunc(self, parent=None):
        current = UnparserRule(name='tabfunc', parent=parent)
        self.enter_rule(current)
        self.TAB(parent=current)
        self.LPAREN(parent=current)
        self.expression(parent=current)
        self.RPAREN(parent=current)
        self.exit_rule(current)
        return current
    tabfunc.min_depth = 3

    @depthcontrol
    def DOLLAR(self, parent=None):
        current = UnlexerRule(name='DOLLAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='$', parent=current)
        self.exit_rule(current)
        return current
    DOLLAR.min_depth = 0

    @depthcontrol
    def PERCENT(self, parent=None):
        current = UnlexerRule(name='PERCENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='%', parent=current)
        self.exit_rule(current)
        return current
    PERCENT.min_depth = 0

    @depthcontrol
    def RETURN(self, parent=None):
        current = UnlexerRule(name='RETURN', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='RETURN', parent=current)
        elif choice == 1:
            UnlexerRule(src='return', parent=current)
        self.exit_rule(current)
        return current
    RETURN.min_depth = 0

    @depthcontrol
    def PRINT(self, parent=None):
        current = UnlexerRule(name='PRINT', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='PRINT', parent=current)
        elif choice == 1:
            UnlexerRule(src='print', parent=current)
        self.exit_rule(current)
        return current
    PRINT.min_depth = 0

    @depthcontrol
    def GOTO(self, parent=None):
        current = UnlexerRule(name='GOTO', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='GOTO', parent=current)
        elif choice == 1:
            UnlexerRule(src='goto', parent=current)
        self.exit_rule(current)
        return current
    GOTO.min_depth = 0

    @depthcontrol
    def GOSUB(self, parent=None):
        current = UnlexerRule(name='GOSUB', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='GOSUB', parent=current)
        elif choice == 1:
            UnlexerRule(src='gosub', parent=current)
        self.exit_rule(current)
        return current
    GOSUB.min_depth = 0

    @depthcontrol
    def IF(self, parent=None):
        current = UnlexerRule(name='IF', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='IF', parent=current)
        elif choice == 1:
            UnlexerRule(src='if', parent=current)
        self.exit_rule(current)
        return current
    IF.min_depth = 0

    @depthcontrol
    def NEXT(self, parent=None):
        current = UnlexerRule(name='NEXT', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='NEXT', parent=current)
        elif choice == 1:
            UnlexerRule(src='next', parent=current)
        self.exit_rule(current)
        return current
    NEXT.min_depth = 0

    @depthcontrol
    def THEN(self, parent=None):
        current = UnlexerRule(name='THEN', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='THEN', parent=current)
        elif choice == 1:
            UnlexerRule(src='then', parent=current)
        self.exit_rule(current)
        return current
    THEN.min_depth = 0

    @depthcontrol
    def REM(self, parent=None):
        current = UnlexerRule(name='REM', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='REM', parent=current)
        elif choice == 1:
            UnlexerRule(src='rem', parent=current)
        self.exit_rule(current)
        return current
    REM.min_depth = 0

    @depthcontrol
    def CHR(self, parent=None):
        current = UnlexerRule(name='CHR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CHR$', parent=current)
        self.exit_rule(current)
        return current
    CHR.min_depth = 0

    @depthcontrol
    def MID(self, parent=None):
        current = UnlexerRule(name='MID', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='MID$', parent=current)
        self.exit_rule(current)
        return current
    MID.min_depth = 0

    @depthcontrol
    def LEFT(self, parent=None):
        current = UnlexerRule(name='LEFT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='LEFT$', parent=current)
        self.exit_rule(current)
        return current
    LEFT.min_depth = 0

    @depthcontrol
    def RIGHT(self, parent=None):
        current = UnlexerRule(name='RIGHT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='RIGHT$', parent=current)
        self.exit_rule(current)
        return current
    RIGHT.min_depth = 0

    @depthcontrol
    def STR(self, parent=None):
        current = UnlexerRule(name='STR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='STR$', parent=current)
        self.exit_rule(current)
        return current
    STR.min_depth = 0

    @depthcontrol
    def LPAREN(self, parent=None):
        current = UnlexerRule(name='LPAREN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        self.exit_rule(current)
        return current
    LPAREN.min_depth = 0

    @depthcontrol
    def RPAREN(self, parent=None):
        current = UnlexerRule(name='RPAREN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    RPAREN.min_depth = 0

    @depthcontrol
    def PLUS(self, parent=None):
        current = UnlexerRule(name='PLUS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='+', parent=current)
        self.exit_rule(current)
        return current
    PLUS.min_depth = 0

    @depthcontrol
    def MINUS(self, parent=None):
        current = UnlexerRule(name='MINUS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='-', parent=current)
        self.exit_rule(current)
        return current
    MINUS.min_depth = 0

    @depthcontrol
    def TIMES(self, parent=None):
        current = UnlexerRule(name='TIMES', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='*', parent=current)
        self.exit_rule(current)
        return current
    TIMES.min_depth = 0

    @depthcontrol
    def DIV(self, parent=None):
        current = UnlexerRule(name='DIV', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='/', parent=current)
        self.exit_rule(current)
        return current
    DIV.min_depth = 0

    @depthcontrol
    def CLEAR(self, parent=None):
        current = UnlexerRule(name='CLEAR', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='CLEAR', parent=current)
        elif choice == 1:
            UnlexerRule(src='clear', parent=current)
        self.exit_rule(current)
        return current
    CLEAR.min_depth = 0

    @depthcontrol
    def GTE(self, parent=None):
        current = UnlexerRule(name='GTE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='>: ', parent=current)
        self.exit_rule(current)
        return current
    GTE.min_depth = 0

    @depthcontrol
    def LTE(self, parent=None):
        current = UnlexerRule(name='LTE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<: ', parent=current)
        self.exit_rule(current)
        return current
    LTE.min_depth = 0

    @depthcontrol
    def GT(self, parent=None):
        current = UnlexerRule(name='GT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='>', parent=current)
        self.exit_rule(current)
        return current
    GT.min_depth = 0

    @depthcontrol
    def LT(self, parent=None):
        current = UnlexerRule(name='LT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<', parent=current)
        self.exit_rule(current)
        return current
    LT.min_depth = 0

    @depthcontrol
    def COMMA(self, parent=None):
        current = UnlexerRule(name='COMMA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=',', parent=current)
        self.exit_rule(current)
        return current
    COMMA.min_depth = 0

    @depthcontrol
    def LIST(self, parent=None):
        current = UnlexerRule(name='LIST', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='LIST', parent=current)
        elif choice == 1:
            UnlexerRule(src='list', parent=current)
        self.exit_rule(current)
        return current
    LIST.min_depth = 0

    @depthcontrol
    def RUN(self, parent=None):
        current = UnlexerRule(name='RUN', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='RUN', parent=current)
        elif choice == 1:
            UnlexerRule(src='run', parent=current)
        self.exit_rule(current)
        return current
    RUN.min_depth = 0

    @depthcontrol
    def END(self, parent=None):
        current = UnlexerRule(name='END', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='END', parent=current)
        elif choice == 1:
            UnlexerRule(src='end', parent=current)
        self.exit_rule(current)
        return current
    END.min_depth = 0

    @depthcontrol
    def LET(self, parent=None):
        current = UnlexerRule(name='LET', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='LET', parent=current)
        elif choice == 1:
            UnlexerRule(src='let', parent=current)
        self.exit_rule(current)
        return current
    LET.min_depth = 0

    @depthcontrol
    def EQ(self, parent=None):
        current = UnlexerRule(name='EQ', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='=', parent=current)
        self.exit_rule(current)
        return current
    EQ.min_depth = 0

    @depthcontrol
    def FOR(self, parent=None):
        current = UnlexerRule(name='FOR', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='FOR', parent=current)
        elif choice == 1:
            UnlexerRule(src='for', parent=current)
        self.exit_rule(current)
        return current
    FOR.min_depth = 0

    @depthcontrol
    def TO(self, parent=None):
        current = UnlexerRule(name='TO', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='TO', parent=current)
        elif choice == 1:
            UnlexerRule(src='to', parent=current)
        self.exit_rule(current)
        return current
    TO.min_depth = 0

    @depthcontrol
    def STEP(self, parent=None):
        current = UnlexerRule(name='STEP', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='STEP', parent=current)
        elif choice == 1:
            UnlexerRule(src='step', parent=current)
        self.exit_rule(current)
        return current
    STEP.min_depth = 0

    @depthcontrol
    def INPUT(self, parent=None):
        current = UnlexerRule(name='INPUT', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='INPUT', parent=current)
        elif choice == 1:
            UnlexerRule(src='input', parent=current)
        self.exit_rule(current)
        return current
    INPUT.min_depth = 0

    @depthcontrol
    def SEMICOLON(self, parent=None):
        current = UnlexerRule(name='SEMICOLON', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=';', parent=current)
        self.exit_rule(current)
        return current
    SEMICOLON.min_depth = 0

    @depthcontrol
    def DIM(self, parent=None):
        current = UnlexerRule(name='DIM', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='DIM', parent=current)
        elif choice == 1:
            UnlexerRule(src='dim', parent=current)
        self.exit_rule(current)
        return current
    DIM.min_depth = 0

    @depthcontrol
    def SQR(self, parent=None):
        current = UnlexerRule(name='SQR', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='SQR', parent=current)
        elif choice == 1:
            UnlexerRule(src='sqr', parent=current)
        self.exit_rule(current)
        return current
    SQR.min_depth = 0

    @depthcontrol
    def COLON(self, parent=None):
        current = UnlexerRule(name='COLON', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=':', parent=current)
        self.exit_rule(current)
        return current
    COLON.min_depth = 0

    @depthcontrol
    def TEXT(self, parent=None):
        current = UnlexerRule(name='TEXT', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='TEXT', parent=current)
        elif choice == 1:
            UnlexerRule(src='text', parent=current)
        self.exit_rule(current)
        return current
    TEXT.min_depth = 0

    @depthcontrol
    def HGR(self, parent=None):
        current = UnlexerRule(name='HGR', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='HGR', parent=current)
        elif choice == 1:
            UnlexerRule(src='hgr', parent=current)
        self.exit_rule(current)
        return current
    HGR.min_depth = 0

    @depthcontrol
    def HGR2(self, parent=None):
        current = UnlexerRule(name='HGR2', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='HGR2', parent=current)
        elif choice == 1:
            UnlexerRule(src='hgr2', parent=current)
        self.exit_rule(current)
        return current
    HGR2.min_depth = 0

    @depthcontrol
    def LEN(self, parent=None):
        current = UnlexerRule(name='LEN', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='LEN', parent=current)
        elif choice == 1:
            UnlexerRule(src='len', parent=current)
        self.exit_rule(current)
        return current
    LEN.min_depth = 0

    @depthcontrol
    def CALL(self, parent=None):
        current = UnlexerRule(name='CALL', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='CALL', parent=current)
        elif choice == 1:
            UnlexerRule(src='call', parent=current)
        self.exit_rule(current)
        return current
    CALL.min_depth = 0

    @depthcontrol
    def ASC(self, parent=None):
        current = UnlexerRule(name='ASC', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='ASC', parent=current)
        elif choice == 1:
            UnlexerRule(src='asc', parent=current)
        self.exit_rule(current)
        return current
    ASC.min_depth = 0

    @depthcontrol
    def HPLOT(self, parent=None):
        current = UnlexerRule(name='HPLOT', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='HPLOT', parent=current)
        elif choice == 1:
            UnlexerRule(src='hplot', parent=current)
        self.exit_rule(current)
        return current
    HPLOT.min_depth = 0

    @depthcontrol
    def VPLOT(self, parent=None):
        current = UnlexerRule(name='VPLOT', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='VPLOT', parent=current)
        elif choice == 1:
            UnlexerRule(src='vplot', parent=current)
        self.exit_rule(current)
        return current
    VPLOT.min_depth = 0

    @depthcontrol
    def PRNUMBER(self, parent=None):
        current = UnlexerRule(name='PRNUMBER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='PR#', parent=current)
        self.exit_rule(current)
        return current
    PRNUMBER.min_depth = 0

    @depthcontrol
    def INNUMBER(self, parent=None):
        current = UnlexerRule(name='INNUMBER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='IN#', parent=current)
        self.exit_rule(current)
        return current
    INNUMBER.min_depth = 0

    @depthcontrol
    def VTAB(self, parent=None):
        current = UnlexerRule(name='VTAB', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='VTAB', parent=current)
        elif choice == 1:
            UnlexerRule(src='vtab', parent=current)
        self.exit_rule(current)
        return current
    VTAB.min_depth = 0

    @depthcontrol
    def HTAB(self, parent=None):
        current = UnlexerRule(name='HTAB', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='HTAB', parent=current)
        elif choice == 1:
            UnlexerRule(src='htab', parent=current)
        self.exit_rule(current)
        return current
    HTAB.min_depth = 0

    @depthcontrol
    def HOME(self, parent=None):
        current = UnlexerRule(name='HOME', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='HOME', parent=current)
        elif choice == 1:
            UnlexerRule(src='home', parent=current)
        self.exit_rule(current)
        return current
    HOME.min_depth = 0

    @depthcontrol
    def ON(self, parent=None):
        current = UnlexerRule(name='ON', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='ON', parent=current)
        elif choice == 1:
            UnlexerRule(src='on', parent=current)
        self.exit_rule(current)
        return current
    ON.min_depth = 0

    @depthcontrol
    def PDL(self, parent=None):
        current = UnlexerRule(name='PDL', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='PDL', parent=current)
        elif choice == 1:
            UnlexerRule(src='pdl', parent=current)
        self.exit_rule(current)
        return current
    PDL.min_depth = 0

    @depthcontrol
    def PLOT(self, parent=None):
        current = UnlexerRule(name='PLOT', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='PLOT', parent=current)
        elif choice == 1:
            UnlexerRule(src='plot', parent=current)
        self.exit_rule(current)
        return current
    PLOT.min_depth = 0

    @depthcontrol
    def PEEK(self, parent=None):
        current = UnlexerRule(name='PEEK', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='PEEK', parent=current)
        elif choice == 1:
            UnlexerRule(src='peek', parent=current)
        self.exit_rule(current)
        return current
    PEEK.min_depth = 0

    @depthcontrol
    def POKE(self, parent=None):
        current = UnlexerRule(name='POKE', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='POKE', parent=current)
        elif choice == 1:
            UnlexerRule(src='poke', parent=current)
        self.exit_rule(current)
        return current
    POKE.min_depth = 0

    @depthcontrol
    def INTF(self, parent=None):
        current = UnlexerRule(name='INTF', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='INT', parent=current)
        elif choice == 1:
            UnlexerRule(src='int', parent=current)
        self.exit_rule(current)
        return current
    INTF.min_depth = 0

    @depthcontrol
    def STOP(self, parent=None):
        current = UnlexerRule(name='STOP', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='STOP', parent=current)
        elif choice == 1:
            UnlexerRule(src='stop', parent=current)
        self.exit_rule(current)
        return current
    STOP.min_depth = 0

    @depthcontrol
    def HIMEM(self, parent=None):
        current = UnlexerRule(name='HIMEM', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='HIMEM', parent=current)
        elif choice == 1:
            UnlexerRule(src='himem', parent=current)
        self.exit_rule(current)
        return current
    HIMEM.min_depth = 0

    @depthcontrol
    def LOMEM(self, parent=None):
        current = UnlexerRule(name='LOMEM', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='LOMEM', parent=current)
        elif choice == 1:
            UnlexerRule(src='lomem', parent=current)
        self.exit_rule(current)
        return current
    LOMEM.min_depth = 0

    @depthcontrol
    def FLASH(self, parent=None):
        current = UnlexerRule(name='FLASH', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='FLASH', parent=current)
        elif choice == 1:
            UnlexerRule(src='flash', parent=current)
        self.exit_rule(current)
        return current
    FLASH.min_depth = 0

    @depthcontrol
    def INVERSE(self, parent=None):
        current = UnlexerRule(name='INVERSE', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='INVERSE', parent=current)
        elif choice == 1:
            UnlexerRule(src='inverse', parent=current)
        self.exit_rule(current)
        return current
    INVERSE.min_depth = 0

    @depthcontrol
    def NORMAL(self, parent=None):
        current = UnlexerRule(name='NORMAL', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='NORMAL', parent=current)
        elif choice == 1:
            UnlexerRule(src='normal', parent=current)
        self.exit_rule(current)
        return current
    NORMAL.min_depth = 0

    @depthcontrol
    def ONERR(self, parent=None):
        current = UnlexerRule(name='ONERR', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='ONERR', parent=current)
        elif choice == 1:
            UnlexerRule(src='onerr', parent=current)
        self.exit_rule(current)
        return current
    ONERR.min_depth = 0

    @depthcontrol
    def SPC(self, parent=None):
        current = UnlexerRule(name='SPC', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='SPC', parent=current)
        elif choice == 1:
            UnlexerRule(src='spc', parent=current)
        self.exit_rule(current)
        return current
    SPC.min_depth = 0

    @depthcontrol
    def FRE(self, parent=None):
        current = UnlexerRule(name='FRE', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='FRE', parent=current)
        elif choice == 1:
            UnlexerRule(src='fre', parent=current)
        self.exit_rule(current)
        return current
    FRE.min_depth = 0

    @depthcontrol
    def POS(self, parent=None):
        current = UnlexerRule(name='POS', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='POS', parent=current)
        elif choice == 1:
            UnlexerRule(src='pos', parent=current)
        self.exit_rule(current)
        return current
    POS.min_depth = 0

    @depthcontrol
    def USR(self, parent=None):
        current = UnlexerRule(name='USR', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='USR', parent=current)
        elif choice == 1:
            UnlexerRule(src='usr', parent=current)
        self.exit_rule(current)
        return current
    USR.min_depth = 0

    @depthcontrol
    def TRACE(self, parent=None):
        current = UnlexerRule(name='TRACE', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='TRACE', parent=current)
        elif choice == 1:
            UnlexerRule(src='trace', parent=current)
        self.exit_rule(current)
        return current
    TRACE.min_depth = 0

    @depthcontrol
    def NOTRACE(self, parent=None):
        current = UnlexerRule(name='NOTRACE', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='NOTRACE', parent=current)
        elif choice == 1:
            UnlexerRule(src='notrace', parent=current)
        self.exit_rule(current)
        return current
    NOTRACE.min_depth = 0

    @depthcontrol
    def AND(self, parent=None):
        current = UnlexerRule(name='AND', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='AND', parent=current)
        elif choice == 1:
            UnlexerRule(src='and', parent=current)
        self.exit_rule(current)
        return current
    AND.min_depth = 0

    @depthcontrol
    def OR(self, parent=None):
        current = UnlexerRule(name='OR', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='OR', parent=current)
        elif choice == 1:
            UnlexerRule(src='or', parent=current)
        self.exit_rule(current)
        return current
    OR.min_depth = 0

    @depthcontrol
    def DATA(self, parent=None):
        current = UnlexerRule(name='DATA', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='DATA', parent=current)
        elif choice == 1:
            UnlexerRule(src='data', parent=current)
        self.exit_rule(current)
        return current
    DATA.min_depth = 0

    @depthcontrol
    def WAIT(self, parent=None):
        current = UnlexerRule(name='WAIT', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='WAIT', parent=current)
        elif choice == 1:
            UnlexerRule(src='wait', parent=current)
        self.exit_rule(current)
        return current
    WAIT.min_depth = 0

    @depthcontrol
    def READ(self, parent=None):
        current = UnlexerRule(name='READ', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='READ', parent=current)
        elif choice == 1:
            UnlexerRule(src='read', parent=current)
        self.exit_rule(current)
        return current
    READ.min_depth = 0

    @depthcontrol
    def XDRAW(self, parent=None):
        current = UnlexerRule(name='XDRAW', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='XDRAW', parent=current)
        elif choice == 1:
            UnlexerRule(src='xdraw', parent=current)
        self.exit_rule(current)
        return current
    XDRAW.min_depth = 0

    @depthcontrol
    def DRAW(self, parent=None):
        current = UnlexerRule(name='DRAW', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='DRAW', parent=current)
        elif choice == 1:
            UnlexerRule(src='draw', parent=current)
        self.exit_rule(current)
        return current
    DRAW.min_depth = 0

    @depthcontrol
    def AT(self, parent=None):
        current = UnlexerRule(name='AT', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='AT', parent=current)
        elif choice == 1:
            UnlexerRule(src='at', parent=current)
        self.exit_rule(current)
        return current
    AT.min_depth = 0

    @depthcontrol
    def DEF(self, parent=None):
        current = UnlexerRule(name='DEF', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='DEF', parent=current)
        elif choice == 1:
            UnlexerRule(src='def', parent=current)
        self.exit_rule(current)
        return current
    DEF.min_depth = 0

    @depthcontrol
    def FN(self, parent=None):
        current = UnlexerRule(name='FN', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='FN', parent=current)
        elif choice == 1:
            UnlexerRule(src='fn', parent=current)
        self.exit_rule(current)
        return current
    FN.min_depth = 0

    @depthcontrol
    def VAL(self, parent=None):
        current = UnlexerRule(name='VAL', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='VAL', parent=current)
        elif choice == 1:
            UnlexerRule(src='val', parent=current)
        self.exit_rule(current)
        return current
    VAL.min_depth = 0

    @depthcontrol
    def TAB(self, parent=None):
        current = UnlexerRule(name='TAB', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='TAB', parent=current)
        elif choice == 1:
            UnlexerRule(src='tab', parent=current)
        self.exit_rule(current)
        return current
    TAB.min_depth = 0

    @depthcontrol
    def SPEED(self, parent=None):
        current = UnlexerRule(name='SPEED', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='SPEED', parent=current)
        elif choice == 1:
            UnlexerRule(src='speed', parent=current)
        self.exit_rule(current)
        return current
    SPEED.min_depth = 0

    @depthcontrol
    def ROT(self, parent=None):
        current = UnlexerRule(name='ROT', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='ROT', parent=current)
        elif choice == 1:
            UnlexerRule(src='rot', parent=current)
        self.exit_rule(current)
        return current
    ROT.min_depth = 0

    @depthcontrol
    def SCALE(self, parent=None):
        current = UnlexerRule(name='SCALE', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='SCALE', parent=current)
        elif choice == 1:
            UnlexerRule(src='scale', parent=current)
        self.exit_rule(current)
        return current
    SCALE.min_depth = 0

    @depthcontrol
    def COLOR(self, parent=None):
        current = UnlexerRule(name='COLOR', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='COLOR', parent=current)
        elif choice == 1:
            UnlexerRule(src='color', parent=current)
        self.exit_rule(current)
        return current
    COLOR.min_depth = 0

    @depthcontrol
    def HCOLOR(self, parent=None):
        current = UnlexerRule(name='HCOLOR', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='HCOLOR', parent=current)
        elif choice == 1:
            UnlexerRule(src='hcolor', parent=current)
        self.exit_rule(current)
        return current
    HCOLOR.min_depth = 0

    @depthcontrol
    def HLIN(self, parent=None):
        current = UnlexerRule(name='HLIN', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='HLIN', parent=current)
        elif choice == 1:
            UnlexerRule(src='hlin', parent=current)
        self.exit_rule(current)
        return current
    HLIN.min_depth = 0

    @depthcontrol
    def VLIN(self, parent=None):
        current = UnlexerRule(name='VLIN', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='VLIN', parent=current)
        elif choice == 1:
            UnlexerRule(src='vlin', parent=current)
        self.exit_rule(current)
        return current
    VLIN.min_depth = 0

    @depthcontrol
    def SCRN(self, parent=None):
        current = UnlexerRule(name='SCRN', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='SCRN', parent=current)
        elif choice == 1:
            UnlexerRule(src='scrn', parent=current)
        self.exit_rule(current)
        return current
    SCRN.min_depth = 0

    @depthcontrol
    def POP(self, parent=None):
        current = UnlexerRule(name='POP', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='POP', parent=current)
        elif choice == 1:
            UnlexerRule(src='pop', parent=current)
        self.exit_rule(current)
        return current
    POP.min_depth = 0

    @depthcontrol
    def SHLOAD(self, parent=None):
        current = UnlexerRule(name='SHLOAD', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='SHLOAD', parent=current)
        elif choice == 1:
            UnlexerRule(src='shload', parent=current)
        self.exit_rule(current)
        return current
    SHLOAD.min_depth = 0

    @depthcontrol
    def SIN(self, parent=None):
        current = UnlexerRule(name='SIN', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='SIN', parent=current)
        elif choice == 1:
            UnlexerRule(src='sin', parent=current)
        self.exit_rule(current)
        return current
    SIN.min_depth = 0

    @depthcontrol
    def COS(self, parent=None):
        current = UnlexerRule(name='COS', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='COS', parent=current)
        elif choice == 1:
            UnlexerRule(src='cos', parent=current)
        self.exit_rule(current)
        return current
    COS.min_depth = 0

    @depthcontrol
    def TAN(self, parent=None):
        current = UnlexerRule(name='TAN', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='TAN', parent=current)
        elif choice == 1:
            UnlexerRule(src='tan', parent=current)
        self.exit_rule(current)
        return current
    TAN.min_depth = 0

    @depthcontrol
    def ATN(self, parent=None):
        current = UnlexerRule(name='ATN', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='ATN', parent=current)
        elif choice == 1:
            UnlexerRule(src='atn', parent=current)
        self.exit_rule(current)
        return current
    ATN.min_depth = 0

    @depthcontrol
    def RND(self, parent=None):
        current = UnlexerRule(name='RND', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='RND', parent=current)
        elif choice == 1:
            UnlexerRule(src='rnd', parent=current)
        self.exit_rule(current)
        return current
    RND.min_depth = 0

    @depthcontrol
    def SGN(self, parent=None):
        current = UnlexerRule(name='SGN', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='SGN', parent=current)
        elif choice == 1:
            UnlexerRule(src='sgn', parent=current)
        self.exit_rule(current)
        return current
    SGN.min_depth = 0

    @depthcontrol
    def EXP(self, parent=None):
        current = UnlexerRule(name='EXP', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='EXP', parent=current)
        elif choice == 1:
            UnlexerRule(src='exp', parent=current)
        self.exit_rule(current)
        return current
    EXP.min_depth = 0

    @depthcontrol
    def LOG(self, parent=None):
        current = UnlexerRule(name='LOG', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='LOG', parent=current)
        elif choice == 1:
            UnlexerRule(src='log', parent=current)
        self.exit_rule(current)
        return current
    LOG.min_depth = 0

    @depthcontrol
    def ABS(self, parent=None):
        current = UnlexerRule(name='ABS', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='ABS', parent=current)
        elif choice == 1:
            UnlexerRule(src='abs', parent=current)
        self.exit_rule(current)
        return current
    ABS.min_depth = 0

    @depthcontrol
    def STORE(self, parent=None):
        current = UnlexerRule(name='STORE', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='STORE', parent=current)
        elif choice == 1:
            UnlexerRule(src='store', parent=current)
        self.exit_rule(current)
        return current
    STORE.min_depth = 0

    @depthcontrol
    def RECALL(self, parent=None):
        current = UnlexerRule(name='RECALL', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='RECALL', parent=current)
        elif choice == 1:
            UnlexerRule(src='recall', parent=current)
        self.exit_rule(current)
        return current
    RECALL.min_depth = 0

    @depthcontrol
    def GET(self, parent=None):
        current = UnlexerRule(name='GET', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='GET', parent=current)
        elif choice == 1:
            UnlexerRule(src='get', parent=current)
        self.exit_rule(current)
        return current
    GET.min_depth = 0

    @depthcontrol
    def EXPONENT(self, parent=None):
        current = UnlexerRule(name='EXPONENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='^', parent=current)
        self.exit_rule(current)
        return current
    EXPONENT.min_depth = 0

    @depthcontrol
    def AMPERSAND(self, parent=None):
        current = UnlexerRule(name='AMPERSAND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='&', parent=current)
        self.exit_rule(current)
        return current
    AMPERSAND.min_depth = 0

    @depthcontrol
    def GR(self, parent=None):
        current = UnlexerRule(name='GR', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='GR', parent=current)
        elif choice == 1:
            UnlexerRule(src='gr', parent=current)
        self.exit_rule(current)
        return current
    GR.min_depth = 0

    @depthcontrol
    def NOT(self, parent=None):
        current = UnlexerRule(name='NOT', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='NOT', parent=current)
        elif choice == 1:
            UnlexerRule(src='not', parent=current)
        self.exit_rule(current)
        return current
    NOT.min_depth = 0

    @depthcontrol
    def RESTORE(self, parent=None):
        current = UnlexerRule(name='RESTORE', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='RESTORE', parent=current)
        elif choice == 1:
            UnlexerRule(src='restore', parent=current)
        self.exit_rule(current)
        return current
    RESTORE.min_depth = 0

    @depthcontrol
    def SAVE(self, parent=None):
        current = UnlexerRule(name='SAVE', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='SAVE', parent=current)
        elif choice == 1:
            UnlexerRule(src='save', parent=current)
        self.exit_rule(current)
        return current
    SAVE.min_depth = 0

    @depthcontrol
    def LOAD(self, parent=None):
        current = UnlexerRule(name='LOAD', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='LOAD', parent=current)
        elif choice == 1:
            UnlexerRule(src='load', parent=current)
        self.exit_rule(current)
        return current
    LOAD.min_depth = 0

    @depthcontrol
    def QUESTION(self, parent=None):
        current = UnlexerRule(name='QUESTION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='?', parent=current)
        self.exit_rule(current)
        return current
    QUESTION.min_depth = 0

    @depthcontrol
    def INCLUDE(self, parent=None):
        current = UnlexerRule(name='INCLUDE', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='INCLUDE', parent=current)
        elif choice == 1:
            UnlexerRule(src='include', parent=current)
        self.exit_rule(current)
        return current
    INCLUDE.min_depth = 0

    @depthcontrol
    def CLS(self, parent=None):
        current = UnlexerRule(name='CLS', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='CLS', parent=current)
        elif choice == 1:
            UnlexerRule(src='cls', parent=current)
        self.exit_rule(current)
        return current
    CLS.min_depth = 0

    @depthcontrol
    def COMMENT(self, parent=None):
        current = UnlexerRule(name='COMMENT', parent=parent)
        self.enter_rule(current)
        self.REM(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[1]), parent=current)
        self.exit_rule(current)
        return current
    COMMENT.min_depth = 1

    @depthcontrol
    def STRINGLITERAL(self, parent=None):
        current = UnlexerRule(name='STRINGLITERAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='"', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[2]), parent=current)
        UnlexerRule(src='"', parent=current)
        self.exit_rule(current)
        return current
    STRINGLITERAL.min_depth = 0

    @depthcontrol
    def LETTERS(self, parent=None):
        current = UnlexerRule(name='LETTERS', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src=self.model.charset(current, 0, self._charsets[3]), parent=current)
                elif choice == 1:
                    UnlexerRule(src=self.model.charset(current, 1, self._charsets[4]), parent=current)
        self.exit_rule(current)
        return current
    LETTERS.min_depth = 0

    @depthcontrol
    def NUMBER(self, parent=None):
        current = UnlexerRule(name='NUMBER', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[5]), parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='e', parent=current)
                elif choice == 1:
                    UnlexerRule(src='E', parent=current)
                self.NUMBER(parent=current)
        self.exit_rule(current)
        return current
    NUMBER.min_depth = 0

    @depthcontrol
    def FLOAT(self, parent=None):
        current = UnlexerRule(name='FLOAT', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[6]), parent=current)
        UnlexerRule(src='.', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 1, self._charsets[7]), parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 2, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    UnlexerRule(src='e', parent=current)
                elif choice == 1:
                    UnlexerRule(src='E', parent=current)
                if self.max_depth >= 0:
                    for _ in self.model.quantify(current, 3, min=1, max=inf):
                        UnlexerRule(src=self.model.charset(current, 2, self._charsets[8]), parent=current)
        self.exit_rule(current)
        return current
    FLOAT.min_depth = 0

    @depthcontrol
    def WS(self, parent=None):
        current = UnlexerRule(name='WS', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.model.charset(current, 0, self._charsets[9]), parent=current)
        self.exit_rule(current)
        return current
    WS.min_depth = 0

    default_rule = prog

    _charsets = {
        0: list(chain.from_iterable([range(32, 127)])),
        1: list(chain.from_iterable([range(32, 127)])),
        2: list(chain.from_iterable([range(32, 34), range(35, 127)])),
        3: list(chain.from_iterable([range(97, 123)])),
        4: list(chain.from_iterable([range(65, 91)])),
        5: list(chain.from_iterable([range(48, 58)])),
        6: list(chain.from_iterable([range(48, 58)])),
        7: list(chain.from_iterable([range(48, 58)])),
        8: list(chain.from_iterable([range(48, 58)])),
        9: list(chain.from_iterable([range(9, 10), range(10, 11), range(13, 14), range(32, 33)])),
    }
